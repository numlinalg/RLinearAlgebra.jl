var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"N. Halko, P. G. Martinsson and J. A. Tropp. Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review 53, 217–288 (2011).\n\n\n\nD. P. Woodruff. Sketching as a tool for numerical linear algebra. Foundations and Trends in Theoretical Computer Science 10, 1–157 (2014).\n\n\n\nN. Ailon and B. Chazelle. The Fast Johnson–Lindenstrauss Transform and Approximate Nearest Neighbors. SIAM Journal on Computing 39, 302–322 (2009).\n\n\n\nP.-G. Martinsson and J. Tropp. Randomized Numerical Linear Algebra: Foundations &amp; Algorithms (2020).\n\n\n\nJ. A. Tropp. Improved Analysis of the Subsampled Randomized Hadamard Transform. Advances in Adaptive Data Analysis 03, 115–126 (2011).\n\n\n\nT. Strohmer and R. Vershynin. A Randomized Kaczmarz Algorithm with Exponential Convergence. Journal of Fourier Analysis and Applications 15, 262–278 (2009).\n\n\n\nD. Needell and J. A. Tropp. Paved with Good Intentions: Analysis of a Randomized Block Kaczmarz Method. Linear Algebra and its Applications 441, 199–221 (2014).\n\n\n\nV. Patel, M. Jahangoshahi and D. A. Maldonado. Randomized Block Adaptive Linear System Solvers. SIAM Journal on Matrix Analysis and Applications 44, 1349–1369 (2023).\n\n\n\nT. S. Motzkin and I. J. Schoenberg. The Relaxation Method for Linear Inequalities. Canadian Journal of Mathematics 6, 393–404 (1954).\n\n\n\n","category":"page"},{"location":"api/sub_solvers/#SubSolvers","page":"SubSolvers API","title":"SubSolvers","text":"","category":"section"},{"location":"api/sub_solvers/","page":"SubSolvers API","title":"SubSolvers API","text":"Pages = [\"sub_solvers.md\"]","category":"page"},{"location":"api/sub_solvers/#Abstract-Types","page":"SubSolvers API","title":"Abstract Types","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.SubSolver","page":"SubSolvers API","title":"RLinearAlgebra.SubSolver","text":"SubSolver\n\nAn abstract supertype for structures specifying solution methods for a linear system or least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.SubSolverRecipe","page":"SubSolvers API","title":"RLinearAlgebra.SubSolverRecipe","text":"SubSolverRecipe\n\nAn abstract supertype for structures with pre-allocated memory for methods that solve a linear system or least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#SubSolver-Structures","page":"SubSolvers API","title":"SubSolver Structures","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.LQSolver","page":"SubSolvers API","title":"RLinearAlgebra.LQSolver","text":"LQSolver <: SubSolver\n\nA type containing information relevant to solving the linear subsystems created by the      Solver routines with the LQ factorization. As there are no user controlled parameters,      if the user wishes to use this method they can simply specify LQSolver().\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.LQSolverRecipe","page":"SubSolvers API","title":"RLinearAlgebra.LQSolverRecipe","text":"LQSolverRecipe <: SubSolverRecipe{M<:AbstractArray}\n\nA mutable type containing informtation relevant to solving the linear subsytems created by      the Solver routines with the LQ factorization.\n\nFields\n\nA::M, The matrix in the linear system that will be solved with the LQ solver.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.QRSolver","page":"SubSolvers API","title":"RLinearAlgebra.QRSolver","text":"QRSolver <: SubSolver\n\nA type containing information relevant to solving the linear subsystems created by the      Solver routines with the QR factorization. As there are no user controlled parameters,      if the user wishes to use this method they can simply specify QRSolver().\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.QRSolverRecipe","page":"SubSolvers API","title":"RLinearAlgebra.QRSolverRecipe","text":"QRSolverRecipe{M<:AbstractArray} <: SubSolverRecipe\n\nA mutable type containing information relevant to solving the linear subsystems created by      the Solver routines with the QR factorization.\n\nFields\n\nA::M, The matrix in the linear system that will be solved with the QR solver.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#Exported-Functions","page":"SubSolvers API","title":"Exported Functions","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.complete_sub_solver","page":"SubSolvers API","title":"RLinearAlgebra.complete_sub_solver","text":"complete_sub_solver(solver::SubSolver, A::AbstractArray)\n\nA function that generates a SubSolverRecipe given the      arguments.\n\nArguments\n\nsolver::SubSolver, a user-specified sub-solving method.\nA::AbstractArray, a coefficient matrix or vector. \n\nReturns\n\nA SubSolverRecipe object.\n\n\n\n\n\ncomplete_sub_solver(solver::SubSolver, A::AbstractArray, b::AbstractArray)\n\nA function that generates a SubSolverRecipe given the      arguments.\n\nArguments\n\nsolver::SubSolver, a user-specified sub-solving method.\nA::AbstractArray, a coefficient matrix or vector. \nb::AbstractArray, a constant matrix or vector. \n\nReturns\n\nA SubSolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/sub_solvers/#RLinearAlgebra.update_sub_solver!","page":"SubSolvers API","title":"RLinearAlgebra.update_sub_solver!","text":"update_sub_solver!(solver::SubSolverRecipe, A::AbstractArray)\n\nA function that updates the SubSolver in place given      arguments.\n\nArguments\n\nsolver::SubSolverRecipe, a fully initialized realization for a   linear sub-solver.\nA::AbstractArray, a coefficient matrix or vector. \n\nReturns\n\nModifies the SubSolverRecipe in place given the arguments.and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#Compressors-Reference","page":"Compressors API","title":"Compressors Reference","text":"","category":"section"},{"location":"api/compressors/","page":"Compressors API","title":"Compressors API","text":"Pages = [\"compressors.md\"]","category":"page"},{"location":"api/compressors/#Abstract-Types","page":"Compressors API","title":"Abstract Types","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.Compressor","page":"Compressors API","title":"RLinearAlgebra.Compressor","text":"Compressor\n\nAn abstract supertype for structures that contain user-controlled parameters corresponding to techniques that compress a matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CompressorRecipe","page":"Compressors API","title":"RLinearAlgebra.CompressorRecipe","text":"CompressorRecipe\n\nAn abstract supertype for structures that contain both the user-controlled parameters in the Compressor and the memory allocations necessary for applying the compression technique to a particular set of matrices and vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CompressorAdjoint","page":"Compressors API","title":"RLinearAlgebra.CompressorAdjoint","text":"CompressorAdjoint{S<:CompressorRecipe}\n\nA structure for the adjoint of a compression recipe.\n\nFields\n\nParent::CompressorRecipe, the CompressorRecipe the adjoint is being applied to.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Cardinality","page":"Compressors API","title":"RLinearAlgebra.Cardinality","text":"Cardinality\n\nAn abstract type for types that specify whether a compressor will be applied from the left or the right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Left","page":"Compressors API","title":"RLinearAlgebra.Left","text":"Left <: Cardinality\n\nA struct indicating matrix multiplication from the left.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Right","page":"Compressors API","title":"RLinearAlgebra.Right","text":"Right <: Cardinality\n\nA struct indicating matrix multiplication from the right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Undef","page":"Compressors API","title":"RLinearAlgebra.Undef","text":"Undef <: Cardinality\n\nA struct indicating matrix multiplication is undefined.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#Compressor-Structures","page":"Compressors API","title":"Compressor Structures","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.CountSketch","page":"Compressors API","title":"RLinearAlgebra.CountSketch","text":"CountSketch <: Compressor\n\nAn implementation of the count sketch compression method. See additional details in  [2] Section 2.1, in which the CountSketch matrix is equivalently defined as sparse  embedding matrix.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from  the left (i.e., we reduce the number of rows), then we construct a Count Sketch matrix S with  dimension s times m, where s is the user-specified compression dimension. Each column of  S is generated independently by the following steps:\n\nRandomly select an integer between 1 and s to determine the row position of the nonzero entry.\nAssign this entry a value of either +1 or -1, chosen uniformly at random.\nSet all the other entries in the column to zero.\n\nAs a result, each column of S has exactly one nonzero element.\n\nIf A is compressed from the right, then we construct a Count Sketch matrix S with dimension  n times s, where s is the user-specified compression dimension. Each row of S is  generated independently using the following steps:\n\nRandomly select an integer between 1 and s to determine the column position of the nonzero entry.\nAssign this entry a value of either +1 or -1, chosen uniformly at random.\nSet all other entries in the row to zero.\n\nIn this case, each row of S has exactly one nonzero entry.  The compressed matrix is then formed by multiplying S A (for left compression) or A S (for right compression).\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nCountSketch(;carinality=Left(), compression_dim=2, type=Float64)\n\nKeywords\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\ntype::Type{<:Number}, the type of the elements in the compressor. By default is set   to Float64.\n\nReturns\n\nA CountSketch object.\n\nThrows\n\nArgumentError if compression_dim is non-positive\nArgumentError if Undef() is taken as the input for cardinality\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CountSketchRecipe","page":"Compressors API","title":"RLinearAlgebra.CountSketchRecipe","text":"CountSketchRecipe <: CompressorRecipe\n\nThe recipe containing all allocations and information for the CountSketch compressor.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The    value is either Left() or Right().\ncompression_dim::Int64, the target compression dimension.\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64`, the number of columns of the compression matrix.\nmat::SparseMatrixCSC, the compression matrix stored in a sparse form.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.FJLT","page":"Compressors API","title":"RLinearAlgebra.FJLT","text":"FJLT <: Compressor\n\nAn implementation of the Fast Johnson-Lindenstrauss Transform method. This technique applies a sparse matrix, a Walsh-Hadamard transform, and a diagonal sign matrix to produce a sketch.  See [3] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Here S=KHD where \n\nK is a sparse matrix with  with dimension s times m, where each entry has    probability q of being non-zero, and, if it is non-zero, then its value is    drawn from an independent normal distribution with mean 0 and variance 1q;\nH is a Hadamard matrix of dimension m times m, which is implicitly applied    through the fast Walsh-Hadamard transform;\nD of is a diagonal matrix of dimension m times m with entries given by    independent Rademacher variables.\n\nIf we want to compress A from the right (i.e., we reduce the number of columns), then  we would apply S=DHK from the right where the dimensions of the matrices are adjusted  to reflect the number of columns in A.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nblock_size::Int64, the number of vectors in the padding matrix.\nsparsity::Int64, the desired sparsity of the matrix K.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nFJLT(;\n    cardinality=Left(),\n    compression_dim::Int64=2,\n    block_size::Int64=10,\n    sparsity::Float64=0.0,\n    type::Type{N}=Float64,\n) where {N<:Number}\n\nKeywords\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description. By default this is set to 2.\nblock_size::Int64, the number of vectors in the padding matrix.\nsparsity::Int64, the desired sparsity of the matrix K, by default sparsity will be    set to be minleft(14 log(n)^2  m 1right), see [3].\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA FJLT object.\n\nThrows\n\nArgumentError if compression_dim is non-positive, if sparsity is not in 01,   or if block_size is non-positive.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.FJLTRecipe","page":"Compressors API","title":"RLinearAlgebra.FJLTRecipe","text":"FJLTRecipe{C<:Cardinality, S<:SparseMatrixCSC, M<:AbstractMatrix} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the FJLT compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are Left() or Right().\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nsparsity:Float64, the sparsity, q, of the sparse component, K.\nscale::Float64, the factor to ensure the isopmorphism of the sketch.\nop::SparseMatrixCSC, the sparse matrix K in the mathematical description.\nsigns::BitVector, the vector of signs where 0 indicates negative one and 1 indicates   positive one. \npadding::AbstractMatrix, the matrix containing the padding for the matrix being sketched.\n\nConstructor\n\nFJLTRecipe(\n    compression_dim::Int64, \n    block_size::Int64,\n    cardinality::C where {C<:Cardinality},\n    sparsity::Float64,\n    A::AbstractMatrix, \n    type::Type{<:Number}\n)\n\nKeywords\n\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\nblock_size::Int64, the number of columns in the padding memory buffer.\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\nsparsity::Vector{Number}, the expected sparsity of the Sparse operator matrix.\nA::AbstractMatrix, the matrix being compressed.\ntype::Type{<:Number}, the type of elements in the compressor.\n\ninfo: Info\nIf the sparsity parameter is set to 0.0, then the sparsity will be set to  minleft(14 log(n)^2  m 1right), see [3].\n\nReturns\n\nA FJLTRecipe object.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Gaussian","page":"Compressors API","title":"RLinearAlgebra.Gaussian","text":"Gaussian <: Compressor\n\nA specification for a Gaussian compressor.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress.\n\nIf we want to compress A from the left (i.e., we reduce the number of rows), then we create a Gaussian sketch matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Each entry of S is generated independently following N(0, 1/s), namely, a Gaussian distribution with mean being zero and variance being 1 divided by the compression dimension.\n\nIf A is compressed from the right, then we create a Gaussian sketch matrix, S, with dimension n times s, where s is the compression dimension that is supplied by the user. Each entry of S is generated independently following N(0, 1/s), namely, a Gaussian distribution with mean being zero and variance being 1 divided by the compression dimension.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in    the mathematical description.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nGaussian(;cardinality=Left(), compression_dim=2, type=Float64)\n\nArguments\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in    the mathemtical description. By default this is set to 2.\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA Gaussian object.\n\nThrows\n\nArgumentError if compression_dim is non-positive\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.GaussianRecipe","page":"Compressors API","title":"RLinearAlgebra.GaussianRecipe","text":"GaussianRecipe <: CompressorRecipe\n\nThe recipe containing all allocations and information for the Gaussian compressor.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The\n\nvalue is either Left() or Right().\n\ncompression_dim::Int64, the target compression dimension.\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nscale::Number, the standard deviation of Gaussian distribution during the \n\ncompression matrix generation.\n\nop::Matrix{Float64}, the Gaussian compression matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Sampling","page":"Compressors API","title":"RLinearAlgebra.Sampling","text":"Sampling <: Compressor\n\nThis method subsets the rows  or columns of a matrix according to a user-supplied distribution. The size of the  subset is also provided by the user.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress.\n\nIf we want to compress A from the left (i.e., we reduce the number of rows), then we create an index set to contain all the indices of selected rows. The indices are  chosen by sampling over all the rows with the user-specified distribution in the  distribution field.\n\nIf A is compressed from the right (i.e., we reduce the number of columns), then we create an index set to contain all the indices of selected columns. The indices  are chosen by sampling over all the columns with the user-specified distribution  in the distribution field.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension.\ndistribution::Distribution, the distribution being used to assign probability weights   on the indices.\n\nConstructor\n\nSampling(;cardinality = Left(), compression_dim = 2, distribution)\n\nArguments\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. By default this is set to 2.\ndistribution::Distribution, the distribution being used to assign probability weights   on the indices. By default this is set as Uniform distribution.\n\nReturns\n\nA Sampling object.\n\nThrows\n\nArgumentError if compression_dim is non-positive\nArgumentError if Undef() is taken as the input for cardinality\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SamplingRecipe","page":"Compressors API","title":"RLinearAlgebra.SamplingRecipe","text":"SamplingRecipe{C<:Cardinality} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the sampling compressor. \n\nFields\n\ncardinality::Cardinality, the cardinality of the compressor. The   value is either Left() or Right().\ncompression_dim::Int64, the target compression dimension.\nn_rows::Int64, number of rows of compression matrix.\nn_cols::Int64, number of columns of compression matrix.\ndistribution_recipe::DistributionRecipe, the user-specified distribution recipe.\nidx::Vector{Int64}, the index set that contains all the chosen indices.\nidx_v::SubArray, the view of the idx.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SparseSign","page":"Compressors API","title":"RLinearAlgebra.SparseSign","text":"SparseSign <: Compressor\n\nAn implementation of the sparse sign compression method. This method forms a sparse matrix with a fixed number of non-zeros per row or column depending on the direction that the compressor is being applied. See Section 9.2 of [4] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a sparse sign matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. In this case, each column of S is generated independently by the following steps:\n\nRandomly choose nnz components of the the s components of the column. Note, nnz  is supplied by the user.\nFor each selected component, randomly set it either to -1sqrttextnnz or  1sqrttextnnz with equal probability.\nSet the remaining components of the column to zero.\n\nIf A is compressed from the right, then we create a sparse sign matrix, S, with dimension n times s, where s is the compression dimension that is supplied by the user. In this case, each row of S is generated independently by the following steps:\n\nRandomly choose nnz components fo the s components of the row. Note, nnz  is supplied by the user.\nFor each selected component, randomly set it either to -1sqrttextnnz or  1sqrttextnnz with equal probability.\nSet the remaining components of the row to zero.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nnnz::Int64, the target number of nonzeros for each column or row of the spares sign   matrix.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nSparseSign(;carinality=Left(), compression_dim=2, nnz::Int64=8, type=Float64)\n\nKeywords\n\ncarinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\nnnz::Int64, the number of non-zeros per row/column in the sampling matrix. By default   this is set to min(compressiond_dim, 8).\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA SparseSign object.\n\nThrows\n\nArgumentError if compression_dim is non-positive, if nnz is exceeds   compression_dim, or if nnz is non-positive.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SparseSignRecipe","page":"Compressors API","title":"RLinearAlgebra.SparseSignRecipe","text":"SparseSignRecipe{C<:Cardinality} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the SparseSign compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to\n\nbe applied to a target matrix or operator. Values allowed are Left() or Right().\n\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nnnz::Int64, the number of non-zero entries in each row if cardinality==Left or the\n\nnumber of non-zero entries each column if cardinality==Right.\n\nscale::Vector{Number}, the set of values of the non-zero entries of the Spares Sign\n\ncompression matrix.\n\nop::SparseMatrixCSC, the Spares Sign compression matrix.\n\nConstructors\n\nSparseSignRecipe(\n    cardinality::C where C<:Cardinality,\n    compression_dim::Int64, \n    A::AbstractMatrix, \n    nnz::Int64, \n    type::Type{<:Number}\n)\n\nAn external constructor of SparseSignRecipe that is dispatched based on the  value of cardinality. See SparseSign for additional details. \n\nArguments\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The    value is either Left() or Right()\ncompression_dim::Int64, the target compression dimension.\nA::AbstractMatrix, a target matrix for compression. \nnnz::Int64, the number of nonzeros in the Sparse Sign compression matrix.\ntype::Type{<:Number}, the data type for the entries of the compression matrix.\n\nReturns\n\nA SparseSignRecipe object.\n\nwarning: Use `complete_compressor`\nWhile an external constructor is provided, it is mainly for internal use. To ensure cross library compatibility please use complete_compressor for forming the SparseSignRecipe.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SRHT","page":"Compressors API","title":"RLinearAlgebra.SRHT","text":"SRHT <: Compressor\n\nAn implementation of the Subsampled Randomized Hadamard Transform (SRHT) method. This  technique applies a subsampling matrix, a Walsh-Hadamard transform, and a diagonal sign  matrix to produce a sketch. See [5] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Here S=KHD where \n\nK is a matrix with  with dimension s times m, where the rows are made up of a    random sample of the rows of a m times m identity matrix.\nH is a Hadamard matrix of dimension m times m, which is implicitly applied    through the fast Walsh-Hadamard transform;\nD of is a diagonal matrix of dimension m times m with entries given by    independent Rademacher variables.\n\nIf we want to compress A from the right (i.e., we reduce the number of columns), then  we would apply S=DHK from the right where the dimensions of the matrices are adjusted  to reflect the number of columns in A.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nblock_size::Int64, the number of vectors in the padding matrix.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nSRHT(;\n    cardinality = Left(),\n    compression_dim::Int64=2,\n    block_size::Int64=10,\n    type::Type{N}=Float64\n) where {N <: Number}\n\nKeywords\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description. By default this is set to 2.\nblock_size::Int64, the number of vectors in the padding matrix.\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA SRHT object.\n\nThrows\n\nArgumentError if compression_dim is non-positive or if block_size is non-positive.\nArgumentError if Cardinality is not either Left or Right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SRHTRecipe","page":"Compressors API","title":"RLinearAlgebra.SRHTRecipe","text":"SRHTRecipe{C<:Cardinality, M<:AbstractMatrix} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the SRHT compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are Left() or Right().\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nscale::Float64, the factor to ensure the isopmorphism of the sketch.\nop::Vector{Int64}, the vector of indices to be subsampled.\nsigns::BitVector, the vector of signs where 0 indicates negative one and 1 indicates   positive one. \npadding::AbstractMatrix, the matrix containing the padding for the matrix being    sketched.\n\nConstructor\n\nSRHTRecipe(\n    compression_dim::Int64,\n    block_size::Int64,\n    cardinality::Left,\n    A::AbstractMatrix,\n    type::Type{<:Number}\n)\n\nKeywords\n\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nblock_size::Int64, the number of vectors in the padding matrix.\ncardinality::Left, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\nA::AbstractMatrix, the matrix being compressed.\ntype::Type{<:Number}, the type of elements in the compressor.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#Exported-Functions","page":"Compressors API","title":"Exported  Functions","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.complete_compressor","page":"Compressors API","title":"RLinearAlgebra.complete_compressor","text":"complete_compressor(compressor::Compressor, A::AbstractMatrix)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nA::AbstractMatrix, a target matrix for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\ncomplete_compressor(compressor::Compressor, A::AbstractMatrix, b::AbstractVector)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\ncomplete_compressor(\n    compressor::Compressor, \n    x::AbstractVector\n    A::AbstractMatrix, \n    b::AbstractVector, \n)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nx::AbstractVector, a vector that ususally represents a current iterate    typically used in a solver.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.update_compressor!","page":"Compressors API","title":"RLinearAlgebra.update_compressor!","text":"update_compressor!(S::CompressorRecipe)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(S::CompressorRecipe, A::AbstractMatrix)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nA::AbstractMatrix, a target matrix for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(S::CompressorRecipe, A::AbstractMatrix, b::AbstractVector)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(\n    S::CompressorRecipe, \n    A::AbstractMatrix, \n    b::AbstractVector,\n    x::AbstractMatrix\n)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nx::AbstractVector, a vector that ususally represents a current iterate    typically used in a solver.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#Internal-Functions","page":"Compressors API","title":"Internal Functions","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.left_mul_dimcheck","page":"Compressors API","title":"RLinearAlgebra.left_mul_dimcheck","text":"left_mul_dimcheck(C::AbstractMatrix, S::CompressorRecipe, A::AbstractMatrix)\n\nA function that checks the compatibility of arguments for      multiplication from the left.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nS::Union{CompressorRecipe, ApproximatorRecipe}, a fully    initialized realization for a compression or approximator method for a    specific AbstractArray or operator.\nA::AbstractArray, a target AbstractArray for compression.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\nleft_mul_dimcheck(C::AbstractMatrix, S::CompressorAdjoint, A::AbstractMatrix)\n\nA function that checks the compatibility of arguments for      multiplication from the left.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nS::Union{CompressorAdjoint, ApproximatorAdjoint}, the    representation of an adjoint of a compression or approximator operator.\nA::AbstractArray, a target AbstractArray for compression.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.right_mul_dimcheck","page":"Compressors API","title":"RLinearAlgebra.right_mul_dimcheck","text":"right_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix, S::CompressorRecipe)\n\nA function that checks the compatibility of arguments for      multiplication from the right.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nA::AbstractArray, a target AbstractArray for compression.\nS::Union{CompressorRecipe, ApproximatorRecipe}, a fully    initialized realization for a compression or approximator method for a    specific AbstractArray or operator.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\nright_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix, S::CompressorAdjoint)\n\nA function that checks the compatibility of arguments for      multiplication from the right.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nA::AbstractArray, a target AbstractArray for compression.\nS::Union{CompressorAdjoint, ApproximatorAdjoint}, the    representation of an adjoint of a compression or approximator operator.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.sparse_idx_update!","page":"Compressors API","title":"RLinearAlgebra.sparse_idx_update!","text":"sparse_idx_update!(\n    values::Vector{Int64}, \n    max_sample_val::Int64, \n    n_samples::Int64, \n    sample_size::Int64\n)\n\nImplicitly splits values into n_samples components of size sample_size.  On each component, replaces the entries of each component with a random sample  without replacement of size sample_size from the set 1:max_sample_val.\n\nwarn: Warn\nvalues should have length equal to sample_size*n_samples, but this  is not checked. \n\nArguments\n\nvalues::Vector{Int64}, a vector containing samples from 1:max_sample_val.\nmax_sample_val::In64, implicitly supplies the set from which to sample,   1:max_sample_val.\nn_samples::Int64, the number of components that values is implicitly split into. \nsample_size::Int64, the size each component that values is split into.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.fwht!","page":"Compressors API","title":"RLinearAlgebra.fwht!","text":"fwht!(x::AbstractVector, signs::BitVector; scaling::Int64 = 1)\n\nPerforms an in-place Fast Walsh Hadamard Transform on the vector x.   signs allows the user to input a boolean vector that flips the signs of the entries  of the vector x before applying the transform. scaling allows the user to scale the  result of the transform. Choosing a scaling of 1/sqrt{size(x)} will result in the FWHT  being an orthogonal transform.\n\nArguments\n\nx::AbstractVector, the vector the FJLT will be applied to.\nsigns::Vector{Bool}, whether the sign of each entry is positive or negative.\n\nKeywords\n\nscaling::Number, how much the vector is scaled, by default this is 1.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#Loggers","page":"Loggers API","title":"Loggers","text":"","category":"section"},{"location":"api/loggers/","page":"Loggers API","title":"Loggers API","text":"Pages = [\"loggers.md\"]","category":"page"},{"location":"api/loggers/#Abstract-Types","page":"Loggers API","title":"Abstract Types","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.Logger","page":"Loggers API","title":"RLinearAlgebra.Logger","text":"Logger\n\nAn abstract supertype for structures that record the progress of a SolverRecipe applied to a coefficient matrix and constant vector.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#RLinearAlgebra.LoggerRecipe","page":"Loggers API","title":"RLinearAlgebra.LoggerRecipe","text":"LoggerRecipe\n\nAn abstract supertype for a structure that contains pre-allocated memory for a method that records the progress of a SolverRecipe.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#Logger-Structures","page":"Loggers API","title":"Logger Structures","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.BasicLogger","page":"Loggers API","title":"RLinearAlgebra.BasicLogger","text":"BasicLogger <: Logger\n\nThis is a mutable struct that contains the max_it parameter and stores the error metric      in a vector. Checks convergence of the solver based on the log information.\n\nFields\n\nmax_it::Int64, The maximum number of iterations for the solver. If not specified by the  user, it is set to 3 times the number of rows in the matrix.\nthreshold_info::Union{Float64, Tuple}, The parameters used for stopping the algorithm.\ncollection_rate::Int64, the rate that history is gathered. (Note: The last value is   always recorded.)\nstopping_criterion::Function, function that evaluates the stopping criterion.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#RLinearAlgebra.BasicLoggerRecipe","page":"Loggers API","title":"RLinearAlgebra.BasicLoggerRecipe","text":"BasicLoggerRecipe <: LoggerRecipe\n\nThis is a mutable struct that contains the max_it parameter and stores the error metric      in a vector. Checks convergence of the solver based on the log information.\n\nFields\n\nmax_it::Int64, The maximum number of iterations for the solver.\nerror::Float64, The current error metric.\nthreshold_info::Union{Float64, Tuple}, The parameters used for stopping the algorithm.\niteration::Int64, the current iteration of the solver.\nrecord_location::Int64, the location in the history vector of the most recent entry.\ncollection_rate::Int64, the rate that history is gathered. (Note: The last value is   always recorded.)\nconverged::Bool, A boolean indicating whether the stopping criterion is satisfied.\nStoppingCriterion::Function, function that evaluates the stopping criterion.\nhist:AbstractVector, vector that contains the history of the error metric.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#Exported-Functions","page":"Loggers API","title":"Exported Functions","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.complete_logger","page":"Loggers API","title":"RLinearAlgebra.complete_logger","text":"complete_logger(logger::Logger)\n\nA function that generates a LoggerRecipe given the      arguments.\n\nArguments\n\nlogger::Logger, a user-specified logging method.\n\nReturns\n\nA LoggerRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.update_logger!","page":"Loggers API","title":"RLinearAlgebra.update_logger!","text":"update_logger!(logger::LoggerRecipe, err::Float64, iteration::Int64)\n\nA function that updates the LoggerRecipe in place given      arguments.\n\nArguments\n\nlogger::LoggerRecipe, a fully initialized realization for a    logging method for a specific linear or least squares solver.\nerr::Real, an error value to be logged. \niteration::Int64, the iteration of the solver. \n\nReturns\n\nPerforms an inplace update to the LoggerRecipe and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.reset_logger!","page":"Loggers API","title":"RLinearAlgebra.reset_logger!","text":"reset_logger!(logger::LoggerRecipe)\n\nA function that resets the LoggerRecipe in place.\n\nArguments\n\nlogger::LoggerRecipe, a fully initialized realization for a    logging method for a specific linear or least squares solver.\n\nReturns\n\nPerforms an inplace update to the LoggerRecipe and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.threshold_stop","page":"Loggers API","title":"RLinearAlgebra.threshold_stop","text":"threshold_stop(log::BasicLoggerRecipe)\n\nFunction that takes an input threshold and stops when the most recent entry in the history vector is less than the threshold.\n\nArguments\n\nlog::LoggerRecipe, a structure containing the logger information\n\nBool\n\nReturns a Bool indicating if the stopping threshold is satisfied.\n\n\n\n\n\n","category":"function"},{"location":"manual/introduction/#A-library-for-exploring-Randomized-Linear-Algebra","page":"Introduction","title":"A library for exploring Randomized Linear Algebra","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"If you are here, you probably know that Linear Algebra is foundational to data science and  scientific computing. You also probably know Linear Algebra routines dominate the  computational cost of many of the algorithms in these fields. Thus, improving the  scalability of these algorithms requires more scalable Linear Algebra techniques.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"An exciting new set of techniques that offers such improved scalability of  Linear Algebra techniques are Randomized Linear Algebra techniques.  In general, Randomized Linear Algebra techniques aim to achieve this improved scalability by forming a representative sample of a matrix and performing  operations on that sample. In some circumstances operating on this sample can offer profound speed-ups as can see in the following example  where a technique known as the RandomizedSVD (see [1])  is used to compute a rank-20 approximation to 3000 times 3000 matrix  A in place of a truncated SVD. Compared to computing the SVD and  truncating it, the RandomizedSVD is 100 times faster and just as accurate  as the truncated SVD.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"using RLinearAlgebra\nusing LinearAlgebra\n\n# Generate a rank-20 matrix\nA = randn(3000, 20) * randn(20, 3000);\n\n@time U,S,V = svd(A);\n#    4.566639 seconds (13 allocations: 412.354 MiB, 0.92% gc time)\n\n# Form the RandomizedSVD data structure\ntechnique = RandSVD(\n    compressor = Gaussian(compression_dim= 22,  cardinality=Right()), \n    orthogonalize=false, \n    power_its = 0\n)\n\n# Take the RandomizedSVD of A\n@time rec = rapproximate(technique, A);\n#    0.050950 seconds (39 allocations: 5.069 MiB)\n\n# Take the norm of the difference between the RandomizedSVD and TrunctatedSVD at rank 22\nnorm(rec.U * Diagonal(rec.S) * rec.V' - U[:,1:22] * Diagonal(S[1:22]) * (V[:, 1:22])')\n# 6.914995919005829e-11","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Over the years, numerous Randomized Linear Algebra approaches have been proposed not only for basic linear tasks such as computing a low-rank approximation to a matrix, solving  a linear system, or solving a least squares problem, but also for how obtain a  representative sample of the matrix itself. To this point, a single easy to prototype  library has not been developed to bring these techniques to the masses. RLinearAlgebra.jl is  designed to be exactly such an easy-to-use library.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"In particular, RLinearAlgebra.jl leverages a modular design to allow you  to easily test Randomized Linear Algebra routines under a wide-range of parameter choices.   RLinearAlgebra.jl provides routines for two core Linear Algebra tasks: finding a solution to a linear system via Ax=b or min_x Ax - b and forming a low rank  approximation to a matrix, hat A where hat A approx A. The solution to a linear system appears everywhere: Optimization, Tomography, Statistics, Scientific Computing,  Machine Learning, etc. The low-rank approximation problem has only become more relevant in  recent years owing to the drastic increase in matrix sizes. It has been widely used in  Statistics via PCA, but also has become increasingly more relevant in all the fields where  solving a linear system is relevant. ","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"This manual will walk you through the use of the RLinearAlgebra.jl library. The remainder  of this section will be focused on providing an overview of the common design elements in  the library, and information about how to get started using the library.","category":"page"},{"location":"manual/introduction/#Overview-of-the-Library","page":"Introduction","title":"Overview of the Library","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"The library is based on two data structure types: techniques that contain the parameters  that define a particular method and technique recipes that contain these parameters and  the necessary preallocations for the desired technique to be executed efficiently. As the  user you only need to define the techniques and the library will do all the work to form the recipes for you. If you wish to convert a technique into a technique recipe you can use the complete_[technique type] function.","category":"page"},{"location":"manual/introduction/#The-Technique-Types","page":"Introduction","title":"The Technique Types","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"With an understanding of the basic structures in the library, one may wonder, what  types of techniques are there? First, there are the techniques for solving the linear  system, Solvers and techniques for forming a low-rank approximation to a matrix,  Approximators. Both Solvers and Approximators achieve speedups by working on  compressed forms (often known as sketched or sampled) of the linear system, techniques that  compress the linear system are known as Compressors. Aside from these global techniques,  there are also techniques that are specific to Solvers, which include: ","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"SubSolvers, techniques that solve the inner (compressed) linear system.\nLoggers, techniques that log information and determine whether a stopping criterion has  been met.\nSolverError, a technique that computes the error of a current iterate of a solver.  ","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Similarly, Approximators have their own specific techniques, which include:","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"ApproximorError, a technique that computes the error of an Approximator.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"With all these technique structures, you may be wondering, what functions can I call on these structures? Well, the answer is not many. As is  summarized in the following table.  ","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Technique Parent Technique Function Calls\nApproximator None complete_approximator,rapproximate\nCompressor None complete_compressor\nSolver None complete_solver, rsolve\nApproximatorError Approximator complete_approximator_error\nLogger Solver complete_logger\nSolverError Solver complete_solver_error\nSubSolver Solver complete_sub_solver","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"From the above table we can see that essentially all you are able to do unless you are using  an Approximator or a Solver is complete the technique. The reason being that all the  technique structures contain only information about algorithmic parameters that require no  information about the linear system. The recipes on the other hand have all the information  required to use a technique including the required pre-allocated memory. We determine the  preallocations for the Recipes by merging the parameter information of the technique  structures with the matrix and linear system information via the complete_[technique]  functions, which is the only function that you can call when you have a technique structure.  There is a special exception for rsolve and rapproximate because they implicitly call  all the necessary completes to form the appropriate recipe. The bottom line is that do  anything useful you will need a recipe.","category":"page"},{"location":"manual/introduction/#The-Recipe-Types","page":"Introduction","title":"The Recipe Types","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Every technique can be transformed into a recipe. As has been stated before, what makes the  recipes different is that they contain all the required memory allocations. These  allocations can only be determined from once the matrix is known. As a user,  all you have to know is that as soon as you have a recipe you can do a lot. As can be seen  in the following table.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Technique Recipe Parent Recipe Function Calls\nApproximator None mul!, rapproximate!\nCompressor None mul!,update_compressor!\nSolver None rsolve!\nApproximatorError Approximator compute_approximator_error\nLogger Solver reset_logger!, update_logger!\nSolverError Solver compute_error\nSubSolver Solver update_sub_solver!,ldiv!","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Instead of providing  a different function for each method associated with these tasks, RLinearAlgebra.jl  leverages the multiple-dispatch functionality of Julia to allow all linear systems and  least squares problems to be solved calling the function  rsolve(solver::Solver, x::AbstractVector, A::AbstractMatrix, b::AbstractVector)  and all matrices to be approximated by calling the function  rapproximate(approximator::Approximator, A::AbstractMatrix). Under this design, changing  the routine for solving your linear system or approximate your matrix is as  simple as changing thesolver or approximator arguments. ","category":"page"},{"location":"manual/introduction/#Installing-RLinearAlgebra","page":"Introduction","title":"Installing RLinearAlgebra","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Currently, RLinearAlgebra.jl is not registered in Julia's official package registry.  It can be installed by writing in the REPL:","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"] add https://github.com/numlinalg/RLinearAlgebra.jl.git","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"It can also be cloned into a local directory and installed by:","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"cd into the local project directory \nCall git clone https://github.com/numlinalg/RLinearAlgebra.jl.git\nRun Julia\nCall using Pkg\nCall Pkg.activate(RLinearAlgebra.jl)\nCall Pkg.instantiate()","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"For more information see  Using someone else's project.","category":"page"},{"location":"manual/introduction/#Using-RLinearAlgebra.jl","page":"Introduction","title":"Using RLinearAlgebra.jl","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"For this example let's assume that we have a vector that we wish to compress using one the RLinearAlgebra.jl SparseSign compressor. To do this: ","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Load RLinearAlgebra.jl and generate your vector\nDefine the SparseSign technique. This requires us to specify a cardinality,  the direction we intend to apply the compressor from, and a compression_dim,   the number of entries we want in the compressed vector. In this instance we   want the cardinality to be Left() and the compression_dim = 20.\nUse the complete_compressor function to generate the SparseSignRecipe.\nApply the compressor to the vector using the multiplication function","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"# Step 1: load RLinearAlgebra.jl and generate vector\nusing RLinearAlgebra\nusing LinearAlgebra\n# Specify the size of the vector\nn = 10000\nx = rand(n)\n\n# Step 2: Define Sparse Sign Compressor\ncomp = SparseSign(compression_dim = 20, cardinality = Left())\n\n# Step 4: Define Sparse Sign Compressor Recipe\nS = complete_compressor(comp, x)\n\n# Step 4: Apply the compressor to the vector using the multiplication function\nSx = S * x\n\nnorm(Sx)\n\nnorm(x)","category":"page"},{"location":"api/distributions/#Distributions","page":"Distributions API","title":"Distributions","text":"","category":"section"},{"location":"api/distributions/","page":"Distributions API","title":"Distributions API","text":"Pages = [\"distributions.md\"]","category":"page"},{"location":"api/distributions/#Abstract-Types","page":"Distributions API","title":"Abstract Types","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.Distribution","page":"Distributions API","title":"RLinearAlgebra.Distribution","text":"Distribution\n\nAn abstract supertype for structures specifying distribution for indices in sampling methods.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#RLinearAlgebra.DistributionRecipe","page":"Distributions API","title":"RLinearAlgebra.DistributionRecipe","text":"DistributionRecipe\n\nAn abstract supertype for structures with pre-allocated memory for distribution function     sampling methods.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#Distribution-Structures","page":"Distributions API","title":"Distribution Structures","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.Uniform","page":"Distributions API","title":"RLinearAlgebra.Uniform","text":"Uniform <: Distribution\n\nUniform distribution over the row/column index set of a matrix.\n\nMathematical Description\n\nDuring the sampling, the uniform distribution is defined on the domain of row/column  indices. If it's compressing from the left, then it means every row index has the same  probability weight. If it's compressing from the right, then it means every column index  has the same probability weight.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right()    or Undef().\nreplace::Bool, if true, then the sampling occurs with replacement; if false,    then the sampling occurs without replacement.\n\nConstructor\n\nUniform(;cardinality=Undef(), replace = false)\n\nReturns\n\nA Uniform object.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#RLinearAlgebra.UniformRecipe","page":"Distributions API","title":"RLinearAlgebra.UniformRecipe","text":"UniformRecipe <: DistributionRecipe\n\nThe recipe containing all allocations and information for the uniform distribution.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The   value is either Left() or Right() or Undef().\nreplace::Bool, an option to replace or not during the sampling process based    on the given weights.\nstate_space::Vector{Int64}, the row/column index set.\nweights::ProbabilityWeights, the weights of each element in the state space.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#Exported-Functions","page":"Distributions API","title":"Exported Functions","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.complete_distribution","page":"Distributions API","title":"RLinearAlgebra.complete_distribution","text":"complete_distribution(distribution::Distribution, A::AbstractMatrix)\n\nA function that generates a DistributionRecipe given the      arguments.\n\nArguments\n\ndistribution::Distribution, a user-specified distribution function for sampling.\nA::AbstractMatrix, a coefficient matrix. \n\nOutputs\n\nA DistributionRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#RLinearAlgebra.update_distribution!","page":"Distributions API","title":"RLinearAlgebra.update_distribution!","text":"update_distribution!(distribution::DistributionRecipe, A::AbstractMatrix)\n\nA function that updates the DistributionRecipe in place given      arguments.\n\nArguments\n\ndistribution::DistributionRecipe, a fully initialized realization of distribution.\nA::AbstractMatrix, a coefficient matrix. \n\nOutputs\n\nModifies the DistributionRecipe in place and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#RLinearAlgebra.sample_distribution!","page":"Distributions API","title":"RLinearAlgebra.sample_distribution!","text":"sample_distribution!(x::AbstractVector, distribution::DistributionRecipe)\n\nA function that in place updates the x by given DistributionRecipe info.\n\nArguments\n\nx::AbstractVector, an abstract vector to store the sampled indices. \ndistribution::DistributionRecipe, a fully initialized realization of distribution.\n\nOutputs\n\nModifies the x in place by sampling that follows the weights and replacement given by \n\n'DistributionRecipe'.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#Internal-Functions","page":"Distributions API","title":"Internal Functions","text":"","category":"section"},{"location":"manual/low_rank_approximators/#Low-Rank-Approximations-of-Matrices","page":"Low-Rank Approximations of Matrices","title":"Low-Rank Approximations of Matrices","text":"","category":"section"},{"location":"manual/low_rank_approximators/","page":"Low-Rank Approximations of Matrices","title":"Low-Rank Approximations of Matrices","text":"Often large matrices contain a lot of redundant information. ","category":"page"},{"location":"manual/low_rank_approximators/#A-RangeFinder-Example","page":"Low-Rank Approximations of Matrices","title":"A RangeFinder Example","text":"","category":"section"},{"location":"manual/low_rank_approximators/","page":"Low-Rank Approximations of Matrices","title":"Low-Rank Approximations of Matrices","text":"Lets say that we wish to obtain a rank-5 RandomizedSVD to matrix with 1000 rows and columns. In RLinearAlgebra.jl we can do this by first generating the RandomizedSVD Approximator. This will require us to specify a Compressor with the desired rank of approximation as the compression_dim and the cardinality=Right(), the number of power iterations we want  to be performed, and the type of power iterations we want to perform. ","category":"page"},{"location":"api/approximators/#Approximators","page":"Approximators API","title":"Approximators","text":"","category":"section"},{"location":"api/approximators/","page":"Approximators API","title":"Approximators API","text":"Pages = [\"approximators.md\"]","category":"page"},{"location":"api/approximators/#Abstract-Types","page":"Approximators API","title":"Abstract Types","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.Approximator","page":"Approximators API","title":"RLinearAlgebra.Approximator","text":"Approximator\n\nAn abstract supertype for structures that store user-controlled parameters corresponding to techniques that form low-rank approximations of the matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.ApproximatorRecipe","page":"Approximators API","title":"RLinearAlgebra.ApproximatorRecipe","text":"ApproximatorRecipe\n\nAn abstract supertype for structures that store user-controlled parameters, linear system dependent parameters and preallocated memory corresponding to techniques that form low-rank approximations of the matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.ApproximatorAdjoint","page":"Approximators API","title":"RLinearAlgebra.ApproximatorAdjoint","text":"ApproximatorAdjoint{S<:ApproximatorRecipe} <: ApproximatorRecipe\n\nA structure for the adjoint of an ApproximatorRecipe.\n\nFields\n\nParent::ApproximatorRecipe, the approximator that we compute the adjoint of.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeApproximator","page":"Approximators API","title":"RLinearAlgebra.RangeApproximator","text":"RangeApproximator\n\nAn abstract type for the structures that contain the user-controlled parameters  corresponding to the Approximator methods that produce an orthogonal approximation to the  range of a matrix A. This includes methods like the RandomizedSVD and  randomized rangefinder.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeApproximatorRecipe","page":"Approximators API","title":"RLinearAlgebra.RangeApproximatorRecipe","text":"RangeApproximatorRecipe\n\nAn abstract type for the structures that contain the user-controlled parameters,  linear system information, and preallocated memory for methods corresponding to the Approximator methods that produce an orthogonal approximation to the range of a matrix A. This includes methods like the RandomizedSVD and  randomized rangefinder.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#Approximator-Structures","page":"Approximators API","title":"Approximator Structures","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.RandSVD","page":"Approximators API","title":"RLinearAlgebra.RandSVD","text":"RandSVD\n\nA struct that implements the Randomized SVD. The Randomized SVD technique compresses a      matrix from the right to compute a rank k estimate to the truncated      SVD of a matrix A. See Algorithm 5.1 in [1] for additional      details.\n\nMathematical Description\n\nSuppose we have a matrix A in mathbbR^m times n for which we wish to form a      low-rank approximation with the form of an SVD. Specifically, we wish to find an      orthogonal matrix, U, a diagonal matrix, Sigma, and an orthogonal matrix,      V such that USigma V^top approx A. This can be done effectively using the      Randomized SVD presented in Algorithm 5.1 of [1].      This algorithm progresses by first having the user select a k  2 to be the      compression_dim of the compressor, which will also correspond to the desired      rank of the approximation. With this k, RandomizedSVD  generates a compression      matrix SinmathbbR^n times k and computes Q = textqr(AS) as in the      RangeFinder. With the Q, the RandomizedSVD      concludes by computing WSigmaV = textSVD(Q^top A) and  setting U = QW.     With high probability the approximation generated by the RandomizedSVD will satisfy      mathbbE A - U Sigma V^top _F leq sqrtk+1       (sum_i=k+1^min(mn)sigma_i)^12     , where sigma_k+1 is the k+1^textth singular value of (see Theorem 10.5      of [1]). This bound is often conservative as long as the singular      values of A decay quickly.\n\nWhen the singular values decay slowly, we can improve the quality of the approximation using the      power iteration, which applies A and A^top, q times      and take the qr factorization of (AA^top)^q AS. Using these power iterations      increases the relative gap between the singular values leading to  better RandomizedSVD      performance. \n\nPerforming power iterations in floating points can destroy all information      related to the smallest singular values of A      (see Remark 4.3 in [1]). We can preserve this information by      orthogonalizing inbetween the products of AS with A or A^top      in the power iteration. These steps are known as the orthogonalized power      iteration (see Algorithm 4.4 of [1]).       Orthogonalized power iterations progress according to the following steps:\n\ntildeA_1 = AS  \nQ_1R_1 = textbfqr(tildeA_1)  \ntildeA_2 = A^top Q_1  \nQ_2R_2 = textbfqr(tildeA_2)  \ntildeA_1 = A Q_2  \nQ_1 R_1 = textbfqr(tildeA_1)  \nRepeat Steps 3 through 6 for the desired number of power iterations  set Q = Q_1.  \n\nFields\n\ncompressor::Compressor, the technique for compressing the matrix from the right.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.    \nblock_size::Int64, the size of the tile when performing matrix multiplication. By    default, block_size = 0, this will be set to be the number of columns in    the original matrix, A.\n\nConstructor\n\nRandSVD(;\n    compressor::Compressor = SparseSign(cardinality = Right()), \n    orthogonalize::Bool  = false, \n    power_its::Int64 = 0,\n    block_size::Int64 = 0,\n)\n\nKeywords\n\ncompressor::Compressor, the technique for compressing the matrix from the right. By    default this is SparseSign with a cardinality Right().\npower_its::Int64, the number of power iterations that should be performed. By default    this is zero.\northogonalize::Bool, a boolean indicating whether the power_its should be performed   with orthogonalization. By default is false. \nblock_size::Int64, the size of the tile when performing matrix multiplication. By    default, block_size = 0, this will be set to be the number of columns in    the original matrix, A. By default this is zero.\n\nReturns\n\nA RandSVD object.\n\nThrows\n\nArgumentError if power_its or block_size are negative.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RandSVDRecipe","page":"Approximators API","title":"RLinearAlgebra.RandSVDRecipe","text":"RandSVDRecipe\n\nA struct that contains the preallocated memory and completed compressor to form a     RandSVD approximation to the matrix A.\n\nFields\n\nn_rows::Int64, the number of rows in the approximation. \nn_cols::Int64, the number of columns in the approximation. \ncompressor::CompressorRecipe, the compressor to be applied from the right to A.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\nU::AbstractArray, the orthogonal matrix that approximates the top compressor_dim    left singular vectors of A.\nS::AbstractVector, a vector containing the top compressor_dim singular values of    A.\nV::AbstractArray, the orthogonal matrix that approximates the top compressor_dim    right singular vectors of A.\nbuffer::AbstractArray, the storage for matrix multiplication with this low-rank    approximation. Will have the compression_dim number of rows and block_size   number of columns.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeFinder","page":"Approximators API","title":"RLinearAlgebra.RangeFinder","text":"RangeFinder\n\nA struct that implements the Randomized Range Finder technique which uses compression from      the right to form an low-dimensional orthogonal matrix Q that approximates the      range of A. See [1] for additional details.\n\nMathematical Description\n\nSuppose we have a matrix A in mathbbR^m times n of which we wish to form a low      rank approximation that approximately captures the range of A. Specifically, we wish     to find an Orthogonal matrix Q such that QQ^top A approx A. \n\nA simple way to find such a matrix is to choose a k representing the number of      vectors we wish to have in the subspace. Then we can generate a compression matrix      SinmathbbR^n times k and compute Q = textqr(AS).      With high probability we will have A - QQ^top A_2 leq     sqrtk+1 (sum_i=k+1^min(mn)sigma_i)^12,      where sigma_k+1 is the k+1^textth singular value      of A (see Theorem 10.5 of [1]). This bound is often conservative      as long as the singular values of A decay quickly.  \n\nWhen the singular values decay slowly, we can improve the quality of the approximation using the      power iteration, which applies A and A^top, q times      and take the qr factorization of (AA^top)^q AS. Using these power iterations increases the      relative gap between the singular values leading to  better Rangefinder performance. \n\nPerforming power iterations in floating points can destroy all information      related to the smallest singular values of A      (see Remark 4.3 in [1]). We can preserve this information by      orthogonalizing inbetween the products of AS with A or A^top      in the power iteration. These steps are known as the orthogonalized power      iteration (see Algorithm 4.4 of [1]).       Orthogonalized power iterations progress according to the following steps:\n\ntildeA_1 = AS  \nQ_1R_1 = textbfqr(tildeA_1)  \ntildeA_2 = A^top Q_1  \nQ_2R_2 = textbfqr(tildeA_2)  \ntildeA_1 = A Q_2  \nQ_1 R_1 = textbfqr(tildeA_1)  \nRepeat Steps 3 through 6 for the desired number of power iterations  set Q = Q_1. \n\nFields\n\ncompressor::Compressor, the technique that will compress the matrix from the right.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\n\nConstructor\n\nRangeFinder(;\n    compressor = SparseSign(), \n    orthogonalize = false, \n    power_its = 0\n)\n\nKeywords\n\ncompressor::Compressor, the technique that will compress the matrix from the right.\npower_its::Int64, the number of power iterations that should be performed. Default is   zero.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization. Default is false.\n\nReturns\n\nA RangeFinder object.\n\nThrows\n\nArgumentError if power_its is negative.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeFinderRecipe","page":"Approximators API","title":"RLinearAlgebra.RangeFinderRecipe","text":"RangeFinderRecipe\n\nA struct that contains the preallocated memory and completed compressor to form a     RangeFinder approximation to the matrix A.\n\nFields\n\ncompressor::CompressorRecipe, the compressor to be applied from the right to A.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\nrange::AbstractMatrix, the orthogonal matrix that approximates the range of A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#Exported-Functions","page":"Approximators API","title":"Exported Functions","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.complete_approximator","page":"Approximators API","title":"RLinearAlgebra.complete_approximator","text":"complete_approximator(approximator::Approximator, A::AbstractMatrix)\n\nA function that generates an ApproximatorRecipe given      arguments.\n\nArguments\n\napproximator::Approximator, a data structure containing the   user-defined parameters associated with a particular low-rank approximation.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rapproximate","page":"Approximators API","title":"RLinearAlgebra.rapproximate","text":"rapproximate(approximator::Approximator, A::AbstractMatrix)\n\nA function that computes a low-rank approximation of the matrix A     using the information in the provided Approximator data structure.\n\nArguments\n\napproximator::Approximator, a data structure containing the   user-defined parameters associated with a particular low-rank approximation.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rapproximate!","page":"Approximators API","title":"RLinearAlgebra.rapproximate!","text":"rapproximate!(approximator::ApproximatorRecipe, A::AbstractMatrix)\n\nA function that computes a low-rank approximation of the matrix A     using the information in the provided Approximator data structure.\n\nArguments\n\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#Internal-Functions","page":"Approximators API","title":"Internal Functions","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.rand_power_it","page":"Approximators API","title":"RLinearAlgebra.rand_power_it","text":"rand_power_it(approx::RangeFinderRecipe, A::AbstractMatrix)\n\nFunction that performs the randomized rangefinder procedure presented in Algortihm 4.3 of  [1].\n\nArguments\n\napprox::RangeFinderRecipe, a RangeFinderRecipe structure that contains the compressor\n\nrecipe.\n\nA::AbstractMatrix, the matrix being approximated.\n\nReturns\n\nQ::AbstractMatrix, an economical Q approximating the range of A.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rand_ortho_it","page":"Approximators API","title":"RLinearAlgebra.rand_ortho_it","text":"rand_ortho_it(approx::RangeFinderRecipe, A::AbstractMatrix)\n\nFunction that performs the randomized rangefinder procedure presented in Algortihm 4.4 of  [1].\n\nArguments\n\napprox::RangeFinderRecipe, a RangeFinderRecipe structure that contains the compressor\n\nrecipe.\n\nA::AbstractMatrix, the matrix being approximated.\n\nReturns\n\nQ::AbstractMatrix, an economical Q approximating the range of A.\n\n\n\n\n\n","category":"function"},{"location":"api/solver_errors/#SolverErrors","page":"SolverErrors API","title":"SolverErrors","text":"","category":"section"},{"location":"api/solver_errors/","page":"SolverErrors API","title":"SolverErrors API","text":"Pages = [\"solver_errors.md\"]","category":"page"},{"location":"api/solver_errors/#Abstract-Types","page":"SolverErrors API","title":"Abstract Types","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.SolverError","page":"SolverErrors API","title":"RLinearAlgebra.SolverError","text":"SolverError\n\nAn abstract supertype for structures that track and/or evaluate the quality of a solution for a linear system or least squares.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#RLinearAlgebra.SolverErrorRecipe","page":"SolverErrors API","title":"RLinearAlgebra.SolverErrorRecipe","text":"SolverErrorRecipe\n\nAn abstract supertype for structures that contain the user-controlled parameters, linear system dependent parameters, and preallocated memory for techniques that evaluate the solution to a linear solver.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#SolverError-Structures","page":"SolverErrors API","title":"SolverError Structures","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.FullResidual","page":"SolverErrors API","title":"RLinearAlgebra.FullResidual","text":"FullResidual <: SolverError\n\nA SolverError structure for computing the norm of the full residual, b-Ax.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#RLinearAlgebra.FullResidualRecipe","page":"SolverErrors API","title":"RLinearAlgebra.FullResidualRecipe","text":"FullResidual <: SolverErrorRecipe\n\nA SolverErrorResidual structure for computing the norm of the full residual, b-Ax\n\nFields\n\nresidual::AbstractVector, a container for the residual b-Ax.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#Exported-Functions","page":"SolverErrors API","title":"Exported Functions","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.complete_error","page":"SolverErrors API","title":"RLinearAlgebra.complete_error","text":"complete_error(\n    error::SolverError, \n    solver::Solver,\n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that generates a SolverErrorRecipe given the      arguments.\n\nArguments\n\nerror::SolverError, a user-specified solver error method.\nsolver::Solver, a user-specified solver method.\nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nReturns\n\nA SolverErrorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solver_errors/#RLinearAlgebra.compute_error","page":"SolverErrors API","title":"RLinearAlgebra.compute_error","text":"compute_error(\n    error::SolverErrorRecipe, \n    solver::SolverRecipe, \n    x::AbstractVector,\n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that evaluates the error for a proposed solution      vector.\n\nArguments\n\nerror::SolverErrorRecipe, a fully initialized realization for   a solver error method for a specific linear system or least squares problem.\nsolver::SolverRecipe, a fully initialized realization for a    solver method for a specific linear system.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nReturns\n\nReturns nothing\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#Solvers","page":"Solvers API","title":"Solvers","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers API","title":"Solvers API","text":"Pages = [\"solvers.md\"]","category":"page"},{"location":"api/solvers/#Abstract-Types","page":"Solvers API","title":"Abstract Types","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.Solver","page":"Solvers API","title":"RLinearAlgebra.Solver","text":"Solver\n\nAn abstract supertype for structures that contain the user-controlled parameters for methods that solve linear systems and least squares problems.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#RLinearAlgebra.SolverRecipe","page":"Solvers API","title":"RLinearAlgebra.SolverRecipe","text":"SolverRecipe\n\nAn abstract supertype specifying a solver method with pre-allocated data structures given a coefficient matrix and constant vector.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#Solver-Structures","page":"Solvers API","title":"Solver Structures","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.Kaczmarz","page":"Solvers API","title":"RLinearAlgebra.Kaczmarz","text":"Kaczmarz <: Solver\n\nAn implementation of a Kaczmarz solver. Specifically, it is a solver that iteratively     updates an iterate by projecting the iterate onto (a subspace of) the row space of a     consistent linear system.\n\nMathematical Description\n\nLet A be an m times n matrix and consider the consistent linear system Ax=b.      We can view the solution to this linear system as lying at the intersection of the      row hyperplanes,      cap_i in 1 ldots mu in mathbbR^n  A_i cdot u = b_i     ,     where A_i cdot represents the i^textth row of A. One way to find      this interesection is to iteratively project some abritrary point, x from one      hyperplane to the next, through      x_+ = x + alpha fracb_i - lange A_icdot xrangle A_icdot     Doing this with random permutation of i can lead to a geometric convergence      [6].     Here alpha is viewed as an over-relaxation parameter and can improve convergence.      One can also generalize this procedure to blocks by considering the S being a      s times n random matrix. If we let tilde A = S A and tilde b = Sb      then we can perform block kaczmarz as described by [7] with      x_+ = x + alpha tilde A^top (tilde A tilde A^top)^dagger      (tilde b - tilde A x)     While, S is often random, in reality, whether S is deterministic or random is      quite flexible see [8] for more details.\n\nFields\n\nalpha::Float64, the over-relaxation parameter. It is multiplied by the update and can    affect convergence.\ncompressor::Compressor, a technique for forming the compressed rowspace of the linear    system.\nlog::Logger, a technique for logging the progress of the solver.\nerror::SolverError, a method for estimating the progress of the solver.\nsub_solver::SubSolver, a technique to perform the projection of the solution onto the    compressed rowspace.\n\nConstructor\n\nKaczmarz(;\n    compressor::Compressor = SparseSign(), \n    log::Logger = BasicLogger(),\n    error::SolverError = FullResidual(),\n    sub_solver::SubSolver = LQSolver(),\n    alpha::Float64 = 1.0\n)\n\nKeywords\n\ncompressor::Compressor, a technique for forming the compressed rowspace of the    linear system.\nlog::Logger, a technique for logging the progress of the solver.\nerror::SolverError, a method for estimating the progress of the solver.\nsub_solver::SubSolver, a technique to perform the projection of the solution onto the    compressed rowspace. When the compression_dim = 1 this is not used.\nalpha::Float64, the over-relaxation parameter. It is multiplied by the update and can    affect convergence. By default this value is 1.\n\nReturns\n\nA Kaczmarz object.\n\ninfo: Info\nThe alpha parameter should be in (02)  for convergence to be guaranteed. This  condition is not enforced in the constructor. There are some instances where setting  alpha = 2 can lead to non-convergent cycles [9].\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#RLinearAlgebra.KaczmarzRecipe","page":"Solvers API","title":"RLinearAlgebra.KaczmarzRecipe","text":"KaczmarzRecipe{\n    T<:Number, \n    V<:AbstractVector,\n    M<:AbstractMatrix, \n    VV<:SubArray,\n    MV<:SubArray,\n    C<:CompressorRecipe, \n    L<:LoggerRecipe,\n    E<:SolverErrorRecipe, \n    B<:SubSolverRecipe\n} <: SolverRecipe\n\nA mutable structure containing all information relevant to the Kaczmarz solver. It is     formed by calling the function complete_solver on Kaczmarz solver, which includes     all the user controlled parameters, and the linear system matrix A and constant      vector b.\n\nFields\n\ncompressor::CompressorRecipe, a technique for forming the compressed rowspace of the    linear system.\nlog::LoggerRecipe, a technique for logging the progress of the solver.\nerror::SolverErrorRecipe, a method for estimating the progress of the solver.\nsub_solver::SubSolverRecipe, a technique to perform the projection of the solution onto   the compressed rowspace.\nalpha::Float64, the over-relaxation parameter. It is multiplied by the update and can    affect convergence.\ncompressed_mat::AbstractMatrix, a matrix container for storing the compressed matrix.    Will be set to be the largest possible block size.\ncompressed_vec::AbstractVector, a vector container for storing the compressed constant   vector. Will be set to be the largest possible block size.\nsolution_vec::AbstractVector, a vector container for storing the solution to the linear   system.\nupdate_vec::AbstractVector, a vector container for storing the update to the linear    system.\nmat_view::SubArray, a container for storing a view of compressed matrix container.    Using views here allows for variable block sizes.\nvec_view::SubArray, a container for storing a view of the compressed vector container.   Using views here allows for variable block sizes.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#Exported-Functions","page":"Solvers API","title":"Exported Functions","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.complete_solver","page":"Solvers API","title":"RLinearAlgebra.complete_solver","text":"complete_solver(solver::Solver, x::AbstractVector, A::AbstractMatrix, b::AbstractVector)\n\nA function that generates a SolverRecipe given the      arguments.\n\nArguments\n\nsolver::Solver, a user-specified solver method.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nA SolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.rsolve!","page":"Solvers API","title":"RLinearAlgebra.rsolve!","text":"rsolve!(\n    solver::SolverRecipe, \n    x::AbstractVector, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that solves a linear system given the arguments.\n\nArguments\n\nsolver::SolverRecipe, a fully initialized realization for a    solver method for a specific linear system.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nReturns nothing. Updates the SolverRecipe and x in place.\n\n\n\n\n\nrsolve!(\n    solver::Solver, \n    x::AbstractVector, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that solves a linear system given the arguments.\n\nArguments\n\nsolver::Solver, a user-specified solver method.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nx::AbstractVector, a proposed solution to a linear system or least squares    problem.\nA SolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#Internal-Functions","page":"Solvers API","title":"Internal Functions","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.kaczmarz_update!","page":"Solvers API","title":"RLinearAlgebra.kaczmarz_update!","text":"kaczmarz_update!(solver::KaczmarzRecipe)\n\nA function that performs the Kaczmarz update when the compression dimension is one.      If a is the resulting compression of the coefficient matrix,      and c is the resulting compression of the constant vector,      then we perform the update: x = x - alpha (a^top x -c)  a_2^2. \n\nArguments\n\nsolver::KaczmarzRecipe, the solver information required for performing the update.\n\nOutputs\n\nreturns nothing\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.kaczmarz_update_block!","page":"Solvers API","title":"RLinearAlgebra.kaczmarz_update_block!","text":"kaczmarz_update_block!(solver::KaczmarzRecipe)\n\nA function that performs the kaczmarz update when the compression dim is greater than 1.       In the block case where the compressed matrix tilde A, and the compressed      contant vector tilde b, we perform the updated:      x = x - alpha tilde A^top (tilde A tilde A^top)^dagger     (tilde Ax-tilde b).\n\nArguments\n\nsolver::KaczmarzRecipe, the solver information required for performing the update.\n\nOutputs\n\nreturns nothing\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.dotu","page":"Solvers API","title":"RLinearAlgebra.dotu","text":"dotu(a::AbstractArray, b::AbstractArray)\n\nA function that computes the non conjugate dot product between two vectors. It is equivalent     to calling dot(conj(a), b).\n\nArguments\n\na::AbstractArray, a vector being dot producted (is labeled as a array to allow for    views).\nb::AbstractArray, a vector being dot producted (is labeled as a array to allow for    views).\n\nReturns\n\nA scalar that is the non-conjugated dot product between two vectors.\n\n\n\n\n\n","category":"function"},{"location":"manual/compression/#Compressing-a-Matrix/Vector","page":"Compression","title":"Compressing a Matrix/Vector","text":"","category":"section"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"Most Randomized Linear Algebra routines start by forming low-dimensional representation of  a matrix/vector. These representations are typically formed by multiplying a  random matrix with a large matrix/vector.  For instance, if we have x in mathbbR^10000 we can apply a matrix,  S in mathbbR^20 times 10000 made up of  independent and identically distributed textbfNormal(0 1sqrt20) to obtain y = Sx in mathbbR^20 where (1-epsilon)x leq y leq (1+epsilon) x with high probability. ","category":"page"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"Of course, many other techniques beyond the one described above can be used to generate  S and they vary both in terms of their approximation complexity and computational  efficiency. In papers, Randomized Linear Algebraists often refer to techniques for generating S as either sampling (random subset of identity) or sketching  (general random matrix) techniques. For simplicity RLinearAlgebra.jl refers to both types  of techniques under the general family of Compressors. ","category":"page"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"In RLinearAlgebra.jl, using a compression technique requires two main steps. The first, is using the complete_compressor function to generate your CompressorRecipe. The second  step is using the mul! or * functions to apply your CompressorRecipe to your matrix/ vector object. If you ever want to form a new realization of your compressor, you can  use the update_compressor! function to update the random entries in your  CompressorRecipe. ","category":"page"},{"location":"manual/compression/#Using-complete_compressor","page":"Compression","title":"Using complete_compressor","text":"","category":"section"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"In its simplest form, complete_compressor has two arguments, the first is compressor, where you specify the compressor technique that you wish to use. All compressors have two fields that the user can specify; although some have some additional technique   specific fields (see Compressors Reference for more details). The first field  is compression_dim, where you specify the dimension that your CompressorRecipe will map  a matrix/vector into after being applied to the matrix/vector. The second field is  Cardinality, which can either be Left() or Right(). Cardinality allows you to  specify how you intend to multiply your compressor to a matrix/vector. In the matrix case,  if S is your CompressorRecipe and A is your matrix, a Left() cardinality  corresponds to multiplying SA and a Right() corresponds to multiplying AS. Once  you have specified these two fields in your Compressor object, the second input in to the  complete_compressor function will be the matrix/vector you wish to compress. ","category":"page"},{"location":"manual/compression/#Multiplying-your-CompressorRecipe","page":"Compression","title":"Multiplying your CompressorRecipe","text":"","category":"section"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"Once you have your CompressorRecipe you can multiply it to any matrix/vector  just as you would any matrix object, using either the mul! or * functions. You can also  take transposes of the CompressorRecipe just as you would any other matrix object. Just like in LinearAlgebra, the mul! function should be used when you have preallocated  an output array and the * function should be used when you have not. ","category":"page"},{"location":"manual/compression/#Updating-update_compressor!","page":"Compression","title":"Updating update_compressor!","text":"","category":"section"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"Because most compression techniques are randomized, it is likely that once you have a  realization of CompressorRecipe that you would want another realization of that same  recipe. This can be done using the update_compressor! function. This function in  its simplest form has only one argument although for some compressors it could have more arguments (see Compressors Reference for more details). The one argument is the  CompressorRecipe.","category":"page"},{"location":"manual/compression/#Compressing-a-Matrix-Example","page":"Compression","title":"Compressing a Matrix Example","text":"","category":"section"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"Knowing that compressors allow us to reduce one of the dimensions of a matrix, the next  important question is how do we do this in RLinearAlgebra.jl? In the following example  we show how to do exactly this using a Gaussian compressor. In this  example we will generate a GaussianRecipe, S with compression_dim 10 and cardinality Left(), then we will apply S and its transpose, S', to a matrix, A,  with a 100 rows and 100 columns using *.  Then we will generate a new realization of the recipe using  update_compressor! and use the mul! to apply this new compressor to A from  the left.","category":"page"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"using RLinearAlgebra\nusing LinearAlgebra\n\nA = rand(100, 100)\n\n# Generate the CompressorRecipe with compression_dim 10 and cardinality Left()\nS = complete_compressor(\n    Gaussian(\n        compression_dim = 10,\n        cardinality = Left()\n    ),\n    A\n)\n\n# Multiply this compressor and its transpose to the left and right of A, respectively\nC = S * A * S'\n\n# Generate a new realization of S\nupdate_compressor!(S)\n\n# use mul! to multiply S from the left\n# the output matrix will have the number of rows in S and the number of columns in A\nC = zeros(size(S, 1), size(A, 2))\n\nmul!(C, S, A)","category":"page"},{"location":"manual/compression/#Sampling-Compressors-and-Distributions","page":"Compression","title":"Sampling Compressors and Distributions","text":"","category":"section"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"A special sub-type of compressors are known as Sampling compressors. These compressors are unique in that they compress the matrix by selecting rows or columns according to a  specific distribution. For example, we could compress a matrix by sampling 10 rows uniformly at random in what is known unsurprisingly as a uniform sampling approach. RLinearAlgebra.jl allows you to use the Sampling techniques with a wide range of distributions (see  Distributions for more details). You can specify the distribution you want to use with the distribution argument in the sampling structure. As an example, if we want to  perform uniform sampling from a matrix we can form our SamplingRecipe by writing:","category":"page"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"using RLinearAlgebra\nA = rand(100, 100)\n\n# Generate Compression recipe using uniform sampling distribution\nS = complete_compressor(\n    Sampling(\n        compression_dim = 10,\n        cardinality = Left(),\n        distribution = Uniform()\n    ),\n    A\n)","category":"page"},{"location":"manual/compression/#Summary-of-Compressors","page":"Compression","title":"Summary of Compressors","text":"","category":"section"},{"location":"manual/compression/","page":"Compression","title":"Compression","text":"We now know that anytime we want to reduce one of the dimensions of a matrix or vector, we need to form a CompressorRecipe. To form the CompressorRecipe, we need to call complete_compressor with a Compressor data structure, which specifies the technique we want to use to compress a matrix/vector, and a matrix/vector that we wish to compress. Once we have this recipe, we can generate a new realization of it by calling  update_compressor! and can apply it to a matrix or vector using mul! or *. For more information on specific compressors see Compressors Reference.","category":"page"},{"location":"api/approximator_errors/#ApproximatorErrors","page":"ApproximatorErrors API","title":"ApproximatorErrors","text":"","category":"section"},{"location":"api/approximator_errors/","page":"ApproximatorErrors API","title":"ApproximatorErrors API","text":"Pages = [\"approximator_errors.md\"]","category":"page"},{"location":"api/approximator_errors/#Abstract-Types","page":"ApproximatorErrors API","title":"Abstract Types","text":"","category":"section"},{"location":"api/approximator_errors/#RLinearAlgebra.ApproximatorError","page":"ApproximatorErrors API","title":"RLinearAlgebra.ApproximatorError","text":"ApproximatorError\n\nAn abstract supertype for structures containing user-controlled parameters corresponding to methods that evaluate the quality of a low-rank approximation of a matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximator_errors/#RLinearAlgebra.ApproximatorErrorRecipe","page":"ApproximatorErrors API","title":"RLinearAlgebra.ApproximatorErrorRecipe","text":"ApproximatorErrorRecipe\n\nAn abstract supertype for structures containing user-controlled parameters, matrix dependent parameters and preallocated memory corresponding to methods that evaluate the quality of a low-rank approximation of a matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximator_errors/#ApproximatorError-Structures","page":"ApproximatorErrors API","title":"ApproximatorError Structures","text":"","category":"section"},{"location":"api/approximator_errors/#Exported-Functions","page":"ApproximatorErrors API","title":"Exported Functions","text":"","category":"section"},{"location":"api/approximator_errors/#RLinearAlgebra.complete_approximator_error","page":"ApproximatorErrors API","title":"RLinearAlgebra.complete_approximator_error","text":"complete_approximator_error(\n    error::ApproximatorError, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that generates an ApproximatorErrorRecipe     given the arguments.\n\nArguments\n\nerror::ApproximatorError, a data structure containing   the user-defined parameters associated with a particular low-rank approximation error   method.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorErrorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#RLinearAlgebra.compute_approximator_error","page":"ApproximatorErrors API","title":"RLinearAlgebra.compute_approximator_error","text":"compute_approximator_error(\n    error::ApproximatorError, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that computes the approximation error of an     ApproximatorRecipe for a matrix A.\n\nArguments\n\nerror::ApproximatorError, a data structure containing   the user-defined parameters associated with a particular low-rank approximation error   method.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nReturns the error::Float64 \n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#RLinearAlgebra.compute_approximator_error!","page":"ApproximatorErrors API","title":"RLinearAlgebra.compute_approximator_error!","text":"compute_approximator_error!(\n    error::ApproximatorErrorRecipe, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that computes the approximation error of an     ApproximatorRecipe for a matrix A.\n\nArguments\n\nerror::ApproximatorErrorRecipe, a fully initialized   realization for a low rank approximation error method for a particular matrix.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nReturns the error::Float64 \n\n\n\n\n\n","category":"function"},{"location":"#RLinearAlgebra","page":"Home","title":"RLinearAlgebra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RLinearAlgebra is a Julia library for the  development and application of randomized algorithms to the problems of forming low rank  approximations to matrices and finding the solution of linear systems and least squares  problems.  Because of the large diversity of randomized techniques, rather than offering isolated  routine implementations of algorithms, this library implements a series of extendable data  structures and methods which allow code reuse.","category":"page"},{"location":"#Documentation-structure","page":"Home","title":"Documentation structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation serves both as a manual to the library and as an introduction to  randomized linear approximation techniques and randomized linear algebra solvers.  We divide it in four parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorial: examples of how to solve linear systems and least squares problems with   RLinearAlgebra and how to extend the library.\nManual: here we offer an introduction to solving linear systems with randomized linear    algebra techniques, compressing a matrix, and forming a low-rank approximation of a matrix.    We introduce theoretical foundations and we provide code examples with RLinearAlgebra.\nAPI: a detailed description of all the data structures and methods of the library.\nDevelopment: detailed instructions on how to contribute to the library.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is supported by the National Science Foundation Office of Advanced  Cyberinfrastructure under awards  2309445 and  2309446. This material is based upon work supported by the U.S. Department of Energy, Office of  Science, under contract number DE-AC02-06CH11357.","category":"page"},{"location":"api/contents/#Randomized-Linear-Solver-Reference","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"","category":"section"},{"location":"api/contents/","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"Pages=[\n  \"approximators.md\",  \n  \"approximator_errors.md\",\n  \"compressors.md\",\n  \"solvers.md\",\n  \"solver_error.md\",\n  \"sub_solvers.md\",\n  \"loggers.md\"]","category":"page"}]
}
