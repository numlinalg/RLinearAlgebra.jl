<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · RLinearAlgebra</title><meta name="title" content="Introduction · RLinearAlgebra"/><meta property="og:title" content="Introduction · RLinearAlgebra"/><meta property="twitter:title" content="Introduction · RLinearAlgebra"/><meta name="description" content="Documentation for RLinearAlgebra."/><meta property="og:description" content="Documentation for RLinearAlgebra."/><meta property="twitter:description" content="Documentation for RLinearAlgebra."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RLinearAlgebra</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li><a class="tocitem" href="#Overview-of-the-Library"><span>Overview of the Library</span></a></li><li><a class="tocitem" href="#Installing-RLinearAlgebra"><span>Installing RLinearAlgebra</span></a></li><li><a class="tocitem" href="#Using-RLinearAlgebra.jl"><span>Using RLinearAlgebra.jl</span></a></li></ul></li><li><a class="tocitem" href="../compression/">Compression</a></li><li><a class="tocitem" href="../low_rank_approximators/">Low-Rank Approximation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/tutorials_overview/">Overview of Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Compressors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/compressors/compressor_example/">Multiplying by a Compressor</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Consistent Linear System</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/consistent_system/consistent_system/">Solving a Consistent Linear System</a></li><li><a class="tocitem" href="../../tutorials/consistent_system/configuring_kaczmarz/">Configuring a Basic Logger for the Generalized Kaczmarz Solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Least Squares</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/least_squares/least_squares/">Solving a Least Squares Problem</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Compressors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/compressors/">Compressors API</a></li><li><a class="tocitem" href="../../api/distributions/">Distributions API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/solvers/">Solvers API</a></li><li><a class="tocitem" href="../../api/sub_solvers/">SubSolvers API</a></li><li><a class="tocitem" href="../../api/solver_errors/">SolverErrors API</a></li><li><a class="tocitem" href="../../api/loggers/">Loggers API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Approximators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../api/approximators/">Approximators API</a></li><li><a class="tocitem" href="../../api/selectors/">Selectors API</a></li><li><a class="tocitem" href="../../api/approximator_errors/">ApproximatorErrors API</a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/numlinalg/RLinearAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/main/docs/src/manual/introduction.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="A-library-for-exploring-Randomized-Linear-Algebra"><a class="docs-heading-anchor" href="#A-library-for-exploring-Randomized-Linear-Algebra">A library for exploring Randomized Linear Algebra</a><a id="A-library-for-exploring-Randomized-Linear-Algebra-1"></a><a class="docs-heading-anchor-permalink" href="#A-library-for-exploring-Randomized-Linear-Algebra" title="Permalink"></a></h1><p>If you are here, you probably know that Linear Algebra is foundational to data science, scientific computing, and AI. You also probably know Linear Algebra routines dominate the  computational cost of many of the algorithms in these fields. Thus, improving the  scalability of these algorithms requires more scalable Linear Algebra techniques.</p><p>Randomized Linear Algebra is an exciting new approach to classical linear algebra problems  that offers strong improvements in scalability. In general, Randomized Linear Algebra  techniques achieve this improved scalability by forming a compressed representation of a  matrix and performing operations on that compressed form. In some circumstances operating on this compressed form can offer profound speed-ups as can seen in the following example  where a technique known as the RandomizedSVD (see [<a href="../../references/#halko2011finding">1</a>])  is used to compute a rank-20 approximation to <span>$3000 \times 3000$</span> matrix  <span>$A$</span> in place of a truncated SVD. Compared to computing the SVD and  truncating it, the RandomizedSVD is 100 times faster and just as accurate  as the truncated SVD.</p><pre><code class="language-julia hljs">using RLinearAlgebra
using LinearAlgebra

# Generate a rank-20 matrix
A = randn(3000, 20) * randn(20, 3000);

@time U,S,V = svd(A);
#    4.566639 seconds (13 allocations: 412.354 MiB, 0.92% gc time)

# Form the RandomizedSVD data structure
technique = RandSVD(
    compressor = Gaussian(compression_dim = 22,  cardinality = Right()) 
)

# Take the RandomizedSVD of A
@time rec = rapproximate(technique, A);
#    0.050950 seconds (39 allocations: 5.069 MiB)

# Take the norm of the difference between the RandomizedSVD and TrunctatedSVD at rank 22
norm(rec.U * Diagonal(rec.S) * rec.V&#39; - U[:,1:22] * Diagonal(S[1:22]) * (V[:, 1:22])&#39;)
# 6.914995919005829e-11</code></pre><p>Randomized Linear Algebra is a fast growing field with a myriad of new methods being  proposed every year. Because randomized linear algebra methods are based around similar  sub-routines many of the innovations could offer improvements to established techniques. Unfortunately, most implementations of these techniques are static making testing the  effectiveness of innovations on previous techniques challenging. RLinearAlgebra.jl aims to  make incorporating new innovations into established randomized linear algebra techniques easy.</p><p>In particular, RLinearAlgebra.jl leverages a modular design to allow you  to easily test Randomized Linear Algebra routines under a wide-range of parameter choices.   RLinearAlgebra.jl provides routines for two core Linear Algebra tasks: finding a solution to a linear system via <span>$Ax=b$</span> or <span>$\min_x \|Ax - b\|$</span> and forming a low rank  approximation to a matrix, <span>$\hat A$</span> where <span>$\hat A \approx A$</span>. The solution to a linear system appears everywhere: Optimization, Tomography, Statistics, Scientific Computing,  Machine Learning, etc. The low-rank approximation problem has only become more relevant in  recent years owing to the drastic increase in matrix sizes. It has been widely used in  Statistics via PCA, but also has become increasingly more relevant.</p><p>This manual will walk you through the use of the RLinearAlgebra.jl library. The remainder  of this section will be focused on providing an overview of the common design elements in  the library, and information about how to get started using the library.</p><h2 id="Overview-of-the-Library"><a class="docs-heading-anchor" href="#Overview-of-the-Library">Overview of the Library</a><a id="Overview-of-the-Library-1"></a><a class="docs-heading-anchor-permalink" href="#Overview-of-the-Library" title="Permalink"></a></h2><p>You can think of using RLinearAlgebra.jl as being a producer on  <a href="https://www.youtube.com/watch?v=7sm8VrnuOFc&amp;list=PLpfv1AIjenVOxDKUfPuOtjsoF7OWIZVK-&amp;index=9"><em>Chopped</em></a>,  the long running Food Network cooking competition.  For those unfamiliar, the show takes place in three rounds, where one of four contestants  get eliminated at the end each round. In each round, the producers provide the contestants with a fix set of ingredients  <a href="https://www.mashed.com/1244321/most-bizarre-mystery-basket-ingredients-ever-seen-chopped/">(often rather unconventional ones at that)</a> and a general category of food (e.g. appetizer, entree, or dessert) that the contestants then have to use in a recipe that they prepare for a panel of judges.</p><p>RLinearAlgebra.jl gives you as the user the fun job of deciding which ingredients  (techniques) you want to use to solve your linear system, compress your matrix/vector,  or form an approximation of your matrix. Then, once you specify that information, you  can start the clock by calling <code>rsolve</code> or <code>rapproximate</code>, with information about your  matrix/linear system and watch RLinearAlgebra.jl do the rest. Behind the scenes  it calls all the  <code>complete_[technique]</code> functions that will generate recipe data  structures that have all the necessary preparations (preallocations) for handling your  proposed task. Then once the preparations are done, RLinearAlgebra follows its designed  recipes to cook-up a solution to your problem. </p><p>With this analogy of how RLinearAlgebra.jl works, the next two sections provide an overview over the two key data structures in RLinearAlgebra.jl, the <strong>technique</strong> structures (your  ingredients) and the <strong>recipe</strong> structures (what RLinearAlgebra.jl creates to perform your task).</p><h3 id="The-Technique-Types-(The-Ingredients)"><a class="docs-heading-anchor" href="#The-Technique-Types-(The-Ingredients)">The Technique Types (The Ingredients)</a><a id="The-Technique-Types-(The-Ingredients)-1"></a><a class="docs-heading-anchor-permalink" href="#The-Technique-Types-(The-Ingredients)" title="Permalink"></a></h3><p>With an understanding of the basic structures in the library, one may wonder, what  types of techniques are there? First, there are the techniques for solving the linear  system, <code>Solvers</code>, and techniques for forming a low-rank approximation to a matrix,  <code>Approximators</code>. Both <code>Solvers</code> and <code>Approximators</code> achieve speedups by working on  compressed forms (often known as sketched or sampled) of the linear system or matrix,  techniques that compress the linear system are known as <code>Compressors</code>.  Aside from these global techniques, there are also techniques that are specific to  <code>Solvers</code>, which include: </p><ol><li><code>SubSolvers</code>, techniques that solve the inner (compressed) linear system.</li><li><code>Loggers</code>, techniques that log information and determine whether a stopping criterion has  been met.</li><li><code>SolverError</code>, a technique that computes the error of a current iterate of a solver.  </li></ol><p>Similarly, <code>Approximators</code> have their own specific techniques, which include:</p><ol><li><code>ApproximatorError</code>, a technique that computes the error of an <code>Approximator</code>.</li></ol><p>With all these technique structures, you may be wondering, what functions can I call on these structures? Well, the answer is not many. As is  summarized in the following table.  </p><table><tr><th style="text-align: left">Technique</th><th style="text-align: left">Parent Technique</th><th style="text-align: left">Function Calls</th></tr><tr><td style="text-align: left"><code>Approximator</code></td><td style="text-align: left">None</td><td style="text-align: left"><code>complete_approximator</code>,<code>rapproximate</code></td></tr><tr><td style="text-align: left"><code>Compressor</code></td><td style="text-align: left">None</td><td style="text-align: left"><code>complete_compressor</code></td></tr><tr><td style="text-align: left"><code>Solver</code></td><td style="text-align: left">None</td><td style="text-align: left"><code>complete_solver</code>, <code>rsolve</code></td></tr><tr><td style="text-align: left"><code>ApproximatorError</code></td><td style="text-align: left"><code>Approximator</code></td><td style="text-align: left"><code>complete_approximator_error</code></td></tr><tr><td style="text-align: left"><code>Logger</code></td><td style="text-align: left"><code>Solver</code></td><td style="text-align: left"><code>complete_logger</code></td></tr><tr><td style="text-align: left"><code>SolverError</code></td><td style="text-align: left"><code>Solver</code></td><td style="text-align: left"><code>complete_solver_error</code></td></tr><tr><td style="text-align: left"><code>SubSolver</code></td><td style="text-align: left"><code>Solver</code></td><td style="text-align: left"><code>complete_sub_solver</code></td></tr></table><p>From the above table we can see that all you are able to do (unless you are using  an <code>Approximator</code> or a <code>Solver</code>) is complete the technique. The reason being that all the  technique structures contain only information about algorithmic parameters that require no  information about the linear system. The recipes on the other hand have all the information  required to execute a technique including the required pre-allocated memory. We determine the  preallocations for the Recipes by merging the parameter information of the technique  structures with the matrix and linear system information via the <code>complete_[technique]</code>  functions, which is the only function that you can call when you have a technique structure.  There is a special exception for <code>rsolve</code> and <code>rapproximate</code> because they implicitly call  all the necessary completes to form the appropriate recipe. The bottom line is that do  anything useful you will need a recipe.</p><h3 id="The-Recipe-Types"><a class="docs-heading-anchor" href="#The-Recipe-Types">The Recipe Types</a><a id="The-Recipe-Types-1"></a><a class="docs-heading-anchor-permalink" href="#The-Recipe-Types" title="Permalink"></a></h3><p>Every technique can be transformed into a recipe. As has been stated before, what makes the  recipes different is that they contain all the required memory allocations. These  allocations can only be determined from once the matrix is known. As a user,  all you have to know is that as soon as you have a recipe you can do a lot. As can be seen  in the following table.</p><table><tr><th style="text-align: left">Technique Recipe</th><th style="text-align: left">Parent Recipe</th><th style="text-align: left">Function Calls</th></tr><tr><td style="text-align: left"><code>ApproximatorRecipe</code></td><td style="text-align: left">None</td><td style="text-align: left"><code>mul!</code>, <code>rapproximate!</code></td></tr><tr><td style="text-align: left"><code>CompressorRecipe</code></td><td style="text-align: left">None</td><td style="text-align: left"><code>mul!</code>,<code>update_compressor!</code></td></tr><tr><td style="text-align: left"><code>SolverRecipe</code></td><td style="text-align: left">None</td><td style="text-align: left"><code>rsolve!</code></td></tr><tr><td style="text-align: left"><code>ApproximatorErrorRecipe</code></td><td style="text-align: left"><code>Approximator</code></td><td style="text-align: left"><code>compute_approximator_error</code></td></tr><tr><td style="text-align: left"><code>LoggerRecipe</code></td><td style="text-align: left"><code>Solver</code></td><td style="text-align: left"><code>reset_logger!</code>, <code>update_logger!</code></td></tr><tr><td style="text-align: left"><code>SolverErrorRecipe</code></td><td style="text-align: left"><code>Solver</code></td><td style="text-align: left"><code>compute_error</code></td></tr><tr><td style="text-align: left"><code>SubSolverRecipe</code></td><td style="text-align: left"><code>Solver</code></td><td style="text-align: left"><code>update_sub_solver!</code>,<code>ldiv!</code></td></tr></table><p>Instead of providing  a different function for each method associated with these tasks, RLinearAlgebra.jl  leverages the multiple-dispatch functionality of Julia to allow all linear systems and  least squares problems to be solved calling the function  <code>rsolve(solver::Solver, x::AbstractVector, A::AbstractMatrix, b::AbstractVector)</code>  and all matrices to be approximated by calling the function  <code>rapproximate(approximator::Approximator, A::AbstractMatrix)</code>. Under this design, changing  the routine for solving your linear system or approximate your matrix is as  simple as changing the<code>solver</code> or <code>approximator</code> arguments. </p><h2 id="Installing-RLinearAlgebra"><a class="docs-heading-anchor" href="#Installing-RLinearAlgebra">Installing RLinearAlgebra</a><a id="Installing-RLinearAlgebra-1"></a><a class="docs-heading-anchor-permalink" href="#Installing-RLinearAlgebra" title="Permalink"></a></h2><p>Currently, RLinearAlgebra.jl is not registered in Julia&#39;s official package registry. There  are two main ways of installing RLinearAlgebra.jl. The preferred way of doing it is through the local registry. You can install this approach by writing in the REPL:</p><pre><code class="language-julia hljs">] registry add https://github.com/numlinalg/NumLingAlg
add RLinearAlgebra</code></pre><p>It can also be installed by writing in the REPL:</p><pre><code class="language-julia hljs">] add https://github.com/numlinalg/RLinearAlgebra.jl.git</code></pre><p>It can also be cloned into a local directory and installed by:</p><ol><li><code>cd</code> into the local project directory </li><li>Call <code>git clone https://github.com/numlinalg/RLinearAlgebra.jl.git</code></li><li>Run Julia</li><li>Call <code>using Pkg</code></li><li>Call <code>Pkg.activate(RLinearAlgebra.jl)</code></li><li>Call <code>Pkg.instantiate()</code></li></ol><p>For more information see  <a href="https://pkgdocs.julialang.org/v1/environments/#Using-someone-else&#39;s-project">Using someone else&#39;s project</a>.</p><h2 id="Using-RLinearAlgebra.jl"><a class="docs-heading-anchor" href="#Using-RLinearAlgebra.jl">Using RLinearAlgebra.jl</a><a id="Using-RLinearAlgebra.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Using-RLinearAlgebra.jl" title="Permalink"></a></h2><p>For this example let&#39;s assume that we have a vector that we wish to compress using one the RLinearAlgebra.jl <code>SparseSign</code> compressor. To do this: </p><ol><li>Load RLinearAlgebra.jl and generate your vector</li><li>Define the <code>SparseSign</code> technique. This requires us to specify a <code>cardinality</code>,  the direction we intend to apply the compressor from, and a <code>compression_dim</code>,   the number of entries we want in the compressed vector. In this instance we   want the cardinality to be <code>Left()</code> and the <code>compression_dim = 20</code>.</li><li>Use the <code>complete_compressor</code> function to generate the <code>SparseSignRecipe</code></li><li>Apply the compressor to the vector using the multiplication function</li></ol><pre><code class="language-julia hljs"># Step 1: load RLinearAlgebra.jl and generate vector
using RLinearAlgebra
using LinearAlgebra
# Specify the size of the vector
n = 10000
x = rand(n)

# Step 2: Define Sparse Sign Compressor
comp = SparseSign(compression_dim = 20, cardinality = Left())

# Step 4: Define Sparse Sign Compressor Recipe
S = complete_compressor(comp, x)

# Step 4: Apply the compressor to the vector using the multiplication function
Sx = S * x

norm(Sx)

norm(x)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../compression/">Compression »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Wednesday 31 December 2025 20:44">Wednesday 31 December 2025</span>. Using Julia version 1.12.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
