<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Compressors API · RLinearAlgebra</title><meta name="title" content="Compressors API · RLinearAlgebra"/><meta property="og:title" content="Compressors API · RLinearAlgebra"/><meta property="twitter:title" content="Compressors API · RLinearAlgebra"/><meta name="description" content="Documentation for RLinearAlgebra."/><meta property="og:description" content="Documentation for RLinearAlgebra."/><meta property="twitter:description" content="Documentation for RLinearAlgebra."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RLinearAlgebra</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../manual/introduction/">Introduction</a></li><li><a class="tocitem" href="../../manual/compression/">Compression</a></li><li><a class="tocitem" href="../../manual/low_rank_approximators/">Low-Rank Approximation</a></li><li><a class="tocitem" href="../../manual/linear_systems/">Linear Systems</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/tutorials_overview/">Overview of Tutorials</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Compressors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/compressors/compressor_example/">Multiplying by a Compressor</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Consistent Linear System</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/consistent_system/consistent_system/">Solving a Consistent Linear System</a></li><li><a class="tocitem" href="../../tutorials/consistent_system/configuring_kaczmarz/">Configuring a Basic Logger for the Generalized Kaczmarz Solver</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Least Squares</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/least_squares/least_squares/">Solving a Least Squares Problem</a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox" checked/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Compressors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Compressors API</a><ul class="internal"><li><a class="tocitem" href="#Abstract-Types"><span>Abstract Types</span></a></li><li><a class="tocitem" href="#Compressor-Structures"><span>Compressor Structures</span></a></li><li><a class="tocitem" href="#Exported-Functions"><span>Exported  Functions</span></a></li><li><a class="tocitem" href="#Internal-Functions"><span>Internal Functions</span></a></li></ul></li><li><a class="tocitem" href="../distributions/">Distributions API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../solvers/">Solvers API</a></li><li><a class="tocitem" href="../sub_solvers/">SubSolvers API</a></li><li><a class="tocitem" href="../solver_errors/">SolverErrors API</a></li><li><a class="tocitem" href="../loggers/">Loggers API</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Approximators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../approximators/">Approximators API</a></li><li><a class="tocitem" href="../selectors/">Selectors API</a></li><li><a class="tocitem" href="../approximator_errors/">ApproximatorErrors API</a></li></ul></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li><a class="is-disabled">Compressors</a></li><li class="is-active"><a href>Compressors API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Compressors API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/numlinalg/RLinearAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/main/docs/src/api/compressors.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Compressors-API"><a class="docs-heading-anchor" href="#Compressors-API">Compressors API</a><a id="Compressors-API-1"></a><a class="docs-heading-anchor-permalink" href="#Compressors-API" title="Permalink"></a></h1><ul><li><a href="#Compressors-API">Compressors API</a></li><li class="no-marker"><ul><li><a href="#Abstract-Types">Abstract Types</a></li><li><a href="#Compressor-Structures">Compressor Structures</a></li><li><a href="#Exported-Functions">Exported  Functions</a></li><li><a href="#Internal-Functions">Internal Functions</a></li></ul></li></ul><h2 id="Abstract-Types"><a class="docs-heading-anchor" href="#Abstract-Types">Abstract Types</a><a id="Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RLinearAlgebra.Compressor"><a class="docstring-binding" href="#RLinearAlgebra.Compressor"><code>RLinearAlgebra.Compressor</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Compressor</code></pre><p>An abstract supertype for structures that contain user-controlled parameters corresponding to techniques that compress a matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L1-L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.CompressorRecipe"><a class="docstring-binding" href="#RLinearAlgebra.CompressorRecipe"><code>RLinearAlgebra.CompressorRecipe</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompressorRecipe</code></pre><p>An abstract supertype for structures that contain both the user-controlled parameters in the <code>Compressor</code> and the memory allocations necessary for applying the compression technique to a particular set of matrices and vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L9-L15">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.CompressorAdjoint"><a class="docstring-binding" href="#RLinearAlgebra.CompressorAdjoint"><code>RLinearAlgebra.CompressorAdjoint</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CompressorAdjoint{S&lt;:CompressorRecipe}</code></pre><p>A structure for the adjoint of a compression recipe.</p><p><strong>Fields</strong></p><ul><li><code>Parent::CompressorRecipe</code>, the CompressorRecipe the adjoint is being applied to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L86-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.Cardinality"><a class="docstring-binding" href="#RLinearAlgebra.Cardinality"><code>RLinearAlgebra.Cardinality</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Cardinality</code></pre><p>An abstract type for types that specify whether a compressor will be applied from the left or the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L18-L23">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.Left"><a class="docstring-binding" href="#RLinearAlgebra.Left"><code>RLinearAlgebra.Left</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Left &lt;: Cardinality</code></pre><p>A struct indicating matrix multiplication from the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L26-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.Right"><a class="docstring-binding" href="#RLinearAlgebra.Right"><code>RLinearAlgebra.Right</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Right &lt;: Cardinality</code></pre><p>A struct indicating matrix multiplication from the right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L33-L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.Undef"><a class="docstring-binding" href="#RLinearAlgebra.Undef"><code>RLinearAlgebra.Undef</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Undef &lt;: Cardinality</code></pre><p>A struct indicating matrix multiplication is undefined.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L40-L44">source</a></section></details></article><h2 id="Compressor-Structures"><a class="docs-heading-anchor" href="#Compressor-Structures">Compressor Structures</a><a id="Compressor-Structures-1"></a><a class="docs-heading-anchor-permalink" href="#Compressor-Structures" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RLinearAlgebra.CountSketch"><a class="docstring-binding" href="#RLinearAlgebra.CountSketch"><code>RLinearAlgebra.CountSketch</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CountSketch &lt;: Compressor</code></pre><p>An implementation of the count sketch compression method. See additional details in  [<a href="../../references/#woodruff2014sketching">7</a>] Section 2.1, in which the CountSketch matrix is equivalently defined as sparse  embedding matrix.</p><p><strong>Mathematical Description</strong></p><p>Let <span>$A$</span> be an <span>$m \times n$</span> matrix that we want to compress. If we want to compress <span>$A$</span> from  the left (i.e., we reduce the number of rows), then we construct a Count Sketch matrix <span>$S$</span> with  dimension <span>$s \times m$</span>, where <span>$s$</span> is the user-specified compression dimension. Each column of  <span>$S$</span> is generated independently by the following steps:</p><ol><li>Randomly select an integer between 1 and <span>$s$</span> to determine the row position of the nonzero entry.</li><li>Assign this entry a value of either +1 or -1, chosen uniformly at random.</li><li>Set all the other entries in the column to zero.</li></ol><p>As a result, each column of S has exactly one nonzero element.</p><p>If <span>$A$</span> is compressed from the right, then we construct a Count Sketch matrix <span>$S$</span> with dimension  <span>$n \times s$</span>, where <span>$s$</span> is the user-specified compression dimension. Each row of <span>$S$</span> is  generated independently using the following steps:</p><ol><li>Randomly select an integer between 1 and <span>$s$</span> to determine the column position of the nonzero entry.</li><li>Assign this entry a value of either +1 or -1, chosen uniformly at random.</li><li>Set all other entries in the row to zero.</li></ol><p>In this case, each row of S has exactly one nonzero entry.  The compressed matrix is then formed by multiplying S A (for left compression) or A S (for right compression).</p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li><li><code>compression_dim::Int64</code>, the target compression dimension. Referred to as <span>$s$</span> in the   mathematical description.</li><li><code>type::Type{&lt;:Number}</code>, the type of the elements in the compressor.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">CountSketch(;carinality=Left(), compression_dim=2, type=Float64)</code></pre><p><strong>Keywords</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.   By default <code>Left()</code> is chosen.</li><li><code>compression_dim</code>, the target compression dimension. Referred to as <span>$s$</span> in the   mathemtical description. By default this is set to 2.</li><li><code>type::Type{&lt;:Number}</code>, the type of the elements in the compressor. By default is set   to Float64.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CountSketch</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>compression_dim</code> is non-positive</li><li><code>ArgumentError</code> if <code>Undef()</code> is taken as the input for <code>cardinality</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/count_sketch.jl#L1-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.CountSketchRecipe"><a class="docstring-binding" href="#RLinearAlgebra.CountSketchRecipe"><code>RLinearAlgebra.CountSketchRecipe</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">CountSketchRecipe &lt;: CompressorRecipe</code></pre><p>The recipe containing all allocations and information for the CountSketch compressor.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::C where C&lt;:Cardinality</code>, the cardinality of the compressor. The    value is either <code>Left()</code> or <code>Right()</code>.</li><li><code>compression_dim::Int64</code>, the target compression dimension.</li><li><code>n_rows::Int64</code>, the number of rows of the compression matrix.</li><li><code>n_cols::Int64</code>`, the number of columns of the compression matrix.</li><li><code>mat::SparseMatrixCSC</code>, the compression matrix stored in a sparse form.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/count_sketch.jl#L92-L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.FJLT"><a class="docstring-binding" href="#RLinearAlgebra.FJLT"><code>RLinearAlgebra.FJLT</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FJLT &lt;: Compressor</code></pre><p>An implementation of the Fast Johnson-Lindenstrauss Transform method. This technique applies a sparse matrix, a Walsh-Hadamard transform, and a diagonal sign matrix to produce a sketch.  See [<a href="../../references/#ailon2009fast">8</a>] for additional details.</p><p><strong>Mathematical Description</strong></p><p>Let <span>$A$</span> be an <span>$m \times n$</span> matrix that we want to compress. If we want to compress <span>$A$</span> from the left (i.e., we reduce the number of rows), then we create a matrix, <span>$S$</span>, with dimension <span>$s \times m$</span> where <span>$s$</span> is the compression dimension that is supplied by the user. Here <span>$S=KHD$</span> where </p><ul><li><span>$K$</span> is a sparse matrix with  with dimension <span>$s \times m$</span>, where each entry has    probability <span>$q$</span> of being non-zero, and, if it is non-zero, then its value is    drawn from an independent normal distribution with mean <span>$0$</span> and variance <span>$1/q$</span>;</li><li><span>$H$</span> is a Hadamard matrix of dimension <span>$m \times m$</span>, which is implicitly applied    through the fast Walsh-Hadamard transform;</li><li><span>$D$</span> of is a diagonal matrix of dimension <span>$m \times m$</span> with entries given by    independent Rademacher variables.</li></ul><p>If we want to compress <span>$A$</span> from the right (i.e., we reduce the number of columns), then  we would apply <span>$S=DHK$</span> from the right where the dimensions of the matrices are adjusted  to reflect the number of columns in <span>$A$</span>.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li><li><code>compression_dim::Int64</code>, the target compression dimension. Referred to as <span>$s$</span> in the   mathematical description.</li><li><code>block_size::Int64</code>, the number of vectors in the padding matrix.</li><li><code>sparsity::Int64</code>, the desired sparsity of the matrix <span>$K$</span>.</li><li><code>type::Type{&lt;:Number}</code>, the type of the elements in the compressor.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">FJLT(;
    cardinality=Left(),
    compression_dim::Int64=2,
    block_size::Int64=10,
    sparsity::Float64=0.0,
    type::Type{N}=Float64,
) where {N&lt;:Number}</code></pre><p><strong>Keywords</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.   By default <code>Left()</code> is chosen.</li><li><code>compression_dim::Int64</code>, the target compression dimension. Referred to as <span>$s$</span> in the   mathematical description. By default this is set to 2.</li><li><code>block_size::Int64</code>, the number of vectors in the padding matrix.</li><li><code>sparsity::Int64</code>, the desired sparsity of the matrix <span>$K$</span>, by default sparsity will be    set to be <span>$\min\left(1/4 \log(n)^2 / m, 1\right)$</span>, see [<a href="../../references/#ailon2009fast">8</a>].</li><li><code>type::Type{&lt;:Number}</code>, the type of elements in the compressor.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>FJLT</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>compression_dim</code> is non-positive, if <code>sparsity</code> is not in <span>$[0,1]$</span>,   or if <code>block_size</code> is non-positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/fjlt.jl#L1-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.FJLTRecipe"><a class="docstring-binding" href="#RLinearAlgebra.FJLTRecipe"><code>RLinearAlgebra.FJLTRecipe</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FJLTRecipe{C&lt;:Cardinality, S&lt;:SparseMatrixCSC, M&lt;:AbstractMatrix} &lt;: CompressorRecipe</code></pre><p>The recipe containing all allocations and information for the FJLT compressor.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li><li><code>n_rows::Int64</code>, the number of rows of the compression matrix.</li><li><code>n_cols::Int64</code>, the number of columns of the compression matrix.</li><li><code>sparsity:Float64</code>, the sparsity, <span>$q$</span>, of the sparse component, <span>$K$</span>.</li><li><code>scale::Float64</code>, the factor to ensure the isopmorphism of the sketch.</li><li><code>op::SparseMatrixCSC</code>, the sparse matrix <span>$K$</span> in the mathematical description.</li><li><code>signs::BitVector</code>, the vector of signs where <code>0</code> indicates negative one and <code>1</code> indicates   positive one. </li><li><code>padding::AbstractMatrix</code>, the matrix containing the padding for the matrix being sketched.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">FJLTRecipe(
    compression_dim::Int64, 
    block_size::Int64,
    cardinality::C where {C&lt;:Cardinality},
    sparsity::Float64,
    A::AbstractMatrix, 
    type::Type{&lt;:Number}
)</code></pre><p><strong>Keywords</strong></p><ul><li><code>compression_dim</code>, the target compression dimension. Referred to as <span>$s$</span> in the   mathemtical description. By default this is set to 2.</li><li><code>block_size::Int64</code>, the number of columns in the padding memory buffer.</li><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.   By default <code>Left()</code> is chosen.</li><li><code>sparsity::Vector{Number}</code>, the expected sparsity of the Sparse operator matrix.</li><li><code>A::AbstractMatrix</code>, the matrix being compressed.</li><li><code>type::Type{&lt;:Number}</code>, the type of elements in the compressor.</li></ul><div class="admonition is-info" id="Info-77faca268834db5d"><header class="admonition-header">Info<a class="admonition-anchor" href="#Info-77faca268834db5d" title="Permalink"></a></header><div class="admonition-body"><p>If the <code>sparsity</code> parameter is set to <code>0.0</code>, then the sparsity will be set to  <span>$\min\left(1/4 \log(n)^2 / m, 1\right)$</span>, see [<a href="../../references/#ailon2009fast">8</a>].</p></div></div><p><strong>Returns</strong></p><ul><li>A <code>FJLTRecipe</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/fjlt.jl#L101-L146">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.Gaussian"><a class="docstring-binding" href="#RLinearAlgebra.Gaussian"><code>RLinearAlgebra.Gaussian</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Gaussian &lt;: Compressor</code></pre><p>A specification for a Gaussian compressor.</p><p><strong>Mathematical Description</strong></p><p>Let <span>$A$</span> be an <span>$m \times n$</span> matrix that we want to compress.</p><p>If we want to compress <span>$A$</span> from the left (i.e., we reduce the number of rows), then we create a Gaussian sketch matrix, <span>$S$</span>, with dimension <span>$s \times m$</span> where <span>$s$</span> is the compression dimension that is supplied by the user. Each entry of <span>$S$</span> is generated independently following N(0, 1/s), namely, a Gaussian distribution with mean being zero and variance being 1 divided by the compression dimension.</p><p>If <span>$A$</span> is compressed from the right, then we create a Gaussian sketch matrix, <span>$S$</span>, with dimension <span>$n \times s$</span>, where <span>$s$</span> is the compression dimension that is supplied by the user. Each entry of <span>$S$</span> is generated independently following N(0, 1/s), namely, a Gaussian distribution with mean being zero and variance being 1 divided by the compression dimension.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li><li><code>compression_dim::Int64</code>, the target compression dimension. Referred to as <span>$s$</span> in    the mathematical description.</li><li><code>type::Type{&lt;:Number}</code>, the type of the elements in the compressor.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Gaussian(;cardinality=Left(), compression_dim=2, type=Float64)</code></pre><p><strong>Arguments</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.   By default <code>Left()</code> is chosen.</li><li><code>compression_dim::Int64</code>, the target compression dimension. Referred to as <span>$s$</span> in    the mathemtical description. By default this is set to 2.</li><li><code>type::Type{&lt;:Number}</code>, the type of elements in the compressor.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Gaussian</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>compression_dim</code> is non-positive</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/gaussian.jl#L1-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.GaussianRecipe"><a class="docstring-binding" href="#RLinearAlgebra.GaussianRecipe"><code>RLinearAlgebra.GaussianRecipe</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GaussianRecipe &lt;: CompressorRecipe</code></pre><p>The recipe containing all allocations and information for the Gaussian compressor.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::C where C&lt;:Cardinality</code>, the cardinality of the compressor. The</li></ul><p>value is either <code>Left()</code> or <code>Right()</code>.</p><ul><li><code>compression_dim::Int64</code>, the target compression dimension.</li><li><code>n_rows::Int64</code>, the number of rows of the compression matrix.</li><li><code>n_cols::Int64</code>, the number of columns of the compression matrix.</li><li><code>scale::Number</code>, the standard deviation of Gaussian distribution during the </li></ul><p>compression matrix generation.</p><ul><li><code>op::Matrix{Float64}</code>, the Gaussian compression matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/gaussian.jl#L72-L86">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.Identity"><a class="docstring-binding" href="#RLinearAlgebra.Identity"><code>RLinearAlgebra.Identity</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Identity &lt;: Compressor</code></pre><p>An implementation of a compressor that returns the original matrix.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Identity(;cardinality=Left())</code></pre><p><strong>Keywords</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Identity</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/identity.jl#L1-L20">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.IdentityRecipe"><a class="docstring-binding" href="#RLinearAlgebra.IdentityRecipe"><code>RLinearAlgebra.IdentityRecipe</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">IdentityRecipe &lt;: CompressorRecipe</code></pre><p>The recipe containing all allocations and information for the <code>Identity</code> compressor.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li><li><code>n_rows::Int64</code>, the number of rows of the compression matrix.</li><li><code>n_cols::Int64</code>, the number of columns of the compression matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/identity.jl#L29-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.Sampling"><a class="docstring-binding" href="#RLinearAlgebra.Sampling"><code>RLinearAlgebra.Sampling</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Sampling &lt;: Compressor</code></pre><p>This method subsets the rows  or columns of a matrix according to a user-supplied distribution. The size of the  subset is also provided by the user.</p><p><strong>Mathematical Description</strong></p><p>Let <span>$A$</span> be an <span>$m \times n$</span> matrix that we want to compress.</p><p>If we want to compress <span>$A$</span> from the left (i.e., we reduce the number of rows), then we create an index set to contain all the indices of selected rows. The indices are  chosen by sampling over all the rows with the user-specified distribution in the  <code>distribution</code> field.</p><p>If <span>$A$</span> is compressed from the right (i.e., we reduce the number of columns), then we create an index set to contain all the indices of selected columns. The indices  are chosen by sampling over all the columns with the user-specified distribution  in the <code>distribution</code> field.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li><li><code>compression_dim::Int64</code>, the target compression dimension.</li><li><code>distribution::Distribution</code>, the distribution being used to assign probability weights   on the indices.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">Sampling(;cardinality = Left(), compression_dim = 2, distribution)</code></pre><p><strong>Arguments</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.   By default <code>Left()</code> is chosen.</li><li><code>compression_dim::Int64</code>, the target compression dimension. By default this is set to 2.</li><li><code>distribution::Distribution</code>, the distribution being used to assign probability weights   on the indices. By default this is set as <code>Uniform</code> distribution.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>Sampling</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>compression_dim</code> is non-positive</li><li><code>ArgumentError</code> if <code>Undef()</code> is taken as the input for <code>cardinality</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/sampling.jl#L1-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.SamplingRecipe"><a class="docstring-binding" href="#RLinearAlgebra.SamplingRecipe"><code>RLinearAlgebra.SamplingRecipe</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SamplingRecipe{C&lt;:Cardinality} &lt;: CompressorRecipe</code></pre><p>The recipe containing all allocations and information for the sampling compressor. </p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the cardinality of the compressor. The   value is either <code>Left()</code> or <code>Right()</code>.</li><li><code>compression_dim::Int64</code>, the target compression dimension.</li><li><code>n_rows::Int64</code>, number of rows of compression matrix.</li><li><code>n_cols::Int64</code>, number of columns of compression matrix.</li><li><code>distribution_recipe::DistributionRecipe</code>, the user-specified distribution recipe.</li><li><code>idx::Vector{Int64}</code>, the index set that contains all the chosen indices.</li><li><code>idx_v::SubArray</code>, the view of the <code>idx</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/sampling.jl#L76-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.SparseSign"><a class="docstring-binding" href="#RLinearAlgebra.SparseSign"><code>RLinearAlgebra.SparseSign</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SparseSign &lt;: Compressor</code></pre><p>An implementation of the sparse sign compression method. This method forms a sparse matrix with a fixed number of non-zeros per row or column depending on the direction that the compressor is being applied. See Section 9.2 of [<a href="../../references/#martinsson2020randomized">5</a>] for additional details.</p><p><strong>Mathematical Description</strong></p><p>Let <span>$A$</span> be an <span>$m \times n$</span> matrix that we want to compress. If we want to compress <span>$A$</span> from the left (i.e., we reduce the number of rows), then we create a sparse sign matrix, <span>$S$</span>, with dimension <span>$s \times m$</span> where <span>$s$</span> is the compression dimension that is supplied by the user. In this case, each column of <span>$S$</span> is generated independently by the following steps:</p><ol><li>Randomly choose <code>nnz</code> components of the the <span>$s$</span> components of the column. Note, <code>nnz</code>  is supplied by the user.</li><li>For each selected component, randomly set it either to <span>$-1/\sqrt{\text{nnz}}$</span> or  <span>$1/\sqrt{\text{nnz}}$</span> with equal probability.</li><li>Set the remaining components of the column to zero.</li></ol><p>If <span>$A$</span> is compressed from the right, then we create a sparse sign matrix, <span>$S$</span>, with dimension <span>$n \times s$</span>, where <span>$s$</span> is the compression dimension that is supplied by the user. In this case, each row of <span>$S$</span> is generated independently by the following steps:</p><ol><li>Randomly choose <code>nnz</code> components of the <span>$s$</span> components of the row. Note, <code>nnz</code>  is supplied by the user.</li><li>For each selected component, randomly set it either to <span>$-1/\sqrt{\text{nnz}}$</span> or  <span>$1/\sqrt{\text{nnz}}$</span> with equal probability.</li><li>Set the remaining components of the row to zero.</li></ol><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li><li><code>compression_dim::Int64</code>, the target compression dimension. Referred to as <span>$s$</span> in the   mathematical description.</li><li><code>nnz::Int64</code>, the target number of nonzeros for each column or row of the spares sign   matrix.</li><li><code>type::Type{&lt;:Number}</code>, the type of the elements in the compressor.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SparseSign(;carinality=Left(), compression_dim=2, nnz::Int64=8, type=Float64)</code></pre><p><strong>Keywords</strong></p><ul><li><code>carinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.   By default <code>Left()</code> is chosen.</li><li><code>compression_dim</code>, the target compression dimension. Referred to as <span>$s$</span> in the   mathemtical description. By default this is set to 2.</li><li><code>nnz::Int64</code>, the number of non-zeros per row/column in the sampling matrix. By default   this is set to min(compressiond_dim, 8).</li><li><code>type::Type{&lt;:Number}</code>, the type of elements in the compressor.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>SparseSign</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>compression_dim</code> is non-positive, if <code>nnz</code> is exceeds   <code>compression_dim</code>, or if <code>nnz</code> is non-positive.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/sparse_sign.jl#L1-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.SparseSignRecipe"><a class="docstring-binding" href="#RLinearAlgebra.SparseSignRecipe"><code>RLinearAlgebra.SparseSignRecipe</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SparseSignRecipe{C&lt;:Cardinality} &lt;: CompressorRecipe</code></pre><p>The recipe containing all allocations and information for the SparseSign compressor.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to</li></ul><p>be applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</p><ul><li><code>n_rows::Int64</code>, the number of rows of the compression matrix.</li><li><code>n_cols::Int64</code>, the number of columns of the compression matrix.</li><li><code>nnz::Int64</code>, the number of non-zero entries in each row if <code>cardinality==Left</code> or the</li></ul><p>number of non-zero entries each column if <code>cardinality==Right</code>.</p><ul><li><code>scale::Vector{Number}</code>, the set of values of the non-zero entries of the Spares Sign</li></ul><p>compression matrix.</p><ul><li><code>op::SparseMatrixCSC</code>, the Spares Sign compression matrix.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">SparseSignRecipe(
    cardinality::C where C&lt;:Cardinality,
    compression_dim::Int64, 
    A::AbstractMatrix, 
    nnz::Int64, 
    type::Type{&lt;:Number}
)</code></pre><p>An external constructor of <code>SparseSignRecipe</code> that is dispatched based on the  value of <code>cardinality</code>. See <a href="#RLinearAlgebra.SparseSign">SparseSign</a> for additional details. </p><p><strong>Arguments</strong></p><ul><li><code>cardinality::C where C&lt;:Cardinality</code>, the cardinality of the compressor. The    value is either <code>Left()</code> or <code>Right()</code></li><li><code>compression_dim::Int64</code>, the target compression dimension.</li><li><code>A::AbstractMatrix</code>, a target matrix for compression. </li><li><code>nnz::Int64</code>, the number of nonzeros in the Sparse Sign compression matrix.</li><li><code>type::Type{&lt;:Number}</code>, the data type for the entries of the compression matrix.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>SparseSignRecipe</code> object.</li></ul><div class="admonition is-warning" id="Use-complete_compressor-d208edd937de4407"><header class="admonition-header">Use `complete_compressor`<a class="admonition-anchor" href="#Use-complete_compressor-d208edd937de4407" title="Permalink"></a></header><div class="admonition-body"><p>While an external constructor is provided, it is mainly for internal use. To ensure cross library compatibility please use <a href="#RLinearAlgebra.complete_compressor"><code>complete_compressor</code></a> for forming the <code>SparseSignRecipe</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/sparse_sign.jl#L174-L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.SRHT"><a class="docstring-binding" href="#RLinearAlgebra.SRHT"><code>RLinearAlgebra.SRHT</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SRHT &lt;: Compressor</code></pre><p>An implementation of the Subsampled Randomized Hadamard Transform (SRHT) method. This  technique applies a subsampling matrix, a Walsh-Hadamard transform, and a diagonal sign  matrix to produce a sketch. See [<a href="../../references/#tropp2011improved">9</a>] for additional details.</p><p><strong>Mathematical Description</strong></p><p>Let <span>$A$</span> be an <span>$m \times n$</span> matrix that we want to compress. If we want to compress <span>$A$</span> from the left (i.e., we reduce the number of rows), then we create a matrix, <span>$S$</span>, with dimension <span>$s \times m$</span> where <span>$s$</span> is the compression dimension that is supplied by the user. Here <span>$S=KHD$</span> where </p><ul><li><span>$K$</span> is a matrix with  with dimension <span>$s \times m$</span>, where the rows are made up of a    random sample of the rows of a <span>$m \times m$</span> identity matrix.</li><li><span>$H$</span> is a Hadamard matrix of dimension <span>$m \times m$</span>, which is implicitly applied    through the fast Walsh-Hadamard transform;</li><li><span>$D$</span> of is a diagonal matrix of dimension <span>$m \times m$</span> with entries given by    independent Rademacher variables.</li></ul><p>If we want to compress <span>$A$</span> from the right (i.e., we reduce the number of columns), then  we would apply <span>$S=DHK$</span> from the right where the dimensions of the matrices are adjusted  to reflect the number of columns in <span>$A$</span>.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li><li><code>compression_dim::Int64</code>, the target compression dimension. Referred to as <span>$s$</span> in the   mathematical description.</li><li><code>block_size::Int64</code>, the number of vectors in the padding matrix.</li><li><code>type::Type{&lt;:Number}</code>, the type of the elements in the compressor.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SRHT(;
    cardinality = Left(),
    compression_dim::Int64=2,
    block_size::Int64=10,
    type::Type{N}=Float64
) where {N &lt;: Number}</code></pre><p><strong>Keywords</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.   By default <code>Left()</code> is chosen.</li><li><code>compression_dim::Int64</code>, the target compression dimension. Referred to as <span>$s$</span> in the   mathematical description. By default this is set to 2.</li><li><code>block_size::Int64</code>, the number of vectors in the padding matrix.</li><li><code>type::Type{&lt;:Number}</code>, the type of elements in the compressor.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>SRHT</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if <code>compression_dim</code> is non-positive or if <code>block_size</code> is non-positive.</li><li><code>ArgumentError</code> if Cardinality is not either <code>Left</code> or <code>Right</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/srht.jl#L1-L59">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.SRHTRecipe"><a class="docstring-binding" href="#RLinearAlgebra.SRHTRecipe"><code>RLinearAlgebra.SRHTRecipe</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SRHTRecipe{C&lt;:Cardinality, M&lt;:AbstractMatrix} &lt;: CompressorRecipe</code></pre><p>The recipe containing all allocations and information for the SRHT compressor.</p><p><strong>Fields</strong></p><ul><li><code>cardinality::Cardinality</code>, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li><li><code>n_rows::Int64</code>, the number of rows of the compression matrix.</li><li><code>n_cols::Int64</code>, the number of columns of the compression matrix.</li><li><code>scale::Float64</code>, the factor to ensure the isopmorphism of the sketch.</li><li><code>op::Vector{Int64}</code>, the vector of indices to be subsampled.</li><li><code>signs::BitVector</code>, the vector of signs where <code>0</code> indicates negative one and <code>1</code> indicates   positive one. </li><li><code>padding::AbstractMatrix</code>, the matrix containing the padding for the matrix being    sketched.</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">SRHTRecipe(
    compression_dim::Int64,
    block_size::Int64,
    cardinality::Left,
    A::AbstractMatrix,
    type::Type{&lt;:Number}
)</code></pre><p><strong>Keywords</strong></p><ul><li><code>compression_dim::Int64</code>, the target compression dimension. Referred to as <span>$s$</span> in the   mathematical description.</li><li><code>block_size::Int64</code>, the number of vectors in the padding matrix.</li><li><code>cardinality::Left</code>, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are <code>Left()</code> or <code>Right()</code>.</li><li><code>A::AbstractMatrix</code>, the matrix being compressed.</li><li><code>type::Type{&lt;:Number}</code>, the type of elements in the compressor.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/srht.jl#L90-L124">source</a></section></details></article><h2 id="Exported-Functions"><a class="docs-heading-anchor" href="#Exported-Functions">Exported  Functions</a><a id="Exported-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RLinearAlgebra.complete_compressor"><a class="docstring-binding" href="#RLinearAlgebra.complete_compressor"><code>RLinearAlgebra.complete_compressor</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">complete_compressor(compressor::Compressor, x::AbstractVector)</code></pre><p>A function that generates a <code>CompressorRecipe</code> given the      arguments.</p><p><strong>Arguments</strong></p><ul><li><code>compressor::Compressor</code>, a user-specified compression method.</li><li><code>x::AbstractVector</code>, a vector that ususally represents a current iterate    typically used in a solver.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CompressorRecipe</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if no method for completing the compressor exists    for the given arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L111-L125">source</a></section><section><div><pre><code class="language-julia hljs">complete_compressor(compressor::Compressor, A::AbstractMatrix)</code></pre><p>A function that generates a <code>CompressorRecipe</code> given the      arguments.</p><p><strong>Arguments</strong></p><ul><li><code>compressor::Compressor</code>, a user-specified compression method.</li><li><code>A::AbstractMatrix</code>, a target matrix for compression.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CompressorRecipe</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if no method for completing the compressor exists    for the given arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L131-L145">source</a></section><section><div><pre><code class="language-julia hljs">complete_compressor(compressor::Compressor, A::AbstractMatrix, b::AbstractVector)</code></pre><p>A function that generates a <code>CompressorRecipe</code> given the      arguments.</p><p><strong>Arguments</strong></p><ul><li><code>compressor::Compressor</code>, a user-specified compression method.</li><li><code>A::AbstractMatrix</code>, a target matrix for compression.</li><li><code>b::AbstractVector</code>, a possible target vector for compression.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CompressorRecipe</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if no method for completing the compressor exists    for the given arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L155-L170">source</a></section><section><div><pre><code class="language-julia hljs">complete_compressor(
    compressor::Compressor, 
    x::AbstractVector
    A::AbstractMatrix, 
    b::AbstractVector, 
)</code></pre><p>A function that generates a <code>CompressorRecipe</code> given the      arguments.</p><p><strong>Arguments</strong></p><ul><li><code>compressor::Compressor</code>, a user-specified compression method.</li><li><code>x::AbstractVector</code>, a vector that ususally represents a current iterate    typically used in a solver.</li><li><code>A::AbstractMatrix</code>, a target matrix for compression.</li><li><code>b::AbstractVector</code>, a possible target vector for compression.</li></ul><p><strong>Returns</strong></p><ul><li>A <code>CompressorRecipe</code> object.</li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if no method for completing the compressor exists    for the given arguments.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L176-L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.update_compressor!"><a class="docstring-binding" href="#RLinearAlgebra.update_compressor!"><code>RLinearAlgebra.update_compressor!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">update_compressor!(S::CompressorRecipe)</code></pre><p>A function that updates the <code>CompressorRecipe</code> in place given      arguments.</p><p><strong>Arguments</strong></p><ul><li><code>S::CompressorRecipe</code>, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if no method exists for updating the compressor    exists.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L211-L224">source</a></section><section><div><pre><code class="language-julia hljs">update_compressor!(S::CompressorRecipe, A::AbstractMatrix)</code></pre><p>A function that updates the <code>CompressorRecipe</code> in place given      arguments.</p><p><strong>Arguments</strong></p><ul><li><code>S::CompressorRecipe</code>, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.</li><li><code>A::AbstractMatrix</code>, a target matrix for compression.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if no method exists for updating the compressor    exists.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L234-L248">source</a></section><section><div><pre><code class="language-julia hljs">update_compressor!(S::CompressorRecipe, A::AbstractMatrix, b::AbstractVector)</code></pre><p>A function that updates the <code>CompressorRecipe</code> in place given      arguments.</p><p><strong>Arguments</strong></p><ul><li><code>S::CompressorRecipe</code>, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.</li><li><code>A::AbstractMatrix</code>, a target matrix for compression.</li><li><code>b::AbstractVector</code>, a possible target vector for compression.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if no method exists for updating the compressor    exists.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L254-L269">source</a></section><section><div><pre><code class="language-julia hljs">update_compressor!(
    S::CompressorRecipe, 
    A::AbstractMatrix, 
    b::AbstractVector,
    x::AbstractMatrix
)</code></pre><p>A function that updates the <code>CompressorRecipe</code> in place given      arguments.</p><p><strong>Arguments</strong></p><ul><li><code>S::CompressorRecipe</code>, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.</li><li><code>x::AbstractVector</code>, a vector that ususally represents a current iterate    typically used in a solver.</li><li><code>A::AbstractMatrix</code>, a target matrix for compression.</li><li><code>b::AbstractVector</code>, a possible target vector for compression.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>ArgumentError</code> if no method exists for updating the compressor    exists.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors.jl#L275-L296">source</a></section></details></article><h2 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RLinearAlgebra.left_mul_dimcheck"><a class="docstring-binding" href="#RLinearAlgebra.left_mul_dimcheck"><code>RLinearAlgebra.left_mul_dimcheck</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">left_mul_dimcheck(C::AbstractMatrix, S::CompressorRecipe, A::AbstractMatrix)</code></pre><p>A function that checks the compatibility of arguments for      multiplication from the left.</p><p><strong>Arguments</strong></p><ul><li><code>C::AbstractArray</code>, a AbstractArray where the output will be stored.</li><li><code>S::Union{CompressorRecipe, ApproximatorRecipe}</code>, a fully    initialized realization for a compression or approximator method for a    specific AbstractArray or operator.</li><li><code>A::AbstractArray</code>, a target AbstractArray for compression.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code> if dimensions of arguments are not compatible for   multiplication.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/helpers/mul_dim_checks.jl#L24-L40">source</a></section><section><div><pre><code class="language-julia hljs">left_mul_dimcheck(C::AbstractMatrix, S::CompressorAdjoint, A::AbstractMatrix)</code></pre><p>A function that checks the compatibility of arguments for      multiplication from the left.</p><p><strong>Arguments</strong></p><ul><li><code>C::AbstractArray</code>, a AbstractArray where the output will be stored.</li><li><code>S::Union{CompressorAdjoint, ApproximatorAdjoint}</code>, the    representation of an adjoint of a compression or approximator operator.</li><li><code>A::AbstractArray</code>, a target AbstractArray for compression.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code> if dimensions of arguments are not compatible for   multiplication.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/helpers/mul_dim_checks.jl#L66-L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.right_mul_dimcheck"><a class="docstring-binding" href="#RLinearAlgebra.right_mul_dimcheck"><code>RLinearAlgebra.right_mul_dimcheck</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">right_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix, S::CompressorRecipe)</code></pre><p>A function that checks the compatibility of arguments for      multiplication from the right.</p><p><strong>Arguments</strong></p><ul><li><code>C::AbstractArray</code>, a AbstractArray where the output will be stored.</li><li><code>A::AbstractArray</code>, a target AbstractArray for compression.</li><li><code>S::Union{CompressorRecipe, ApproximatorRecipe}</code>, a fully    initialized realization for a compression or approximator method for a    specific AbstractArray or operator.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code> if dimensions of arguments are not compatible for   multiplication.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/helpers/mul_dim_checks.jl#L93-L109">source</a></section><section><div><pre><code class="language-julia hljs">right_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix, S::CompressorAdjoint)</code></pre><p>A function that checks the compatibility of arguments for      multiplication from the right.</p><p><strong>Arguments</strong></p><ul><li><code>C::AbstractArray</code>, a AbstractArray where the output will be stored.</li><li><code>A::AbstractArray</code>, a target AbstractArray for compression.</li><li><code>S::Union{CompressorAdjoint, ApproximatorAdjoint}</code>, the    representation of an adjoint of a compression or approximator operator.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul><p><strong>Throws</strong></p><ul><li><code>DimensionMismatch</code> if dimensions of arguments are not compatible for   multiplication.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/helpers/mul_dim_checks.jl#L135-L151">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.sparse_idx_update!"><a class="docstring-binding" href="#RLinearAlgebra.sparse_idx_update!"><code>RLinearAlgebra.sparse_idx_update!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sparse_idx_update!(
    values::Vector{Int64}, 
    max_sample_val::Int64, 
    n_samples::Int64, 
    sample_size::Int64
)</code></pre><p>Implicitly splits <code>values</code> into <code>n_samples</code> components of size <code>sample_size</code>.  On each component, replaces the entries of each component with a random sample  without replacement of size <code>sample_size</code> from the set <code>1:max_sample_val</code>.</p><div class="admonition is-category-warn" id="Warn-381f687941cf44f5"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-381f687941cf44f5" title="Permalink"></a></header><div class="admonition-body"><p><code>values</code> should have length equal to <code>sample_size*n_samples</code>, but this  is not checked. </p></div></div><p><strong>Arguments</strong></p><ul><li><code>values::Vector{Int64}</code>, a vector containing samples from <code>1:max_sample_val</code>.</li><li><code>max_sample_val::In64</code>, implicitly supplies the set from which to sample,   <code>1:max_sample_val</code>.</li><li><code>n_samples::Int64</code>, the number of components that <code>values</code> is implicitly split into. </li><li><code>sample_size::Int64</code>, the size each component that <code>values</code> is split into.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/sparse_sign.jl#L129-L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RLinearAlgebra.fwht!"><a class="docstring-binding" href="#RLinearAlgebra.fwht!"><code>RLinearAlgebra.fwht!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fwht!(x::AbstractVector, signs::BitVector; scaling::Int64 = 1)</code></pre><p>Performs an in-place Fast Walsh Hadamard Transform on the vector x.   <code>signs</code> allows the user to input a boolean vector that flips the signs of the entries  of the vector <code>x</code> before applying the transform. <code>scaling</code> allows the user to scale the  result of the transform. Choosing a scaling of 1/sqrt{size(x)} will result in the FWHT  being an orthogonal transform.</p><p><strong>Arguments</strong></p><ul><li><code>x::AbstractVector</code>, the vector the FJLT will be applied to.</li><li><code>signs::Vector{Bool}</code>, whether the sign of each entry is positive or negative.</li></ul><p><strong>Keywords</strong></p><ul><li><code>scaling::Number</code>, how much the vector is scaled, by default this is 1.</li></ul><p><strong>Returns</strong></p><ul><li><code>nothing</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/160c0d0512e2568c7c3f4cb047736b2e23b86398/src/Compressors/helpers/fwht.jl#L1-L20">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/least_squares/least_squares/">« Solving a Least Squares Problem</a><a class="docs-footer-nextpage" href="../distributions/">Distributions API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 6 February 2026 05:38">Friday 6 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
