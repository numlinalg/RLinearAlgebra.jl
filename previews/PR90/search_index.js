var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"N. Halko, P. G. Martinsson and J. A. Tropp. Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review 53, 217–288 (2011).\n\n\n\nD. P. Woodruff. Sketching as a tool for numerical linear algebra. Foundations and Trends in Theoretical Computer Science 10, 1–157 (2014).\n\n\n\nN. Ailon and B. Chazelle. The Fast Johnson–Lindenstrauss Transform and Approximate Nearest Neighbors. SIAM Journal on Computing 39, 302–322 (2009).\n\n\n\nP.-G. Martinsson and J. Tropp. Randomized Numerical Linear Algebra: Foundations &amp; Algorithms (2020).\n\n\n\nJ. A. Tropp. Improved Analysis of the Subsampled Randomized Hadamard Transform. Advances in Adaptive Data Analysis 03, 115–126 (2011).\n\n\n\nT. Strohmer and R. Vershynin. A Randomized Kaczmarz Algorithm with Exponential Convergence. Journal of Fourier Analysis and Applications 15, 262–278 (2009).\n\n\n\nD. Needell and J. A. Tropp. Paved with Good Intentions: Analysis of a Randomized Block Kaczmarz Method. Linear Algebra and its Applications 441, 199–221 (2014).\n\n\n\nV. Patel, M. Jahangoshahi and D. A. Maldonado. Randomized Block Adaptive Linear System Solvers. SIAM Journal on Matrix Analysis and Applications 44, 1349–1369 (2023).\n\n\n\nT. S. Motzkin and I. J. Schoenberg. The Relaxation Method for Linear Inequalities. Canadian Journal of Mathematics 6, 393–404 (1954).\n\n\n\n","category":"page"},{"location":"dev/design/#Design","page":"Design of Library","title":"Design","text":"","category":"section"},{"location":"dev/design/#Overview-Library-Goals","page":"Design of Library","title":"Overview Library Goals","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"RLinearAlgebra.jl implements randomized numerical linear algebra (RNLA) routines for two tasks: (1) solving a matrix equations and (2) forming a low-rank approximation  to matrices.  The primary tool Randomized Linear Algebra uses to accomplish these tasks is multiplying the large matrix system by a smaller randomized matrix to compress the  large matrix. In the literature this process if often referred to as sampling or sketching, RLinearAlgebra.jl refers to this process as compression. ","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The library is organized with main techniques falling into one of three types:  Approximators, Compressors, and Solvers. Solvers feature their own set of  sub-techniques: Loggers, SolverErrors, and SubSolvers that facilitate solving. Approximators have only one set of sub-techniques known as ApproximatorErrors.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"RLinearAlgebra.jl is designed so that the codebase has a good balance between efficiency  and modularity. RLinearAlgebra.jl tries to achieve these goals by introducing two  structures, one that contains user-controlled parameters which takes the form of  [Technique] and a second that is used by the technique to execute the techniques because it contains the necessary preallocated memory and is known as a [Technique]Recipe.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"We can see an example of the difference between the two structures when considering an  implementation of compression with Gaussian matrices. In this implementation we wish to  have the user specify a compression dimension and size without having to know the dimension of the matrix the sketch is applied to. The Gaussian structure facilitates this by having  two fields n_rows  and n_cols with the default for both being zero. When the user then  constructs this structure the can specify the dimension and direction of the compression  by specifying the number of rows or columns they wish for the compression matrix to have. If the user wanted a Gaussian matrix with 3 rows they would call  Gaussian(n_rows = 3). We then turn this dimensional information into an usable compression matrix by using the complete_compressor function to form a GaussianRecipe. This  GaussianRecipe contains Fields n_rows = 3, n_cols set to be the number of rows in the compressor, and a Gaussian matrix of the size specified by n_rows and n_cols.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Once a [Technique]Recipe has been created, this data structure can then be used to  execute a particular technique. The command to execute each technique varies by the class  of techniques, as such we lay out the specifics for each type of techniques in the following  section.","category":"page"},{"location":"dev/design/#Technique-Types","page":"Design of Library","title":"Technique Types","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Overall, there are three top-level technique types: (1) Compressors, (2) Solvers, and  (3) Approximators, with the latter two also having additional sets of technique types used in the execution of the top-level techniques. We group the discussions of the technique  classes by top-level technique.","category":"page"},{"location":"dev/design/#Compressors","page":"Design of Library","title":"Compressors","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"When implementing a Compressor, RLinearAlgebra requires an mutable Compressor  structure, a mutable CompressorRecipe structure, a complete_compressor function, a  update_compressor! function, and for five input mul! functions (one for applying the  compressor to vectors, one for applying the adjoint of a compressor to a vector,  and two for applying the compressor to matrices). ","category":"page"},{"location":"dev/design/#Compressor-Structure","page":"Design of Library","title":"Compressor Structure","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Every compression technique needs a place to store user-controlled parameters.  This will be accomplished by the immutable Compressor structure.  We present an example structure used for the Sparse Sign technique.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"struct SparseSign <: Compressor\n    n_rows::Int64\n    n_cols::Int64\n    nnz::Int64\nend","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"You will first notice that n_rows and n_cols are fields present in the Compressor,  these fields allow for the user to specify either the number of rows or the number of  columns they wish the compressor to have. Both n_rows and n_cols are required for  every Compressor structure. Beyond those fields the technique will dictate the other  parameters that should be made available to the user. In addition to the structure, there  should be a constructor for the structure that accepts keyword inputs for each  field of the Compressor structure. For example in the SparseSign case we define,","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function SparseSign(;n_rows::Int64 = 0, n_cols::Int64 = 0, nnz::Int64 = 8)\n    # Partially construct the sparse sign datatype\n    return SparseSign(n_rows, n_cols, nnz)\nend","category":"page"},{"location":"dev/design/#CompressorRecipe-Structure","page":"Design of Library","title":"CompressorRecipe Structure","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"To form the compressor from the user-inputted information, we need information about the  linear system. Once this information is attained preallocations of the necessary memory can  be done. These preallocations are then stored in the CompressorRecipe structure. Because this structure has all of the preallocated memory for applying the compression technique it is this structure that can be applied to matrices and vectors. ","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"As example, we have included the CompressorRecipe for the sparse sign compressor. This structure importantly includes the size of the compressor in the n_rows and n_cols  fields","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct SparseSignRecipe <: CompressorRecipe\n    n_rows::Int64\n    n_cols::Int64\n    max_idx::Int64\n    nnz::Int64\n    scale::Float64\n    idxs::Vector{Int64}\n    signs::Vector{Bool}\nend","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Here we have the required n_rows and n_cols fields for all compressors. The  remaining fields are specific to the sparse sign compression technique. ","category":"page"},{"location":"dev/design/#complete_compressor","page":"Design of Library","title":"complete_compressor","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"To create the CompressorRecipe from linear system information and the user-controlled  parameters, we use the function complete_compressor(::Compressor, ::AbsractMatrix),  if vector information is required we can also define  complete_compressor(::Compressor, ::AbsractMatrix, ::AbstractVector).  An example of how this is done for the sparse sign case can be seen below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_compressor(sparse_info::SparseSign, A::AbstractMatrix)\n    n_rows = sparse_info.n_rows\n    n_cols = sparse_info.n_cols\n    # FInd the zero dimension and set it to be the dimension of A\n    if n_rows == 0 && n_cols == 0\n        # by default we will compress the row dimension to size 2\n        n_cols = size(A, 1)\n        n_rows = 2\n        # correct these sizes\n        initial_size = max(n_rows, n_cols)\n        sample_size = min(n_rows, n_cols)\n    elseif n_rows == 0 && n_cols > 0\n        # Assuming that if n_rows is not specified we compress column dimension\n         n_rows = size(A, 2)\n         # If the user specifies one size as nonzero that is the sample size\n         sample_size = n_cols\n         initial_size = n_rows\n    elseif n_rows > 0 && n_cols == 0\n        n_cols = size(A, 1)\n        sample_size = n_rows\n        initial_size = n_cols\n    else\n        if n_rows == size(A, 2)\n            initial_size = n_rows\n            sample_size = n_cols\n        elseif n_cols == size(A, 2)\n            initial_size = n_cols\n            sample_size == n_rows\n        else\n            @assert false \"Either you inputted row or column dimension must match \\\\\n            the column or row dimension of the matrix.\"\n        end\n    end\n\n    nnz = (sparse_info.nnz == 8) ? min(8, sample_size) : sparse_info.nnz\n    @assert nnz <= sample_size \"Number of non-zero indices, $nnz, must be less than \\\\ \n        compression dimension, $sample_size.\"\n    idxs = Vector{Int64}(undef, nnz * initial_size)\n    start = 1\n    for i in 1:initial_size\n        # every grouping of nnz entries corresponds to each row/column in sample\n        stop = start + nnz - 1\n        # Sample indices from the intial_size\n        @views sample!(\n            1:sample_size, \n            idxs[start:stop], \n            replace = false, \n            ordered = true\n        )\n        start = stop + 1\n    end\n    \n    # Store signs as a boolean to save memory\n    signs = bitrand(nnz * initial_size)\n    scale = 1 / sqrt(nnz)\n    \n    return SparseSignRecipe(n_rows, n_cols, sample_size, nnz, scale, idxs, signs)\nend","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The complete_compressor function assumes that if the user inputs only n_rows or n_cols  in the Compressor structure this is the desired compression dimension. If they input  neither, it creates a compressor with a compression dimension of two and  if the input both and neither is consistent with  a dimension of the inputted linear system it returns an error. Otherwise, it assumes the  inconsistent dimension is the compression dimension. Once the sizes of the compressor have  been determined it next allocates the memory necessary for storing the initial compressor and packages these allocations with the size information into the CompressorRecipe.","category":"page"},{"location":"dev/design/#update_compressor!","page":"Design of Library","title":"update_compressor!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"To generate a new version of the compressor we can call the function update_compressor!,  this function simply changes the random components of the CompressorRecipe. In the sparse  sign case this means updating the nonzero indices and the signs as can be seen in the  following example code.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function update_compressor!(\n                            S::SparseSignRecipe, \n                            A::AbstractMatrix, \n                            b::AbstractVector, \n                            x::AbstractVector\n                           )\n    # Sample_size will be the minimum of the two size dimensions of `S`\n    sample_size = min(S.n_rows, S.n_cols)\n    initial_size = max(S.n_rows, S.n_cols)\n    start = 1\n    for i in 1:sample_size\n        # every grouping of nnz entries corresponds to each row/column in sample\n        stop = start + S.nnz - 1\n        # Sample indices from the intial_size\n        @views sample!(\n            1:sample_size, \n            S.idxs[start:stop], \n            replace = false, \n            ordered = true\n        )\n        start = stop + 1\n    end\n    # There is no inplace update of bitrand and using sample is slower\n    S.signs .= bitrand(S.nnz * initial_size) \n    return\nend","category":"page"},{"location":"dev/design/#mul!","page":"Design of Library","title":"mul!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The last pieces of code that every compression technique requires are the mul! functions.  For these functions we follow the conventions laid out in the LinearAlgebra library where  there are five inputs (C, A, S, alpha, beta) and it outputs C = beta * C + alpha * A * S. The mul! functions that should be implemented are two for applying the compression matrix to vectors, one in standard orientation and one for when the adjoint of the compressor is  applied to the vector. Additionally, two mul! functions should be implemented for when  the compression matrix is applied to a matrix, one for when the compression matrix, S, is  applied from the left, i.e. AS, and one for when the compression matrix is applied from the  right, i.e. SA. ","category":"page"},{"location":"dev/design/#Solvers","page":"Design of Library","title":"Solvers","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A Solver technique is any technique that aims to find a vector x such that either  Ax = b or x = min_u A u - b_2^2. Solvers rely on compression techniques,  logging techniques, error techniques, and sub-solver techniques. We first discuss  implementation requirements for the sub-techniques and then discuss how we can use these  when creating a solver structure.","category":"page"},{"location":"dev/design/#Loggers","page":"Design of Library","title":"Loggers","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Loggers are structures with two goals (1) log a progress value produced by an error metric and (2) evaluate whether that error is sufficient for stopping. The user controlled inputs for a logging technique are contained in the Logger structure.","category":"page"},{"location":"dev/design/#Logger","page":"Design of Library","title":"Logger","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The Logger structure is where the user inputs any information required  to logging progress and stopping the method. The Logger is required to have a field for  max_it, threshold_info, and stopping_criterion. The max_it field is a field for the maximum number of iterations of the method. The stopping_criterion is a field that contains a function that returns a stopping decision based on the information in the  LoggerRecipe and the Tuple of information supplied by the user in the threshold_info  field. It is important to note that constructors for these techniques should have keyword  inputs with predefined defaults. We present an example of the Logger structure for a  BasicLogger below","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"struct BasicLogger <: Logger\n    max_it::Int64\n    collection_rate::Int64\n    threshold_info::Union{Float64, Tuple}\n    stopping_criterion::Function\nend","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Aside from the required parameters the BasicLogger also features a collection rate  parameter to allow the user to specify how often they wish for the LoggerRecipe to log  progress.","category":"page"},{"location":"dev/design/#LoggerRecipe","page":"Design of Library","title":"LoggerRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The LoggerRecipe will contain the user-controlled parameters from the Logger as well as  memory for storing the logged information. All LoggerRecipes  must contain a max_it field and a converged field, where the converged field is a  boolean indicating if the method has converged. An example of a LoggerRecipe is presented  below for the BasicLoggerRecipe.  This Logger has a vector for the history of the progress  metric, a field whose inclusion is strongly suggested. It also has record_location field  to keep track of where the next observed progress estimate should be placed depending  on the collection_rate.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct BasicLoggerRecipe{F} <: LoggerRecipe where F<:Function\n    max_it::Int64\n    err::Float64\n    threshold_info::Union{Float64, Tuple}\n    iteration::Int64\n    record_location::Int64\n    collection_rate::Int64\n    converged::Bool\n    stopping_criterion::F\n    hist::Vector{Float64}\nend","category":"page"},{"location":"dev/design/#complete_logger","page":"Design of Library","title":"complete_logger","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"As with the other techniques, complete_logger  takes a Logger data structure and  performs the appropriate allocations to generate a LoggerRecipe. An example of this  function for BasicLogger is presented below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_logger(logger::BasicLogger, A::AbstractMatrix)\n    # We will run for a number of iterations equal to 3 itmes the number of rows if maxit is\n    # not set\n    max_it = logger.max_it == 0 ? 3 * size(A, 1) : logger.max_it\n\n    max_collection = Int(ceil(max_it / logger.collection_rate))\n    # use one more than max it form collection\n    hist = zeros(max_collection + 1)\n    return BasicLoggerRecipe{typeof(logger.stopping_criterion)}(max_it,\n                                                                0.0,\n                                                                logger.threshold_info,\n                                                                1,\n                                                                1,\n                                                                logger.collection_rate,\n                                                                false,\n                                                                logger.stopping_criterion,\n                                                                hist\n                                                               )\nend","category":"page"},{"location":"dev/design/#update_logger!","page":"Design of Library","title":"update_logger!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"As with the compressors update_logger! performs an in-place update of the  LoggerRecipe using the inputted progress metric and iteration of the method. An example of  the update_logger! function for the BasicLoggerRecipe is included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function update_logger!(logger::BasicLoggerRecipe, err::Float64, iteration::Int64)\n    logger.iteration = iteration\n    logger.err = err\n    if rem(iteration, logger.collection_rate) == 0\n        logger.hist[logger.record_location] = err\n        logger.record_location += 1\n    end\n    # Always check max_it stopping criterion\n    # Compute in this way to avoid bounds error from searching in the max_it + 1 location\n    logger.converged = iteration <= logger.max_it ? logger.stopping_criterion(logger) : \n        false\n    return\n\nend","category":"page"},{"location":"dev/design/#Stopping-Functions","page":"Design of Library","title":"Stopping Functions","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"As was noted in the description of the required fields for the Logger the user should  have the opportunity to input a stopping function that should take the input of a  LoggerRecipe to which it updates the value of the converged field if stopping should  occur. An example implementation of function for threshold stopping, stop when progress  the metric falls below a particular threshold is presented below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function threshold_stop(log::LoggerRecipe)\n    return log.err < log.threshold_info\nend","category":"page"},{"location":"dev/design/#SolverErrors","page":"Design of Library","title":"SolverErrors","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"For computing the progress of a solver it is important to include implementations of  particular error techniques. These typically will be techniques like the residual or  compressed residual, but could be more complicated techniques like an estimate of backwards stability. ","category":"page"},{"location":"dev/design/#SolverError","page":"Design of Library","title":"SolverError","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a structure that holds user-controlled parameters for a progress estimation  technique. For basic techniques like the residual where no user-controlled parameters are  required this will simply be an empty structure. We have included an example of a  SolverError structure for the residual computations. It is important to note that  constructors for these techniques should have keyword inputs with predefined defaults.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"struct FullResidual <: SolverError\n\nend","category":"page"},{"location":"dev/design/#SolverErrorRecipe","page":"Design of Library","title":"SolverErrorRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This structure contains the user-controlled parameters from the SolverError as well  memory allocations of a size determined based on the linear system. An example for a  residual technique has been included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct FullResidualRecipe{V<:AbstractVector} <: SolverErrorRecipe\n    residual::V\nend","category":"page"},{"location":"dev/design/#complete_error","page":"Design of Library","title":"complete_error","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"To generate the SolverErrorRecipe from the information in the linear system and  SolverError we use the function complete_error. This function should be implemented to take the inputs of the SolverError, a matrixArepresenting the linear system, and a  vectorb` representing the constant vector of the linear system. An example of this  function for the residual error technique has been included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_error(error::FullResidual, A::AbstractMatrix, b::AbstractVector)\n    return FullResidualRecipe{typeof(b)}(zeros(size(b,1)))\nend","category":"page"},{"location":"dev/design/#compute_error","page":"Design of Library","title":"compute_error","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"To excute the technique we call the function compute_error with the inputs of the  SolverErrorRecipe, Solver, coefficient matrix A, and constant vector b. This  function then performs the necessary computations to return a single value indication of the progress of the solver. An example of this for the residual technique that returns the norm- squared of the residual is included below.  ","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function compute_error(\n        error::FullResidualRecipe, \n        solver::KaczmarzRecipe, \n        A::AbstractMatrix, \n        b::AbstractVector\n    )::Float64\n    copyto!(error.residual, b)\n    mul!(error.residual, A, solver.solution_vec, -1.0, 1.0)\n    return dot(error.residual, error.residual)\nend","category":"page"},{"location":"dev/design/#SubSolvers","page":"Design of Library","title":"SubSolvers","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Although, randomized solvers are used to solve a larger linear system. They typically rely on using compressors to generate a compressed linear system that can be easily solved  using standard techniques. The specifics of the 'standard' techniques is typically not  specified. For instance, if the compressed system is a least squares problem one could solve this system with a QR algorithm or LSQR and potentially get vastly different performance results. To allow the user to experiment with different techniques for solving the  compressed linear system, we introduce the SubSolver data structures.","category":"page"},{"location":"dev/design/#SubSolver","page":"Design of Library","title":"SubSolver","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a data structure that allows the user to specify how they wish to solve the compressed linear systems generated in the solving process. When the solver type is a direct method it is possible for there to be no user inputs in this data structure. For iterative methods there could be extensive user-controlled parameters included in this structure. For  example, for a LSQR SubSolver the user could input the maximum of iterations, a  preconditioner type, or stopping thresholds. We have included an example of the SubSolver structure for the LQSolver, which is an approach for solving undetermined linear systems  and does not have any user-controlled parameters associated with it. It is important to note  that constructors for these techniques should have keyword inputs with predefined defaults.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"struct LQSolver <: SubSolver\n\nend","category":"page"},{"location":"dev/design/#SubSolverRecipe","page":"Design of Library","title":"SubSolverRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a data structure that contains the preallocated memory necessary for solving the  linear system. ","category":"page"},{"location":"dev/design/#complete_solver","page":"Design of Library","title":"complete_solver","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a function that takes a SubSolver and the linear system as input and uses these  inputs to output a SubSolverRecipe.","category":"page"},{"location":"dev/design/#update*sub*solver","page":"Design of Library","title":"updatesubsolver","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a function that updates the preallocated memory in the SubSolverRecipe with  the relevant information for the new compressed linear system. ","category":"page"},{"location":"dev/design/#ldiv!","page":"Design of Library","title":"ldiv!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A function that uses the SubSolverRecipe to solve the compressed linear system.","category":"page"},{"location":"dev/design/#Solvers-2","page":"Design of Library","title":"Solvers","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"With an understanding of all of these sub techniques, we can discuss how to use these  methods to implement a Solver technique. The first data structure required for a solver is  the Solver structure.","category":"page"},{"location":"dev/design/#Solver","page":"Design of Library","title":"Solver","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The Solver data structure is a structure where the user can input values of user-controlled  parameters specific to a particular type of solver. This typically involves the user inputting the structures associated with their desired Compressor, Logger, Error, and  SubSolver, as well as any parameters like step-sizes associated with the particular  randomized solver they are using. As an example, we have included the Solver structure  associated with the Kaczmarz solver. It is important to note that constructors for these techniques should have keyword inputs with predefined defaults.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct Kaczmarz <: Solver \n    alpha::Float64\n    S::Compressor\n    log::Logger\n    error::SolverError\n    sub_solver::SubSolver\nend","category":"page"},{"location":"dev/design/#SolverRecipe","page":"Design of Library","title":"SolverRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The SolverRecipe will contain all the preallocated memory associate with the solver, the  solver specific user-controlled parameters, and all recipes associated with the  sub-techniques included in the Solver structure. We have included an example for the  KaczmarzRecipe below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct KaczmarzRecipe{T<:Number, \n                              V<:AbstractVector,\n                              M<:AbstractMatrix, \n                              VV<:SubArray,\n                              MV<:SubArray,\n                              C<:CompressorRecipe, \n                              L<:LoggerRecipe,\n                              E<:SolverErrorRecipe, \n                              B<:SubSolverRecipe\n                             } <: SolverRecipe\n    S::C\n    log::L\n    error::E\n    sub_solver::B\n    alpha::Float64\n    compressed_mat::M\n    compressed_vec::V\n    solution_vec::V\n    update_vec::V\n    mat_view::MV\n    vec_view::VV\nend","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The first four fields are associated with the sub-techniques for the solver. The alpha  field is a user defined value and the remaining fields are preallocated space for storing the result of the compression and the solution vector.","category":"page"},{"location":"dev/design/#complete_solver-2","page":"Design of Library","title":"complete_solver","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The complete_solver function performs the necessary computations and allocations to change a Solver structure into a SolverRecipe. In the example code below for a Kaczmarz solver these computations include running complete_[technique] for the compression, logging,  error, and sub solver techniques, as well as allocating memory for storing the compressed  matrix and compressed vector, the solution vector, and update vector. The views  allocated by this function should be replicated in other multi-compression solver structures  to allow for varying sizes of the compression matrix.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_solver(\n        solver::Kaczmarz, \n        x::AbstractVector, \n        A::AbstractMatrix, \n        b::AbstractVector\n    )\n    # Dimension checking will be performed in the complete_compressor\n    compressor = complete_compressor(solver.S, A, b)\n    logger = complete_logger(solver.log, A, b)\n    error = complete_error(solver.error, A, b) \n    # Check that required fields are in the types\n    @assert isdefined(error, :residual) \"ErrorRecipe $(typeof(error)) does not contain the\\ \nfield 'residual' and is not valid for a kaczmarz solver.\"\n    @assert isdefined(logger, :converged) \"LoggerRecipe $(typeof(logger)) does not contain\\\n the field 'converged' and is not valid for a kaczmarz solver.\"\n    # Assuming that max_it is defined in the logger\n    alpha::Float64 = solver.alpha \n    # We assume the user is using compressors to only decrease dimension\n    n_rows::Int64 = compressor.n_rows\n    n_cols::Int64 = compressor.n_cols\n    sample_size = n_rows\n    initial_size = n_cols\n    rows_a, cols_a = size(A)\n    # Allocate the information in the buffer using the types of A and b\n    compressed_mat = typeof(A)(undef, sample_size, cols_a)\n    compressed_vec = typeof(b)(undef, sample_size) \n    # Since sub_solver is applied to compressed matrices use here\n    sub_solver = complete_sub_solver(solver.sub_solver, compressed_mat, compressed_vec)\n    mat_view = view(compressed_mat, 1:sample_size, :)\n    vec_view = view(compressed_vec, 1:sample_size)\n    solution_vec = x\n    update_vec = typeof(x)(undef, cols_a)\n    return KaczmarzRecipe{eltype(A), \n                          typeof(b), \n                          typeof(A), \n                          typeof(vec_view),\n                          typeof(mat_view),\n                          typeof(compressor),\n                          typeof(logger),\n                          typeof(error),\n                          typeof(sub_solver)\n                         }(compressor, \n                           logger, \n                           error,\n                           sub_solver,\n                           alpha,\n                           compressed_mat,\n                           compressed_vec,\n                           solution_vec,\n                           update_vec,\n                           mat_view,\n                           vec_view\n                          )\nend","category":"page"},{"location":"dev/design/#rsolve!","page":"Design of Library","title":"rsolve!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Every implementation of a Solver technique should include a rsolve! function that performs in-place updates to a solution vector and SolverRecipe. An example of such an  implementation for a Kaczmarz solver is included below. To the greatest extent possible the implementation should be written in a way that avoids new memory allocations. This means making use in-place update functions like mul! or ldiv! rather than * or \\.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function rsolve!(\n        solver::KaczmarzRecipe, \n        x::AbstractVector, \n        A::AbstractMatrix, \n        b::AbstractVector\n    )\n    solver.solution_vec = x\n    err = 0.0\n    for i in 1:solver.log.max_it\n        err = compute_error(solver.error, solver, A, b)\n        # Update log adds value of err to log and checks stopping\n        update_logger!(solver.log, err, i)\n        if solver.log.converged\n            return solver.solution_vec, solver.log\n        end\n\n        # generate a new version of the compression matrix\n        update_compressor!(solver.S, A, b, x)\n        # based on size of new compressor update views of matrix\n        # this should not result in new allocations\n        rows_s, cols_s =  size(solver.S)\n        solver.mat_view = view(solver.compressed_mat, 1:rows_s, :)\n        solver.vec_view = view(solver.compressed_vec, 1:rows_s)\n        # compress the matrix and constant vector\n        mul!(solver.mat_view, solver.S, A)\n        mul!(solver.vec_view, solver.S, b)\n        # Compute the block residual\n        mul!(solver.vec_view, solver.mat_view, solver.solution_vec, -1.0, 1.0)\n        # sub-solver needs to designed for new compressed matrix\n        update_sub_solver!(solver.sub_solver, solver.mat_view)\n        # use sub-solver to find update the solution\n        sub_solve!(solver.update_vec, solver.sub_solver, solver.vec_view)\n        # Using over-relaxation parameter, alpha, to update solution\n        solver.solution_vec .+= solver.alpha .* solver.update_vec \n    end\n\n    return solver.solution_vec, solver.log\nend","category":"page"},{"location":"dev/design/#Approximators","page":"Design of Library","title":"Approximators","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Aside from solving linear systems, Randomized Linear Algebra has also been proven to be extremely useful for generating low rank approximations to linear systems. These low-rank  approximations can then be used to solve linear systems or perform more efficient matrix-matrix multiplications. The main types of low rank approximation methods implemented in this version of the library are random range finder techniques like random SVD, CUR  type methods, and Nystrom Methods. Low rank approximations can be formed simply by calling  the rapproximate function. Once a Low-rank approximation has been formed it can then be  applied either as a preconditioner by calling the ldiv! function or multiplied by calling  the mul! function. Each of the low rank approximation technique requires the implementation of the following data structures and functions.","category":"page"},{"location":"dev/design/#Approximator","page":"Design of Library","title":"Approximator","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a data structure that contains the user defined parameters for an approximator. An  example of this structure for the RangeFinder decomposition is included below. In the case  of the randomized range finder the only real user controlled parameter is the sketch size, which is controlled by the Compressor. It should be noted that constructors for these  structures should be based around keyword inputs with preset defaults. ","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct RangeFinder <: Approximator\n    S::Compressor\n    error::ErrorMethod\nend","category":"page"},{"location":"dev/design/#ApproximatorRecipe","page":"Design of Library","title":"ApproximatorRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This a data structure that contains preallocated memory and the user-controlled parameters  for a specific approximation method. An example of this data structure for a RangeFinder  decomposition is included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct RangeFinderRecipe <: ApproximatorRecipe\n    S::CompressorRecipe\n    error::ErrorMethodRecipe\n    compressed_mat::AbstractMatrix\n    approx_range::AbstractMatrix\nend","category":"page"},{"location":"dev/design/#complete_approximator","page":"Design of Library","title":"complete_approximator","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The complete_approximator function takes the matrix A and the  Approximator data structure to output an ApproximatorRecipe with properly allocated  storage for the low-rank approximation. An example of this function for the  RangeFinderRecipe is included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_approximator(approx::RangeFinder, A::AbstractMatrix)\n    S = complete_compressor(approx.S, A)\n    err = complete_error(approx.error, A)\n    s_rows, s_cols = size(S)\n    a_rows, a_cols = size(A)\n    compressed_mat = Matrix{eltype(A)}(undef, a_rows, s_cols)\n    approx_range = Matrix{eltype(A)}(undef, a_rows, s_cols) \n    return RangeFinderRecipe(S, err, compressed_mat, approx_range)\nend","category":"page"},{"location":"dev/design/#rapproximate!","page":"Design of Library","title":"rapproximate!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A function that returns an ApproximatorRecipe and approximation error value for a particular approximation method. The returned ApproximatorRecipe can then be used for  matrix multiplication or preconditioning through the use of the mul! and ldiv! functions respectively. An example of this function for the RangeFinderRecipe is included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function r_approximate!(\n    approximator::RangeFinderRecipe\n    A::AbstractMatrix\n)\n    m, n = size(A)\n    update_compressor!(aproximator.S)\n    # compuress the matrix\n    mul!(compressed_mat, A, aproximator.S)\n    # Array is required to compute the skinny qr\n    approximator.approx_range .= Array(qr(compressed_mat).Q)\n    err = compute_error(aproximator.error, A)\n    return approximator, error\nend","category":"page"},{"location":"dev/design/#ldiv!-2","page":"Design of Library","title":"ldiv!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A function that solves the system Mx = b for x where M is a low rank approximation  matrix. This is useful for preconditioning linear systems. When there is no obvious way to use the low rank approximation to solve this system the implementation will be the same as the implementation for mul!.","category":"page"},{"location":"dev/design/#mul!-2","page":"Design of Library","title":"mul!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A function that multiplies a low rank approximation with a matrix. This should be  implemented as the five input mul! function. For these functions we follow the conventions  laid out in the LinearAlgebra library where there are five inputs (C, A, S, alpha, beta) and  it outputs C = beta * C + alpha * A * S.","category":"page"},{"location":"dev/design/#Approximation-Error","page":"Design of Library","title":"Approximation Error","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"For the Approximators an important sub-techniques are those that verify the accuracy of a particular approximation. These methods can be exact, as in the case of computing A - QQA_F, where Q is a row-space approximator or approximate such as the  AS - QQAS_F where S is a Gaussian matrix with 10 column vectors.","category":"page"},{"location":"dev/design/#ApproximatorError","page":"Design of Library","title":"ApproximatorError","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The ApproximatorError data structure is a data structure that takes the user controlled  parameters for a method that computes the approximation error, e.g A - QQA for a  particular approximation method. In cases where this error is an exact approximation no  user-controlled parameters may be needed and the ApproximatorError can be implemented as  an empty data structure. If user-controlled parameters are necessary then constructors should be implemented that take in keyword arguments with defaults. We have included an  example data structure for a method that computes the projected error, A - QQA, below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct ProjectedError <: ApproximatorError\n\nend\n","category":"page"},{"location":"dev/design/#ApproximatorErrorRecipe","page":"Design of Library","title":"ApproximatorErrorRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"An ApproximatorErrorRecipe contains the user-controlled parameters and preallocated memory  for a method that computes the approximation error, e.g A - QQ'A for a particular  approximation method.  ","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct ProjectedErrorRecipe{T, M{T}} <: ApproximatorErrorRecipe \n    where M <: AbstractMatrix\n    error::Float64\n    large_buff_mat::M\n    small_buffer_mat::M\nend","category":"page"},{"location":"dev/design/#complete_error-2","page":"Design of Library","title":"complete_error","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The complete_error function takes the information from a ApproximatorError and an AbstractMatrix to create an ApproximatorErrorRecipe. An example for the  ProjectedError structure is included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_error(error::ProjectedError, S::CompressorRecipe, A::AbstractMatrix)\n    row_s, col_s = size(S)\n    row_a, col_a = size(A)\n    T = eltype(A)\n    M = Matrix{T}\n    small_buffer_mat = M(undef, col_s, col_a) \n    large_buffer_mat = M(undef, row, col_a) \n    return ProjectedErrorRecipe{T, M}(0.0, large_buffer_mat, small_buffer_mat)\nend","category":"page"},{"location":"dev/design/#compute_error-2","page":"Design of Library","title":"compute_error","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A function that computes the error of a particular approximation method with respect to the  matrix A for a particular approximation technique. An example for ProjectedError is  included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function compute_error(\n        error::ProjectedErrorRecipe,\n        approximator::RandRangeFinderRecipe,\n        A::AbstractMatrix\n    )\n    mul!(error.small_buffer_mat, approximator.row_space', A)\n    mul!(error.large_buffer_mat, approximator.row_space, error.small_buffer_mat)\n    error.large_buffer_mat .-= A\n    error.error = norm(error.large_buffer_mat)\n    return error.error\nend","category":"page"},{"location":"dev/style_guide/#Style-Guide","page":"Style Guide","title":"Style Guide","text":"","category":"section"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"Pages=[\"styleguide.md\"]","category":"page"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"When writing code for RLinearAlgebra.jl we expect the code to be written in accordance  with the BLUE style.","category":"page"},{"location":"dev/style_guide/#Documentation","page":"Style Guide","title":"Documentation","text":"","category":"section"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"This section describes the writing style that should be used when writing documentation for  RLinearAlgebra.jl. Many of these ideas for these suggestions come from JUMP.  Overall when documenting the code one should follow these recommendations:     - Be concise     - Prefer lists over long sentences     - Use numbers when describing an ordered set of ideas     - Use bullets when these is no specific order","category":"page"},{"location":"dev/style_guide/#Docstrings","page":"Style Guide","title":"Docstrings","text":"","category":"section"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"- Every new **function** and **data structure** needs to have a docstring\n- Use properly punctuated complete sentences","category":"page"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"Below, we provide an example of a function docstring and a data structure docstring.","category":"page"},{"location":"dev/style_guide/#Function-Docstring","page":"Style Guide","title":"Function Docstring","text":"","category":"section"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    myFunction(args; kwargs...)\n    \nA couple of sentences describing the function. These sentences should describe what inputs \nare required and what is output by the function.\n\n### Arguments\n- `arg1`, description of arg 1\n\n### Outputs\nThe result of calling the function. This should be either the data structure that is \nmodified or what is returned.\n\nA citation from the package DocumenterCitations.\n\"\"\"\n","category":"page"},{"location":"dev/style_guide/#Data-Structure-Docstring","page":"Style Guide","title":"Data Structure Docstring","text":"","category":"section"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    YourStructure <: YourStructuresSuperType\n\nA brief sentence describing the purpose of the structure.\n\nA citation in MLA format if the function comes from another author's work.\n\n### Fields\n- `S::FieldType`, brief description of field purpose\n\nInclude a sentence or two describing how the constructors work. Please be sure to include \nthe default values of the constructor.\n\"\"\"\n","category":"page"},{"location":"api/sub_solvers/#SubSolvers","page":"SubSolvers","title":"SubSolvers","text":"","category":"section"},{"location":"api/sub_solvers/","page":"SubSolvers","title":"SubSolvers","text":"Pages = [\"sub_solvers.md\"]","category":"page"},{"location":"api/sub_solvers/#Abstract-Types","page":"SubSolvers","title":"Abstract Types","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.SubSolver","page":"SubSolvers","title":"RLinearAlgebra.SubSolver","text":"SubSolver\n\nAn abstract supertype for structures specifying solution methods for a linear system or least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.SubSolverRecipe","page":"SubSolvers","title":"RLinearAlgebra.SubSolverRecipe","text":"SubSolverRecipe\n\nAn abstract supertype for structures with pre-allocated memory for methods that solve a linear system or least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#SubSolver-Structures","page":"SubSolvers","title":"SubSolver Structures","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.LQSolver","page":"SubSolvers","title":"RLinearAlgebra.LQSolver","text":"LQSolver <: SubSolver\n\nA type containing information relevant to solving the linear subsystems created by the      Solver routines with the LQ factorization. As there are no user controlled parameters,      if the user wishes to use this method they can simply specify LQSolver().\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.LQSolverRecipe","page":"SubSolvers","title":"RLinearAlgebra.LQSolverRecipe","text":"LQSolverRecipe <: SubSolverRecipe{M<:AbstractArray}\n\nA mutable type containing informtation relevant to solving the linear subsytems created by      the Solver routines with the LQ factorization.\n\nFields\n\nA::M, The matrix in the linear system that will be solved with the LQ solver.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.QRSolver","page":"SubSolvers","title":"RLinearAlgebra.QRSolver","text":"QRSolver <: SubSolver\n\nA type containing information relevant to solving the linear subsystems created by the      Solver routines with the QR factorization. As there are no user controlled parameters,      if the user wishes to use this method they can simply specify QRSolver().\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.QRSolverRecipe","page":"SubSolvers","title":"RLinearAlgebra.QRSolverRecipe","text":"QRSolverRecipe{M<:AbstractArray} <: SubSolverRecipe\n\nA mutable type containing information relevant to solving the linear subsystems created by      the Solver routines with the QR factorization.\n\nFields\n\nA::M, The matrix in the linear system that will be solved with the QR solver.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#Exported-Functions","page":"SubSolvers","title":"Exported Functions","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.complete_sub_solver","page":"SubSolvers","title":"RLinearAlgebra.complete_sub_solver","text":"complete_sub_solver(solver::SubSolver, A::AbstractArray)\n\nA function that generates a SubSolverRecipe given the      arguments.\n\nArguments\n\nsolver::SubSolver, a user-specified sub-solving method.\nA::AbstractArray, a coefficient matrix or vector. \n\nReturns\n\nA SubSolverRecipe object.\n\n\n\n\n\ncomplete_sub_solver(solver::SubSolver, A::AbstractArray, b::AbstractArray)\n\nA function that generates a SubSolverRecipe given the      arguments.\n\nArguments\n\nsolver::SubSolver, a user-specified sub-solving method.\nA::AbstractArray, a coefficient matrix or vector. \nb::AbstractArray, a constant matrix or vector. \n\nReturns\n\nA SubSolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/sub_solvers/#RLinearAlgebra.update_sub_solver!","page":"SubSolvers","title":"RLinearAlgebra.update_sub_solver!","text":"update_sub_solver!(solver::SubSolverRecipe, A::AbstractArray)\n\nA function that updates the SubSolver in place given      arguments.\n\nArguments\n\nsolver::SubSolverRecipe, a fully initialized realization for a   linear sub-solver.\nA::AbstractArray, a coefficient matrix or vector. \n\nReturns\n\nModifies the SubSolverRecipe in place given the arguments.and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#Compressors","page":"Compressors Overview","title":"Compressors","text":"","category":"section"},{"location":"api/compressors/","page":"Compressors Overview","title":"Compressors Overview","text":"Pages = [\"compressors.md\"]","category":"page"},{"location":"api/compressors/#Abstract-Types","page":"Compressors Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.Compressor","page":"Compressors Overview","title":"RLinearAlgebra.Compressor","text":"Compressor\n\nAn abstract supertype for structures that contain user-controlled parameters corresponding to techniques that compress a matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CompressorRecipe","page":"Compressors Overview","title":"RLinearAlgebra.CompressorRecipe","text":"CompressorRecipe\n\nAn abstract supertype for structures that contain both the user-controlled parameters in the Compressor and the memory allocations necessary for applying the compression technique to a particular set of matrices and vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CompressorAdjoint","page":"Compressors Overview","title":"RLinearAlgebra.CompressorAdjoint","text":"CompressorAdjoint{S<:CompressorRecipe}\n\nA structure for the adjoint of a compression recipe.\n\nFields\n\nParent::CompressorRecipe, the CompressorRecipe the adjoint is being applied to.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Cardinality","page":"Compressors Overview","title":"RLinearAlgebra.Cardinality","text":"Cardinality\n\nAn abstract type for types that specify whether a compressor will be applied from the left or the right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Left","page":"Compressors Overview","title":"RLinearAlgebra.Left","text":"Left <: Cardinality\n\nA struct indicating matrix multiplication from the left.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Right","page":"Compressors Overview","title":"RLinearAlgebra.Right","text":"Right <: Cardinality\n\nA struct indicating matrix multiplication from the right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Undef","page":"Compressors Overview","title":"RLinearAlgebra.Undef","text":"Undef <: Cardinality\n\nA struct indicating matrix multiplication is undefined.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#Compressor-Structures","page":"Compressors Overview","title":"Compressor Structures","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.CountSketch","page":"Compressors Overview","title":"RLinearAlgebra.CountSketch","text":"CountSketch <: Compressor\n\nAn implementation of the count sketch compression method. See additional details in  [2] Section 2.1, in which the CountSketch matrix is equivalently defined as sparse  embedding matrix.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from  the left (i.e., we reduce the number of rows), then we construct a Count Sketch matrix S with  dimension s times m, where s is the user-specified compression dimension. Each column of  S is generated independently by the following steps:\n\nRandomly select an integer between 1 and s to determine the row position of the nonzero entry.\nAssign this entry a value of either +1 or -1, chosen uniformly at random.\nSet all the other entries in the column to zero.\n\nAs a result, each column of S has exactly one nonzero element.\n\nIf A is compressed from the right, then we construct a Count Sketch matrix S with dimension  n times s, where s is the user-specified compression dimension. Each row of S is  generated independently using the following steps:\n\nRandomly select an integer between 1 and s to determine the column position of the nonzero entry.\nAssign this entry a value of either +1 or -1, chosen uniformly at random.\nSet all other entries in the row to zero.\n\nIn this case, each row of S has exactly one nonzero entry.  The compressed matrix is then formed by multiplying S A (for left compression) or A S (for right compression).\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nCountSketch(;carinality=Left(), compression_dim=2, type=Float64)\n\nKeywords\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\ntype::Type{<:Number}, the type of the elements in the compressor. By default is set   to Float64.\n\nReturns\n\nA CountSketch object.\n\nThrows\n\nArgumentError if compression_dim is non-positive\nArgumentError if Undef() is taken as the input for cardinality\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CountSketchRecipe","page":"Compressors Overview","title":"RLinearAlgebra.CountSketchRecipe","text":"CountSketchRecipe <: CompressorRecipe\n\nThe recipe containing all allocations and information for the CountSketch compressor.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The    value is either Left() or Right().\ncompression_dim::Int64, the target compression dimension.\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64`, the number of columns of the compression matrix.\nmat::SparseMatrixCSC, the compression matrix stored in a sparse form.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.FJLT","page":"Compressors Overview","title":"RLinearAlgebra.FJLT","text":"FJLT <: Compressor\n\nAn implementation of the Fast Johnson-Lindenstrauss Transform method. This technique applies a sparse matrix, a Walsh-Hadamard transform, and a diagonal sign matrix to produce a sketch.  See [3] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Here S=KHD where \n\nK is a sparse matrix with  with dimension s times m, where each entry has    probability q of being non-zero, and, if it is non-zero, then its value is    drawn from an independent normal distribution with mean 0 and variance 1q;\nH is a Hadamard matrix of dimension m times m, which is implicitly applied    through the fast Walsh-Hadamard transform;\nD of is a diagonal matrix of dimension m times m with entries given by    independent Rademacher variables.\n\nIf we want to compress A from the right (i.e., we reduce the number of columns), then  we would apply S=DHK from the right where the dimensions of the matrices are adjusted  to reflect the number of columns in A.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nblock_size::Int64, the number of vectors in the padding matrix.\nsparsity::Int64, the desired sparsity of the matrix K.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nFJLT(;\n    cardinality=Left(),\n    compression_dim::Int64=2,\n    block_size::Int64=10,\n    sparsity::Float64=0.0,\n    type::Type{N}=Float64,\n) where {N<:Number}\n\nKeywords\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description. By default this is set to 2.\nblock_size::Int64, the number of vectors in the padding matrix.\nsparsity::Int64, the desired sparsity of the matrix K, by default sparsity will be    set to be minleft(14 log(n)^2  m 1right), see [3].\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA FJLT object.\n\nThrows\n\nArgumentError if compression_dim is non-positive, if sparsity is not in 01,   or if block_size is non-positive.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.FJLTRecipe","page":"Compressors Overview","title":"RLinearAlgebra.FJLTRecipe","text":"FJLTRecipe{C<:Cardinality, S<:SparseMatrixCSC, M<:AbstractMatrix} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the FJLT compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are Left() or Right().\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nsparsity:Float64, the sparsity, q, of the sparse component, K.\nscale::Float64, the factor to ensure the isopmorphism of the sketch.\nop::SparseMatrixCSC, the sparse matrix K in the mathematical description.\nsigns::BitVector, the vector of signs where 0 indicates negative one and 1 indicates   positive one. \npadding::AbstractMatrix, the matrix containing the padding for the matrix being sketched.\n\nConstructor\n\nFJLTRecipe(\n    compression_dim::Int64, \n    block_size::Int64,\n    cardinality::C where {C<:Cardinality},\n    sparsity::Float64,\n    A::AbstractMatrix, \n    type::Type{<:Number}\n)\n\nKeywords\n\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\nblock_size::Int64, the number of columns in the padding memory buffer.\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\nsparsity::Vector{Number}, the expected sparsity of the Sparse operator matrix.\nA::AbstractMatrix, the matrix being compressed.\ntype::Type{<:Number}, the type of elements in the compressor.\n\ninfo: Info\nIf the sparsity parameter is set to 0.0, then the sparsity will be set to  minleft(14 log(n)^2  m 1right), see [3].\n\nReturns\n\nA FJLTRecipe object.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Gaussian","page":"Compressors Overview","title":"RLinearAlgebra.Gaussian","text":"Gaussian <: Compressor\n\nA specification for a Gaussian compressor.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress.\n\nIf we want to compress A from the left (i.e., we reduce the number of rows), then we create a Gaussian sketch matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Each entry of S is generated independently following N(0, 1/s), namely, a Gaussian distribution with mean being zero and variance being 1 divided by the compression dimension.\n\nIf A is compressed from the right, then we create a Gaussian sketch matrix, S, with dimension n times s, where s is the compression dimension that is supplied by the user. Each entry of S is generated independently following N(0, 1/s), namely, a Gaussian distribution with mean being zero and variance being 1 divided by the compression dimension.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in    the mathematical description.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nGaussian(;cardinality=Left(), compression_dim=2, type=Float64)\n\nArguments\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in    the mathemtical description. By default this is set to 2.\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA Gaussian object.\n\nThrows\n\nArgumentError if compression_dim is non-positive\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.GaussianRecipe","page":"Compressors Overview","title":"RLinearAlgebra.GaussianRecipe","text":"GaussianRecipe <: CompressorRecipe\n\nThe recipe containing all allocations and information for the Gaussian compressor.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The\n\nvalue is either Left() or Right().\n\ncompression_dim::Int64, the target compression dimension.\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nscale::Number, the standard deviation of Gaussian distribution during the \n\ncompression matrix generation.\n\nop::Matrix{Float64}, the Gaussian compression matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Sampling","page":"Compressors Overview","title":"RLinearAlgebra.Sampling","text":"Sampling <: Compressor\n\nThis method subsets the rows  or columns of a matrix according to a user-supplied distribution. The size of the  subset is also provided by the user.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress.\n\nIf we want to compress A from the left (i.e., we reduce the number of rows), then we create an index set to contain all the indices of selected rows. The indices are  chosen by sampling over all the rows with the user-specified distribution in the  distribution field.\n\nIf A is compressed from the right (i.e., we reduce the number of columns), then we create an index set to contain all the indices of selected columns. The indices  are chosen by sampling over all the columns with the user-specified distribution  in the distribution field.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension.\ndistribution::Distribution, the distribution being used to assign probability weights   on the indices.\n\nConstructor\n\nSampling(;cardinality = Left(), compression_dim = 2, distribution)\n\nArguments\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. By default this is set to 2.\ndistribution::Distribution, the distribution being used to assign probability weights   on the indices. By default this is set as Uniform distribution.\n\nReturns\n\nA Sampling object.\n\nThrows\n\nArgumentError if compression_dim is non-positive\nArgumentError if Undef() is taken as the input for cardinality\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SamplingRecipe","page":"Compressors Overview","title":"RLinearAlgebra.SamplingRecipe","text":"SamplingRecipe{C<:Cardinality} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the sampling compressor. \n\nFields\n\ncardinality::Cardinality, the cardinality of the compressor. The   value is either Left() or Right().\ncompression_dim::Int64, the target compression dimension.\nn_rows::Int64, number of rows of compression matrix.\nn_cols::Int64, number of columns of compression matrix.\ndistribution_recipe::DistributionRecipe, the user-specified distribution recipe.\nidx::Vector{Int64}, the index set that contains all the chosen indices.\nidx_v::SubArray, the view of the idx.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SparseSign","page":"Compressors Overview","title":"RLinearAlgebra.SparseSign","text":"SparseSign <: Compressor\n\nAn implementation of the sparse sign compression method. This method forms a sparse matrix with a fixed number of non-zeros per row or column depending on the direction that the compressor is being applied. See Section 9.2 of [4] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a sparse sign matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. In this case, each column of S is generated independently by the following steps:\n\nRandomly choose nnz components of the the s components of the column. Note, nnz  is supplied by the user.\nFor each selected component, randomly set it either to -1sqrttextnnz or  1sqrttextnnz with equal probability.\nSet the remaining components of the column to zero.\n\nIf A is compressed from the right, then we create a sparse sign matrix, S, with dimension n times s, where s is the compression dimension that is supplied by the user. In this case, each row of S is generated independently by the following steps:\n\nRandomly choose nnz components of the s components of the row. Note, nnz  is supplied by the user.\nFor each selected component, randomly set it either to -1sqrttextnnz or  1sqrttextnnz with equal probability.\nSet the remaining components of the row to zero.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nnnz::Int64, the target number of nonzeros for each column or row of the spares sign   matrix.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nSparseSign(;carinality=Left(), compression_dim=2, nnz::Int64=8, type=Float64)\n\nKeywords\n\ncarinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\nnnz::Int64, the number of non-zeros per row/column in the sampling matrix. By default   this is set to min(compressiond_dim, 8).\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA SparseSign object.\n\nThrows\n\nArgumentError if compression_dim is non-positive, if nnz is exceeds   compression_dim, or if nnz is non-positive.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SparseSignRecipe","page":"Compressors Overview","title":"RLinearAlgebra.SparseSignRecipe","text":"SparseSignRecipe{C<:Cardinality} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the SparseSign compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to\n\nbe applied to a target matrix or operator. Values allowed are Left() or Right().\n\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nnnz::Int64, the number of non-zero entries in each row if cardinality==Left or the\n\nnumber of non-zero entries each column if cardinality==Right.\n\nscale::Vector{Number}, the set of values of the non-zero entries of the Spares Sign\n\ncompression matrix.\n\nop::SparseMatrixCSC, the Spares Sign compression matrix.\n\nConstructors\n\nSparseSignRecipe(\n    cardinality::C where C<:Cardinality,\n    compression_dim::Int64, \n    A::AbstractMatrix, \n    nnz::Int64, \n    type::Type{<:Number}\n)\n\nAn external constructor of SparseSignRecipe that is dispatched based on the  value of cardinality. See SparseSign for additional details. \n\nArguments\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The    value is either Left() or Right()\ncompression_dim::Int64, the target compression dimension.\nA::AbstractMatrix, a target matrix for compression. \nnnz::Int64, the number of nonzeros in the Sparse Sign compression matrix.\ntype::Type{<:Number}, the data type for the entries of the compression matrix.\n\nReturns\n\nA SparseSignRecipe object.\n\nwarning: Use `complete_compressor`\nWhile an external constructor is provided, it is mainly for internal use. To ensure cross library compatibility please use complete_compressor for forming the SparseSignRecipe.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SRHT","page":"Compressors Overview","title":"RLinearAlgebra.SRHT","text":"SRHT <: Compressor\n\nAn implementation of the Subsampled Randomized Hadamard Transform (SRHT) method. This  technique applies a subsampling matrix, a Walsh-Hadamard transform, and a diagonal sign  matrix to produce a sketch. See [5] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Here S=KHD where \n\nK is a matrix with  with dimension s times m, where the rows are made up of a    random sample of the rows of a m times m identity matrix.\nH is a Hadamard matrix of dimension m times m, which is implicitly applied    through the fast Walsh-Hadamard transform;\nD of is a diagonal matrix of dimension m times m with entries given by    independent Rademacher variables.\n\nIf we want to compress A from the right (i.e., we reduce the number of columns), then  we would apply S=DHK from the right where the dimensions of the matrices are adjusted  to reflect the number of columns in A.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nblock_size::Int64, the number of vectors in the padding matrix.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nSRHT(;\n    cardinality = Left(),\n    compression_dim::Int64=2,\n    block_size::Int64=10,\n    type::Type{N}=Float64\n) where {N <: Number}\n\nKeywords\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description. By default this is set to 2.\nblock_size::Int64, the number of vectors in the padding matrix.\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA SRHT object.\n\nThrows\n\nArgumentError if compression_dim is non-positive or if block_size is non-positive.\nArgumentError if Cardinality is not either Left or Right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SRHTRecipe","page":"Compressors Overview","title":"RLinearAlgebra.SRHTRecipe","text":"SRHTRecipe{C<:Cardinality, M<:AbstractMatrix} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the SRHT compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are Left() or Right().\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nscale::Float64, the factor to ensure the isopmorphism of the sketch.\nop::Vector{Int64}, the vector of indices to be subsampled.\nsigns::BitVector, the vector of signs where 0 indicates negative one and 1 indicates   positive one. \npadding::AbstractMatrix, the matrix containing the padding for the matrix being    sketched.\n\nConstructor\n\nSRHTRecipe(\n    compression_dim::Int64,\n    block_size::Int64,\n    cardinality::Left,\n    A::AbstractMatrix,\n    type::Type{<:Number}\n)\n\nKeywords\n\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nblock_size::Int64, the number of vectors in the padding matrix.\ncardinality::Left, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\nA::AbstractMatrix, the matrix being compressed.\ntype::Type{<:Number}, the type of elements in the compressor.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#Exported-Functions","page":"Compressors Overview","title":"Exported  Functions","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.complete_compressor","page":"Compressors Overview","title":"RLinearAlgebra.complete_compressor","text":"complete_compressor(compressor::Compressor, A::AbstractMatrix)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nA::AbstractMatrix, a target matrix for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\ncomplete_compressor(compressor::Compressor, A::AbstractMatrix, b::AbstractVector)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\ncomplete_compressor(\n    compressor::Compressor, \n    x::AbstractVector\n    A::AbstractMatrix, \n    b::AbstractVector, \n)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nx::AbstractVector, a vector that ususally represents a current iterate    typically used in a solver.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.update_compressor!","page":"Compressors Overview","title":"RLinearAlgebra.update_compressor!","text":"update_compressor!(S::CompressorRecipe)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(S::CompressorRecipe, A::AbstractMatrix)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nA::AbstractMatrix, a target matrix for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(S::CompressorRecipe, A::AbstractMatrix, b::AbstractVector)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(\n    S::CompressorRecipe, \n    A::AbstractMatrix, \n    b::AbstractVector,\n    x::AbstractMatrix\n)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nx::AbstractVector, a vector that ususally represents a current iterate    typically used in a solver.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#Internal-Functions","page":"Compressors Overview","title":"Internal Functions","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.left_mul_dimcheck","page":"Compressors Overview","title":"RLinearAlgebra.left_mul_dimcheck","text":"left_mul_dimcheck(C::AbstractMatrix, S::CompressorRecipe, A::AbstractMatrix)\n\nA function that checks the compatibility of arguments for      multiplication from the left.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nS::Union{CompressorRecipe, ApproximatorRecipe}, a fully    initialized realization for a compression or approximator method for a    specific AbstractArray or operator.\nA::AbstractArray, a target AbstractArray for compression.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\nleft_mul_dimcheck(C::AbstractMatrix, S::CompressorAdjoint, A::AbstractMatrix)\n\nA function that checks the compatibility of arguments for      multiplication from the left.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nS::Union{CompressorAdjoint, ApproximatorAdjoint}, the    representation of an adjoint of a compression or approximator operator.\nA::AbstractArray, a target AbstractArray for compression.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.right_mul_dimcheck","page":"Compressors Overview","title":"RLinearAlgebra.right_mul_dimcheck","text":"right_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix, S::CompressorRecipe)\n\nA function that checks the compatibility of arguments for      multiplication from the right.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nA::AbstractArray, a target AbstractArray for compression.\nS::Union{CompressorRecipe, ApproximatorRecipe}, a fully    initialized realization for a compression or approximator method for a    specific AbstractArray or operator.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\nright_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix, S::CompressorAdjoint)\n\nA function that checks the compatibility of arguments for      multiplication from the right.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nA::AbstractArray, a target AbstractArray for compression.\nS::Union{CompressorAdjoint, ApproximatorAdjoint}, the    representation of an adjoint of a compression or approximator operator.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.sparse_idx_update!","page":"Compressors Overview","title":"RLinearAlgebra.sparse_idx_update!","text":"sparse_idx_update!(\n    values::Vector{Int64}, \n    max_sample_val::Int64, \n    n_samples::Int64, \n    sample_size::Int64\n)\n\nImplicitly splits values into n_samples components of size sample_size.  On each component, replaces the entries of each component with a random sample  without replacement of size sample_size from the set 1:max_sample_val.\n\nwarn: Warn\nvalues should have length equal to sample_size*n_samples, but this  is not checked. \n\nArguments\n\nvalues::Vector{Int64}, a vector containing samples from 1:max_sample_val.\nmax_sample_val::In64, implicitly supplies the set from which to sample,   1:max_sample_val.\nn_samples::Int64, the number of components that values is implicitly split into. \nsample_size::Int64, the size each component that values is split into.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.fwht!","page":"Compressors Overview","title":"RLinearAlgebra.fwht!","text":"fwht!(x::AbstractVector, signs::BitVector; scaling::Int64 = 1)\n\nPerforms an in-place Fast Walsh Hadamard Transform on the vector x.   signs allows the user to input a boolean vector that flips the signs of the entries  of the vector x before applying the transform. scaling allows the user to scale the  result of the transform. Choosing a scaling of 1/sqrt{size(x)} will result in the FWHT  being an orthogonal transform.\n\nArguments\n\nx::AbstractVector, the vector the FJLT will be applied to.\nsigns::Vector{Bool}, whether the sign of each entry is positive or negative.\n\nKeywords\n\nscaling::Number, how much the vector is scaled, by default this is 1.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#Loggers","page":"Loggers","title":"Loggers","text":"","category":"section"},{"location":"api/loggers/","page":"Loggers","title":"Loggers","text":"Pages = [\"loggers.md\"]","category":"page"},{"location":"api/loggers/#Abstract-Types","page":"Loggers","title":"Abstract Types","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.Logger","page":"Loggers","title":"RLinearAlgebra.Logger","text":"Logger\n\nAn abstract supertype for structures that record the progress of a SolverRecipe applied to a coefficient matrix and constant vector.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#RLinearAlgebra.LoggerRecipe","page":"Loggers","title":"RLinearAlgebra.LoggerRecipe","text":"LoggerRecipe\n\nAn abstract supertype for a structure that contains pre-allocated memory for a method that records the progress of a SolverRecipe.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#Logger-Structures","page":"Loggers","title":"Logger Structures","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.BasicLogger","page":"Loggers","title":"RLinearAlgebra.BasicLogger","text":"BasicLogger <: Logger\n\nThis is a mutable struct that contains the max_it parameter and stores the error metric      in a vector. Checks convergence of the solver based on the log information.\n\nFields\n\nmax_it::Int64, The maximum number of iterations for the solver. If not specified by the  user, it is set to 3 times the number of rows in the matrix.\nthreshold_info::Union{Float64, Tuple}, The parameters used for stopping the algorithm.\ncollection_rate::Int64, the rate that history is gathered. (Note: The last value is   always recorded.)\nstopping_criterion::Function, function that evaluates the stopping criterion.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#RLinearAlgebra.BasicLoggerRecipe","page":"Loggers","title":"RLinearAlgebra.BasicLoggerRecipe","text":"BasicLoggerRecipe <: LoggerRecipe\n\nThis is a mutable struct that contains the max_it parameter and stores the error metric      in a vector. Checks convergence of the solver based on the log information.\n\nFields\n\nmax_it::Int64, The maximum number of iterations for the solver.\nerror::Float64, The current error metric.\nthreshold_info::Union{Float64, Tuple}, The parameters used for stopping the algorithm.\niteration::Int64, the current iteration of the solver.\nrecord_location::Int64, the location in the history vector of the most recent entry.\ncollection_rate::Int64, the rate that history is gathered. (Note: The last value is   always recorded.)\nconverged::Bool, A boolean indicating whether the stopping criterion is satisfied.\nStoppingCriterion::Function, function that evaluates the stopping criterion.\nhist:AbstractVector, vector that contains the history of the error metric.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#Exported-Functions","page":"Loggers","title":"Exported Functions","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.complete_logger","page":"Loggers","title":"RLinearAlgebra.complete_logger","text":"complete_logger(logger::Logger)\n\nA function that generates a LoggerRecipe given the      arguments.\n\nArguments\n\nlogger::Logger, a user-specified logging method.\n\nReturns\n\nA LoggerRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.update_logger!","page":"Loggers","title":"RLinearAlgebra.update_logger!","text":"update_logger!(logger::LoggerRecipe, err::Float64, iteration::Int64)\n\nA function that updates the LoggerRecipe in place given      arguments.\n\nArguments\n\nlogger::LoggerRecipe, a fully initialized realization for a    logging method for a specific linear or least squares solver.\nerr::Real, an error value to be logged. \niteration::Int64, the iteration of the solver. \n\nReturns\n\nPerforms an inplace update to the LoggerRecipe and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.reset_logger!","page":"Loggers","title":"RLinearAlgebra.reset_logger!","text":"reset_logger!(logger::LoggerRecipe)\n\nA function that resets the LoggerRecipe in place.\n\nArguments\n\nlogger::LoggerRecipe, a fully initialized realization for a    logging method for a specific linear or least squares solver.\n\nReturns\n\nPerforms an inplace update to the LoggerRecipe and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.threshold_stop","page":"Loggers","title":"RLinearAlgebra.threshold_stop","text":"threshold_stop(log::BasicLoggerRecipe)\n\nFunction that takes an input threshold and stops when the most recent entry in the history vector is less than the threshold.\n\nArguments\n\nlog::LoggerRecipe, a structure containing the logger information\n\nBool\n\nReturns a Bool indicating if the stopping threshold is satisfied.\n\n\n\n\n\n","category":"function"},{"location":"dev/checklists/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"dev/checklists/","page":"Overview","title":"Overview","text":"The purpose of this page is to offer checklists of tasks, for everyone who help to improve the package. These checklists are organized by method.","category":"page"},{"location":"dev/checklists/#Create-issue-and-use-it!","page":"Overview","title":"Create issue and use it!","text":"","category":"section"},{"location":"dev/checklists/","page":"Overview","title":"Overview","text":"Please add a brief introduction when you create an issue. After the introduction, copy and paste the corresponding checklist.  You can check the  boxes after you finish each steps, to help you contribute smoothly!","category":"page"},{"location":"dev/checklists/","page":"Overview","title":"Overview","text":"For example, If I want to add a moving_average logging method to the package, I will create an issue as follows:","category":"page"},{"location":"dev/checklists/","page":"Overview","title":"Overview","text":"# Introduction\nAdd the moving average method for both full and sketching residual. For more details, please see [the paper](https://arxiv.org/abs/2208.04989).\n# Checklist \n## Implementation\n1. Method's core codes (`src/Solvers/Loggers`):\n    - [ ] Create a file in the directory `src/Solvers/Loggers`. For example, `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `Logger` struct with `max_it`, `collection_rate`, `threshold_info`, `stopping_criterion`, any other method-needed parameters, and argument validations to check invalid inputs. For example, `BasicLogger<:Logger`.\n    - [ ] Create a constructor with keyword default values for your `Logger` struct. For example, \n    ```\n        BasicLogger(;\n            max_it = 0, \n            collection_rate = 1, \n            threshold = 0.0,\n            stopping_criterion = threshold_stop \n        ) = BasicLogger(max_it, collection_rate, threshold, stopping_criterion)\n    ```\n    - [ ] Add documentation for this `Logger` struct, with mainly 5 parts: brief introduction, fields introduction, constructor and its keywords, what the constructor returns, and what the argument validations throw. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `LoggerRecipe` struct that uses the parameters from the `Logger` struct to preallocate memory. For example, `BasicLoggerRecipe{F<:Function} <: LoggerRecipe`.\n    - [ ] Create a `complete_logger` function that takes the `logger` struct as an input, and returns the `LoggerRecipe` struct you defined last step. For example, `complete_logger(logger::BasicLogger)`.\n    - [ ] Add documentation for this `LoggerRecipe` struct, with mainly 2 parts: brief introduction, fields introduction. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `update_logger!` function to log the errors as the iteration goes on, and stop the logging with convergence status or the maximum iteration limit. For example, \n    ```\n        update_logger!(logger::BasicLoggerRecipe, error::Float64, iteration::Int64)\n    ```\n    - [ ] Create a `reset_logger!` function to clean the history log information after convergence or exceed the maximum iteration. For example, `reset_logger!(logger::BasicLoggerRecipe)`.\n    - [ ] Create a `threshold_stop` function as the convergent stopping criterion designed for your `Logger` struct. For example, `threshold_stop(log::BasicLoggerRecipe)`\n    - [ ] Add documentation for this `threshold_stop` function, with mainly 3 parts: brief introduction, arguments introduction, and returns. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] **Optional**: If you have any helper functions that needed for your implementation, please implement them in a folder at `src/Solvers/Loggers`.\n2. Package structure cooperation (`src/Solvers/Loggers.jl`, `src/RLinearAlgebra.jl`, `src/refs.bib`):  \n    - [ ] Add an include(\"Loggers/[YOURFILE]\") at bottom of the page, `src/Solvers/Loggers.jl`.\n    - [ ] Add import statements to `src/RLinearAlgebra.jl` with any functions from other packages that you use.\n    - [ ] Export your `Logger`, `LoggerRecipe`, any structs and functions you needed for your logger method to work in `src/RLinearAlgebra.jl`.\n    - [ ] Add your `Logger`, `LoggerRecipe`, needed structs and functions to `docs/src/api.loggers.md`, under the appropriate heading.\n    - [ ] If there are any new-added references, please add in `src/refs.bib`.\n3. Tests (`test/Solvers/Loggers`):\n    - [ ] Add a procedural test to `test/Solvers/Loggers`. Be sure to check that the functions work as intended and all warnings/assertions are displayed. For example, `test/Solvers/Loggers/basic_logger.jl`.\n    - [ ] After finish implementing, you can goes to the julia's package environment by type `]` in the julia command line and run `test` to test whether you can pass all the tests.\n\n## Pull request\n- [ ] Give a specific title to pull request.\n- [ ] Lay out the features added to the pull request.\n- [ ] Tag two people to review your pull request.\n- [ ] **Optional**: If possible, please also add Copilot as a reviewer and choose to adopt its suggestions if reasonable.","category":"page"},{"location":"dev/checklists/","page":"Overview","title":"Overview","text":"Note that, the checklist is copied from Loggers","category":"page"},{"location":"manual/introduction/#A-library-for-exploring-Randomized-Linear-Algebra","page":"Introduction","title":"A library for exploring Randomized Linear Algebra","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"If you are here, you probably know that Linear Algebra is foundational to data science and  scientific computing. You also probably know Linear Algebra routines dominate the  computational cost of many of the algorithms in these fields. Thus, improving the  scalability of these algorithms requires more scalable Linear Algebra techniques.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"An exciting new set of techniques that offers such improved scalability of  Linear Algebra techniques are Randomized Linear Algebra techniques.  In general, Randomized Linear Algebra techniques aim to achieve this improved scalability by forming a representative sample of a matrix and performing  operations on that sample. In some circumstances operating on this sample can offer profound speed-ups as can see in the following example  where a technique known as the RandomizedSVD (see [1])  is used to compute a rank-20 approximation to 3000 times 3000 matrix  A in place of a truncated SVD. Compared to computing the SVD and  truncating it, the RandomizedSVD is 100 times faster and just as accurate  as the truncated SVD.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"using RLinearAlgebra\nusing LinearAlgebra\n\n# Generate a rank-20 matrix\nA = randn(3000, 20) * randn(20, 3000);\n\n@time U,S,V = svd(A);\n#    4.566639 seconds (13 allocations: 412.354 MiB, 0.92% gc time)\n\n# Form the RandomizedSVD data structure\ntechnique = RandomizedSVD(\n    compressor = Gaussian(compression_dim= 22,  cardinality=Right()), \n    orthogonalize=false, \n    power_its = 0\n)\n\n# Take the RandomizedSVD of A\n@time rec = rapproximate(technique, A);\n#    0.050950 seconds (39 allocations: 5.069 MiB)\n\n# Take the norm of the difference between the RandomizedSVD and TrunctatedSVD at rank 22\nnorm(rec.U * Diagonal(rec.S) * rec.V' - U[:,1:22] * Diagonal(S[1:22]) * (V[:, 1:22])')\n# 6.914995919005829e-11","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Over the years, numerous Randomized Linear Algebra approaches have been proposed not only for basic linear tasks such as computing a low-rank approximation to a matrix, solving  a linear system, or solving a least squares problem, but also for how obtain a  representative sample of the matrix itself. To this point, a single easy to prototype  library has not been developed to bring these techniques to the masses. RLinearAlgebra.jl is designed to be exactly such an easy-to-use library.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"In particular, RLinearAlgebra.jl leverages a modular design to allow you  to easily test Randomized Linear Algebra routines under a wide-range of parameter choices.  RLinearAlgebra.jl provides routines for two core Linear Algebra tasks: finding a solution to a linear system via Ax=b or min_x Ax - b and forming a low rank  approximation to a matrix, hat A where hat A approx A. The solution to a linear system appears everywhere: Optimization, Tomography, Statistics, Scientific Computing, Machine Learning, etc. The low-rank approximation problem has only become more relevant in recent years owing to the drastic increase in matrix sizes. It has been widely used in Statistics via PCA, but  also has become increasingly more relevant in all the fields where solving a linear system is  relevant. ","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"This manual will walk you through the use of the RLinearAlgebra.jl library. The remainder of this section will be focused on providing an overview of the common design elements in the library,  and information about how to get started using the library.","category":"page"},{"location":"manual/introduction/#Overview-of-the-Library","page":"Introduction","title":"Overview of the Library","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"The library is based on two data structure types: techniques that contain the parameters  that define a particular method and technique recipes that contain these parameters and  the necessary preallocations for the desired technique to be executed efficiently. As the  user you only need to define the techniques and the library will do all the work to form the recipes for you. If you wish to convert a technique into a technique recipe you can use the complete_[technique type] function.","category":"page"},{"location":"manual/introduction/#The-Technique-Types","page":"Introduction","title":"The Technique Types","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"With an understanding of the basic structures in the library, one may wonder, what  types of techniques are there? First, there are the techniques for solving the linear  system, Solvers and techniques for forming a low-rank approximation to a matrix,  Approximators. Both Solvers and Approximators achieve speedups by working on  compressed forms (often known as sketched or sampled) of the linear system, techniques that  compress the linear system are known as Compressors. Aside from these global techniques,  there are also techniques that are specific to Solvers, which include: ","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"SubSolvers, techniques that solve the inner (compressed) linear system.\nLoggers, techniques that log information and determine whether a stopping criterion has  been met.\nSolverError, a technique that computes the error of a current iterate of a solver.  ","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Similarly, Approximators have their own specific techniques, which include:","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"ApproximorError, a technique that computes the error of an Approximator.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"With all these technique structures, you may be wondering, what functions can I call on these structures? Well, the answer is not many. As is  summarized in the following table.  ","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Technique Parent Technique Function Calls\nApproximator None complete_approximator,rapproximate\nCompressor None complete_compressor\nSolver None complete_solver, rsolve\nApproximatorError Approximator complete_approximator_error\nLogger Solver complete_logger\nSolverError Solver complete_solver_error\nSubSolver Solver complete_sub_solver","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"From the above table we can see that essentially all you are able to do unless you are using  an Approximator or a Solver is complete the technique. The reason being that all the  technique structures contain only information about algorithmic parameters that require no  information about the linear system. The recipes on the other hand have all the information  required to use a technique including the required pre-allocated memory. We determine the  preallocations for the Recipes by merging the parameter information of the technique  structures with the matrix and linear system information via the complete_[technique]  functions, which is the only function that you can call when you have a technique structure.  There is a special exception for rsolve and rapproximate because they implicitly call  all the necessary completes to form the appropriate recipe. The bottom line is that do  anything useful you will need a recipe.","category":"page"},{"location":"manual/introduction/#The-Recipe-Types","page":"Introduction","title":"The Recipe Types","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Every technique can be transformed into a recipe. As has been stated before, what makes the  recipes different is that they contain all the required memory allocations. These allocations can only be determined from once the matrix is known. As a user,  all you have to know is that as soon as you have a recipe you can do a lot. As can be seen  in the following table.","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Technique Recipe Parent Recipe Function Calls\nApproximator None mul!, rapproximate!\nCompressor None mul!,update_compressor!\nSolver None rsolve!\nApproximatorError Approximator compute_approximator_error\nLogger Solver reset_logger!, update_logger!\nSolverError Solver compute_error\nSubSolver Solver update_sub_solver!,ldiv!","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Instead of providing  a different function for each method associated with these tasks, RLinearAlgebra.jl  leverages the multiple-dispatch functionality of Julia to allow all linear systems and  least squares problems to be solved calling the function  rsolve(solver::Solver, x::AbstractVector, A::AbstractMatrix, b::AbstractVector)  and all matrices to be approximated by calling the function  rapproximate(approximator::Approximator, A::AbstractMatrix). Under this design, changing  the routine for solving your linear system or approximate your matrix is as  simple as changing thesolver or approximator arguments. ","category":"page"},{"location":"manual/introduction/#Installing-RLinearAlgebra","page":"Introduction","title":"Installing RLinearAlgebra","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"Currently, RLinearAlgebra.jl is not registered in Julia's official package registry.  It can be installed by writing in the REPL:","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"] add https://github.com/numlinalg/RLinearAlgebra.jl.git","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"It can also be cloned into a local directory and installed by:","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"cd into the local project directory \nCall git clone https://github.com/numlinalg/RLinearAlgebra.jl.git\nRun Julia\nCall using Pkg\nCall Pkg.activate(RLinearAlgebra.jl)\nCall Pkg.instantiate()","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"For more information see Using someone else's project.","category":"page"},{"location":"manual/introduction/#Using-RLinearAlgebra.jl","page":"Introduction","title":"Using RLinearAlgebra.jl","text":"","category":"section"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"For this example let's assume that we have a vector that we wish to compress using one the RLinearAlgebra.jl SparseSign compressor. To do this: ","category":"page"},{"location":"manual/introduction/","page":"Introduction","title":"Introduction","text":"<ol>\n  <li>\n    Load <code>RLinearAlgebra.jl</code> and generate your vector\n<pre><code class=\"language-julia\">using RLinearAlgebra\nusing LinearAlgebra\n# Specify the size of the vector\nn = 10000\nx = rand(n)</code></pre>\n  </li>\n  <li>\n    Define the <code>SparseSign</code> technique. This requires us to specify a <code>cardinality</code>,\n    the direction we intend to apply the compressor from, and a <code>compression_dim</code>, \n    the number of entries we want in the compressed vector. In this instance we \n    want the cardinality to be <code>Left()</code> and the <code>compression_dim = 20</code>.\n    <pre><code class=\"language-julia\">comp = SparseSign(compression_dim = 20, Cardinality = Left())</code></pre>\n  </li>\n  <li>\n    Use the <code>complete_compressor</code> function to generate the <code>SparseSignRecipe</code>.\n    <pre><code class=\"language-julia\">S = complete_compressor(comp, A)</code></pre>\n  </li>\n  <li>\n    Apply the compressor to the vector using the multiplication function\n    <pre><code class=\"language-julia\">Sx = S * x\n    \nnorm(Sx)\n\nnorm(x)</code></pre>\n  </li>\n</ol>","category":"page"},{"location":"api/distributions/#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"api/distributions/","page":"Distributions","title":"Distributions","text":"Pages = [\"distributions.md\"]","category":"page"},{"location":"api/distributions/#Abstract-Types","page":"Distributions","title":"Abstract Types","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.Distribution","page":"Distributions","title":"RLinearAlgebra.Distribution","text":"Distribution\n\nAn abstract supertype for structures specifying distribution for indices in sampling methods.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#RLinearAlgebra.DistributionRecipe","page":"Distributions","title":"RLinearAlgebra.DistributionRecipe","text":"DistributionRecipe\n\nAn abstract supertype for structures with pre-allocated memory for distribution function     sampling methods.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#Distribution-Structures","page":"Distributions","title":"Distribution Structures","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.Uniform","page":"Distributions","title":"RLinearAlgebra.Uniform","text":"Uniform <: Distribution\n\nUniform distribution over the row/column index set of a matrix.\n\nMathematical Description\n\nDuring the sampling, the uniform distribution is defined on the domain of row/column  indices. If it's compressing from the left, then it means every row index has the same  probability weight. If it's compressing from the right, then it means every column index  has the same probability weight.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right()    or Undef().\nreplace::Bool, if true, then the sampling occurs with replacement; if false,    then the sampling occurs without replacement.\n\nConstructor\n\nUniform(;cardinality=Undef(), replace = false)\n\nReturns\n\nA Uniform object.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#RLinearAlgebra.UniformRecipe","page":"Distributions","title":"RLinearAlgebra.UniformRecipe","text":"UniformRecipe <: DistributionRecipe\n\nThe recipe containing all allocations and information for the uniform distribution.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The   value is either Left() or Right() or Undef().\nreplace::Bool, an option to replace or not during the sampling process based    on the given weights.\nstate_space::Vector{Int64}, the row/column index set.\nweights::ProbabilityWeights, the weights of each element in the state space.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#Exported-Functions","page":"Distributions","title":"Exported Functions","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.complete_distribution","page":"Distributions","title":"RLinearAlgebra.complete_distribution","text":"complete_distribution(distribution::Distribution, A::AbstractMatrix)\n\nA function that generates a DistributionRecipe given the      arguments.\n\nArguments\n\ndistribution::Distribution, a user-specified distribution function for sampling.\nA::AbstractMatrix, a coefficient matrix. \n\nOutputs\n\nA DistributionRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#RLinearAlgebra.update_distribution!","page":"Distributions","title":"RLinearAlgebra.update_distribution!","text":"update_distribution!(distribution::DistributionRecipe, A::AbstractMatrix)\n\nA function that updates the DistributionRecipe in place given      arguments.\n\nArguments\n\ndistribution::DistributionRecipe, a fully initialized realization of distribution.\nA::AbstractMatrix, a coefficient matrix. \n\nOutputs\n\nModifies the DistributionRecipe in place and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#RLinearAlgebra.sample_distribution!","page":"Distributions","title":"RLinearAlgebra.sample_distribution!","text":"sample_distribution!(x::AbstractVector, distribution::DistributionRecipe)\n\nA function that in place updates the x by given DistributionRecipe info.\n\nArguments\n\nx::AbstractVector, an abstract vector to store the sampled indices. \ndistribution::DistributionRecipe, a fully initialized realization of distribution.\n\nOutputs\n\nModifies the x in place by sampling that follows the weights and replacement given by \n\n'DistributionRecipe'.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#Internal-Functions","page":"Distributions","title":"Internal Functions","text":"","category":"section"},{"location":"api/approximators/#Approximators","page":"Approximators Overview","title":"Approximators","text":"","category":"section"},{"location":"api/approximators/","page":"Approximators Overview","title":"Approximators Overview","text":"Pages = [\"approximators.md\"]","category":"page"},{"location":"api/approximators/#Abstract-Types","page":"Approximators Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.Approximator","page":"Approximators Overview","title":"RLinearAlgebra.Approximator","text":"Approximator\n\nAn abstract supertype for structures that store user-controlled parameters corresponding to techniques that form low-rank approximations of the matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.ApproximatorRecipe","page":"Approximators Overview","title":"RLinearAlgebra.ApproximatorRecipe","text":"ApproximatorRecipe\n\nAn abstract supertype for structures that store user-controlled parameters, linear system dependent parameters and preallocated memory corresponding to techniques that form low-rank approximations of the matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.ApproximatorAdjoint","page":"Approximators Overview","title":"RLinearAlgebra.ApproximatorAdjoint","text":"ApproximatorAdjoint{S<:ApproximatorRecipe} <: ApproximatorRecipe\n\nA structure for the adjoint of an ApproximatorRecipe.\n\nFields\n\nParent::ApproximatorRecipe, the approximator that we compute the adjoint of.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeApproximator","page":"Approximators Overview","title":"RLinearAlgebra.RangeApproximator","text":"RangeApproximator\n\nAn abstract type for the structures that contain the user-controlled parameters  corresponding to the Approximator methods that produce an orthogonal approximation to the  range of a matrix A. This includes methods like the RandomizedSVD and  randomized rangefinder.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeApproximatorRecipe","page":"Approximators Overview","title":"RLinearAlgebra.RangeApproximatorRecipe","text":"RangeApproximatorRecipe\n\nAn abstract type for the structures that contain the user-controlled parameters,  linear system information, and preallocated memory for methods corresponding to the Approximator methods that produce an orthogonal approximation to the range of a matrix A. This includes methods like the RandomizedSVD and  randomized rangefinder.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#Approximator-Structures","page":"Approximators Overview","title":"Approximator Structures","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.RandSVD","page":"Approximators Overview","title":"RLinearAlgebra.RandSVD","text":"RandSVD\n\nA struct that implements the Randomized SVD. The Randomized SVD technique compresses a      matrix from the right to compute a rank k estimate to the truncated      SVD of a matrix A. See Algorithm 5.1 in [1] for additional      details.\n\nMathematical Description\n\nSuppose we have a matrix A in mathbbR^m times n for which we wish to form a      low-rank approximation with the form of an SVD. Specifically, we wish to find an      orthogonal matrix, U, a diagonal matrix, Sigma, and an orthogonal matrix,      V such that USigma V^top approx A. This can be done effectively using the      Randomized SVD presented in Algorithm 5.1 of [1].      This algorithm progresses by first having the user select a k  2 to be the      compression_dim of the compressor, which will also correspond to the desired      rank of the approximation. With this k, RandomizedSVD  generates a compression      matrix SinmathbbR^n times k and computes Q = textqr(AS) as in the      RangeFinder. With the Q, the RandomizedSVD      concludes by computing WSigmaV = textSVD(Q^top A) and  setting U = QW.     With high probability the approximation generated by the RandomizedSVD will satisfy      mathbbE A - U Sigma V^top _F leq sqrtk+1       (sum_i=k+1^min(mn)sigma_i)^12     , where sigma_k+1 is the k+1^textth singular value of (see Theorem 10.5      of [1]). This bound is often conservative as long as the singular      values of A decay quickly.\n\nWhen the singular values decay slowly, we can improve the quality of the approximation using the      power iteration, which applies A and A^top, q times      and take the qr factorization of (AA^top)^q AS. Using these power iterations      increases the relative gap between the singular values leading to  better RandomizedSVD      performance. \n\nPerforming power iterations in floating points can destroy all information      related to the smallest singular values of A      (see Remark 4.3 in [1]). We can preserve this information by      orthogonalizing inbetween the products of AS with A or A^top      in the power iteration. These steps are known as the orthogonalized power      iteration (see Algorithm 4.4 of [1]).       Orthogonalized power iterations progress according to the following steps:\n\ntildeA_1 = AS  \nQ_1R_1 = textbfqr(tildeA_1)  \ntildeA_2 = A^top Q_1  \nQ_2R_2 = textbfqr(tildeA_2)  \ntildeA_1 = A Q_2  \nQ_1 R_1 = textbfqr(tildeA_1)  \nRepeat Steps 3 through 6 for the desired number of power iterations  set Q = Q_1.  \n\nFields\n\ncompressor::Compressor, the technique for compressing the matrix from the right.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.    \nblock_size::Int64, the size of the tile when performing matrix multiplication. By    default, block_size = 0, this will be set to be the number of columns in    the original matrix, A.\n\nConstructor\n\nRandSVD(;\n    compressor::Compressor = SparseSign(cardinality = Right()), \n    orthogonalize::Bool  = false, \n    power_its::Int64 = 0,\n    block_size::Int64 = 0,\n)\n\nKeywords\n\ncompressor::Compressor, the technique for compressing the matrix from the right. By    default this is SparseSign with a cardinality Right().\npower_its::Int64, the number of power iterations that should be performed. By default    this is zero.\northogonalize::Bool, a boolean indicating whether the power_its should be performed   with orthogonalization. By default is false. \nblock_size::Int64, the size of the tile when performing matrix multiplication. By    default, block_size = 0, this will be set to be the number of columns in    the original matrix, A. By default this is zero.\n\nReturns\n\nA RandSVD object.\n\nThrows\n\nArgumentError if power_its or block_size are negative.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RandSVDRecipe","page":"Approximators Overview","title":"RLinearAlgebra.RandSVDRecipe","text":"RandSVDRecipe\n\nA struct that contains the preallocated memory and completed compressor to form a     RandSVD approximation to the matrix A.\n\nFields\n\nn_rows::Int64, the number of rows in the approximation. \nn_cols::Int64, the number of columns in the approximation. \ncompressor::CompressorRecipe, the compressor to be applied from the right to A.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\nU::AbstractArray, the orthogonal matrix that approximates the top compressor_dim    left singular vectors of A.\nS::AbstractVector, a vector containing the top compressor_dim singular values of    A.\nV::AbstractArray, the orthogonal matrix that approximates the top compressor_dim    right singular vectors of A.\nbuffer::AbstractArray, the storage for matrix multiplication with this low-rank    approximation. Will have the compression_dim number of rows and block_size   number of columns.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeFinder","page":"Approximators Overview","title":"RLinearAlgebra.RangeFinder","text":"RangeFinder\n\nA struct that implements the Randomized Range Finder technique which uses compression from      the right to form an low-dimensional orthogonal matrix Q that approximates the      range of A. See [1] for additional details.\n\nMathematical Description\n\nSuppose we have a matrix A in mathbbR^m times n of which we wish to form a low      rank approximation that approximately captures the range of A. Specifically, we wish     to find an Orthogonal matrix Q such that QQ^top A approx A. \n\nA simple way to find such a matrix is to choose a k representing the number of      vectors we wish to have in the subspace. Then we can generate a compression matrix      SinmathbbR^n times k and compute Q = textqr(AS).      With high probability we will have A - QQ^top A_2 leq     sqrtk+1 (sum_i=k+1^min(mn)sigma_i)^12,      where sigma_k+1 is the k+1^textth singular value      of A (see Theorem 10.5 of [1]). This bound is often conservative      as long as the singular values of A decay quickly.  \n\nWhen the singular values decay slowly, we can improve the quality of the approximation using the      power iteration, which applies A and A^top, q times      and take the qr factorization of (AA^top)^q AS. Using these power iterations increases the      relative gap between the singular values leading to  better Rangefinder performance. \n\nPerforming power iterations in floating points can destroy all information      related to the smallest singular values of A      (see Remark 4.3 in [1]). We can preserve this information by      orthogonalizing inbetween the products of AS with A or A^top      in the power iteration. These steps are known as the orthogonalized power      iteration (see Algorithm 4.4 of [1]).       Orthogonalized power iterations progress according to the following steps:\n\ntildeA_1 = AS  \nQ_1R_1 = textbfqr(tildeA_1)  \ntildeA_2 = A^top Q_1  \nQ_2R_2 = textbfqr(tildeA_2)  \ntildeA_1 = A Q_2  \nQ_1 R_1 = textbfqr(tildeA_1)  \nRepeat Steps 3 through 6 for the desired number of power iterations  set Q = Q_1. \n\nFields\n\ncompressor::Compressor, the technique that will compress the matrix from the right.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\n\nConstructor\n\nRangeFinder(;\n    compressor = SparseSign(), \n    orthogonalize = false, \n    power_its = 0\n)\n\nKeywords\n\ncompressor::Compressor, the technique that will compress the matrix from the right.\npower_its::Int64, the number of power iterations that should be performed. Default is   zero.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization. Default is false.\n\nReturns\n\nA RangeFinder object.\n\nThrows\n\nArgumentError if power_its is negative.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeFinderRecipe","page":"Approximators Overview","title":"RLinearAlgebra.RangeFinderRecipe","text":"RangeFinderRecipe\n\nA struct that contains the preallocated memory and completed compressor to form a     RangeFinder approximation to the matrix A.\n\nFields\n\ncompressor::CompressorRecipe, the compressor to be applied from the right to A.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\nrange::AbstractMatrix, the orthogonal matrix that approximates the range of A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#Exported-Functions","page":"Approximators Overview","title":"Exported Functions","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.complete_approximator","page":"Approximators Overview","title":"RLinearAlgebra.complete_approximator","text":"complete_approximator(approximator::Approximator, A::AbstractMatrix)\n\nA function that generates an ApproximatorRecipe given      arguments.\n\nArguments\n\napproximator::Approximator, a data structure containing the   user-defined parameters associated with a particular low-rank approximation.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rapproximate","page":"Approximators Overview","title":"RLinearAlgebra.rapproximate","text":"rapproximate(approximator::Approximator, A::AbstractMatrix)\n\nA function that computes a low-rank approximation of the matrix A     using the information in the provided Approximator data structure.\n\nArguments\n\napproximator::Approximator, a data structure containing the   user-defined parameters associated with a particular low-rank approximation.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rapproximate!","page":"Approximators Overview","title":"RLinearAlgebra.rapproximate!","text":"rapproximate!(approximator::ApproximatorRecipe, A::AbstractMatrix)\n\nA function that computes a low-rank approximation of the matrix A     using the information in the provided Approximator data structure.\n\nArguments\n\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#Internal-Functions","page":"Approximators Overview","title":"Internal Functions","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.rand_power_it","page":"Approximators Overview","title":"RLinearAlgebra.rand_power_it","text":"rand_power_it(approx::RangeFinderRecipe, A::AbstractMatrix)\n\nFunction that performs the randomized rangefinder procedure presented in Algortihm 4.3 of  [1].\n\nArguments\n\napprox::RangeFinderRecipe, a RangeFinderRecipe structure that contains the compressor\n\nrecipe.\n\nA::AbstractMatrix, the matrix being approximated.\n\nReturns\n\nQ::AbstractMatrix, an economical Q approximating the range of A.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rand_ortho_it","page":"Approximators Overview","title":"RLinearAlgebra.rand_ortho_it","text":"rand_ortho_it(approx::RangeFinderRecipe, A::AbstractMatrix)\n\nFunction that performs the randomized rangefinder procedure presented in Algortihm 4.4 of  [1].\n\nArguments\n\napprox::RangeFinderRecipe, a RangeFinderRecipe structure that contains the compressor\n\nrecipe.\n\nA::AbstractMatrix, the matrix being approximated.\n\nReturns\n\nQ::AbstractMatrix, an economical Q approximating the range of A.\n\n\n\n\n\n","category":"function"},{"location":"dev/contributing/#Contributing","page":"Contributing Overview","title":"Contributing","text":"","category":"section"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"Pages=[\"contributing.md\"]","category":"page"},{"location":"dev/contributing/#Improve-the-documentation","page":"Contributing Overview","title":"Improve the documentation","text":"","category":"section"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"If you have ever been reading the documentation and been unsure about a description or      instruction, the documentation can be improved. Since you are the person finding this       gap in the documentation, you are also the person in the best position to fix it.","category":"page"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"The documentation is written in Markdown and built using      Documenter.jl.      The source code for all the docs is      here. ","category":"page"},{"location":"dev/contributing/#Bug-Reports","page":"Contributing Overview","title":"Bug Reports","text":"","category":"section"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"If you find a bug in our software we would love to know about it. You can make an issue  relating to a bug report here. ","category":"page"},{"location":"dev/contributing/#Feature-Requests","page":"Contributing Overview","title":"Feature Requests","text":"","category":"section"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"Have a new method that you think would be a valuable addition to the package?      Make a feature request      and let us know about it. Please provide details of why this feature would be valuable      and if possible point us to resources to help us better understand the feature.","category":"page"},{"location":"dev/contributing/#Contribute-code","page":"Contributing Overview","title":"Contribute code","text":"","category":"section"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"You can also contribute code to RLinearAlgebra.jl. Before contributing make sure that you      are familiar with Git,      GitHub,       Julia package development,     and the Design of the RLinearAlgebra.jl.     Once you are familiar with these items you can contribute to RLinearAlgebra.jl by      following the steps laid out in the      JUMP guide.","category":"page"},{"location":"dev/checklists/loggers/#Loggers-checklist","page":"Loggers","title":"Loggers checklist","text":"","category":"section"},{"location":"dev/checklists/loggers/","page":"Loggers","title":"Loggers","text":"If you are implementing a logging method for the library, make sure you have completed  the following steps before making a pull request. In the following guides, BasicLogger method is used as an example.","category":"page"},{"location":"dev/checklists/loggers/","page":"Loggers","title":"Loggers","text":"## Implementation\n1. Method's core codes (`src/Solvers/Loggers`):\n    - [ ] Create a file in the directory `src/Solvers/Loggers`. For example, `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `Logger` struct with `max_it`, `collection_rate`, `threshold_info`, `stopping_criterion`, any other method-needed parameters, and argument validations to check invalid inputs. For example, `BasicLogger<:Logger`.\n    - [ ] Create a constructor with keyword default values for your `Logger` struct. For example, \n    ```\n        BasicLogger(;\n            max_it = 0, \n            collection_rate = 1, \n            threshold = 0.0,\n            stopping_criterion = threshold_stop \n        ) = BasicLogger(max_it, collection_rate, threshold, stopping_criterion)\n    ```\n    - [ ] Add documentation for this `Logger` struct, with mainly 5 parts: brief introduction, fields introduction, constructor and its keywords, what the constructor returns, and what the argument validations throw. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `LoggerRecipe` struct that uses the parameters from the `Logger` struct to preallocate memory. For example, `BasicLoggerRecipe{F<:Function} <: LoggerRecipe`.\n    - [ ] Create a `complete_logger` function that takes the `logger` struct as an input, and returns the `LoggerRecipe` struct you defined last step. For example, `complete_logger(logger::BasicLogger)`.\n    - [ ] Add documentation for this `LoggerRecipe` struct, with mainly 2 parts: brief introduction, fields introduction. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `update_logger!` function to log the errors as the iteration goes on, and stop the logging with convergence status or the maximum iteration limit. For example, \n    ```\n        update_logger!(logger::BasicLoggerRecipe, error::Float64, iteration::Int64)\n    ```\n    - [ ] Create a `reset_logger!` function to clean the history log information after convergence or exceed the maximum iteration. For example, `reset_logger!(logger::BasicLoggerRecipe)`.\n    - [ ] Create a `threshold_stop` function as the convergent stopping criterion designed for your `Logger` struct. For example, `threshold_stop(log::BasicLoggerRecipe)`\n    - [ ] Add documentation for this `threshold_stop` function, with mainly 3 parts: brief introduction, arguments introduction, and returns. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] **Optional**: If you have any helper functions that needed for your implementation, please implement them in a folder at `src/Solvers/Loggers`.\n2. Package structure cooperation (`src/Solvers/Loggers.jl`, `src/RLinearAlgebra.jl`, `src/refs.bib`):  \n    - [ ] Add an include(\"Loggers/[YOURFILE]\") at bottom of the page, `src/Solvers/Loggers.jl`.\n    - [ ] Add import statements to `src/RLinearAlgebra.jl` with any functions from other packages that you use.\n    - [ ] Export your `Logger`, `LoggerRecipe`, any structs and functions you needed for your logger method to work in `src/RLinearAlgebra.jl`.\n    - [ ] Add your `Logger`, `LoggerRecipe`, needed structs and functions to `docs/src/api.loggers.md`, under the appropriate heading.\n    - [ ] If there are any new-added references, please add in `src/refs.bib`.\n3. Tests (`test/Solvers/Loggers`):\n    - [ ] Add a procedural test to `test/Solvers/Loggers`. Be sure to check that the functions work as intended and all warnings/assertions are displayed. For example, `test/Solvers/Loggers/basic_logger.jl`.\n    - [ ] After finish implementing, you can goes to the julia's package environment by type `]` in the julia command line and run `test` to test whether you can pass all the tests.\n\n## Pull request\n- [ ] Give a specific title to pull request.\n- [ ] Lay out the features added to the pull request.\n- [ ] Tag two people to review your pull request.\n- [ ] **Optional**: If possible, please also add Copilot as a reviewer and choose to adopt its suggestions if reasonable.","category":"page"},{"location":"api/solver_errors/#SolverErrors","page":"SolverErrors","title":"SolverErrors","text":"","category":"section"},{"location":"api/solver_errors/","page":"SolverErrors","title":"SolverErrors","text":"Pages = [\"solver_errors.md\"]","category":"page"},{"location":"api/solver_errors/#Abstract-Types","page":"SolverErrors","title":"Abstract Types","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.SolverError","page":"SolverErrors","title":"RLinearAlgebra.SolverError","text":"SolverError\n\nAn abstract supertype for structures that track and/or evaluate the quality of a solution for a linear system or least squares.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#RLinearAlgebra.SolverErrorRecipe","page":"SolverErrors","title":"RLinearAlgebra.SolverErrorRecipe","text":"SolverErrorRecipe\n\nAn abstract supertype for structures that contain the user-controlled parameters, linear system dependent parameters, and preallocated memory for techniques that evaluate the solution to a linear solver.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#SolverError-Structures","page":"SolverErrors","title":"SolverError Structures","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.FullResidual","page":"SolverErrors","title":"RLinearAlgebra.FullResidual","text":"FullResidual <: SolverError\n\nA SolverError structure for computing the norm of the full residual, b-Ax.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#RLinearAlgebra.FullResidualRecipe","page":"SolverErrors","title":"RLinearAlgebra.FullResidualRecipe","text":"FullResidual <: SolverErrorRecipe\n\nA SolverErrorResidual structure for computing the norm of the full residual, b-Ax\n\nFields\n\nresidual::AbstractVector, a container for the residual b-Ax.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#Exported-Functions","page":"SolverErrors","title":"Exported Functions","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.complete_error","page":"SolverErrors","title":"RLinearAlgebra.complete_error","text":"complete_error(\n    error::SolverError, \n    solver::Solver,\n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that generates a SolverErrorRecipe given the      arguments.\n\nArguments\n\nerror::SolverError, a user-specified solver error method.\nsolver::Solver, a user-specified solver method.\nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nReturns\n\nA SolverErrorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solver_errors/#RLinearAlgebra.compute_error","page":"SolverErrors","title":"RLinearAlgebra.compute_error","text":"compute_error(\n    error::SolverErrorRecipe, \n    solver::SolverRecipe, \n    x::AbstractVector,\n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that evaluates the error for a proposed solution      vector.\n\nArguments\n\nerror::SolverErrorRecipe, a fully initialized realization for   a solver error method for a specific linear system or least squares problem.\nsolver::SolverRecipe, a fully initialized realization for a    solver method for a specific linear system.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nReturns\n\nReturns nothing\n\n\n\n\n\n","category":"function"},{"location":"tutorials/introduction/#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"The purpose of these tutorials is to use examples help  new users quickly get hands on the usage of RLinearAlgebra.","category":"page"},{"location":"tutorials/introduction/#How-these-tutorials-are-structured","page":"Introduction","title":"How these tutorials are structured","text":"","category":"section"},{"location":"tutorials/introduction/","page":"Introduction","title":"Introduction","text":"Start from the solving Ax = b","category":"page"},{"location":"api/solvers/#Solvers","page":"Solvers Overview","title":"Solvers","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers Overview","title":"Solvers Overview","text":"Pages = [\"solvers.md\"]","category":"page"},{"location":"api/solvers/#Abstract-Types","page":"Solvers Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.Solver","page":"Solvers Overview","title":"RLinearAlgebra.Solver","text":"Solver\n\nAn abstract supertype for structures that contain the user-controlled parameters for methods that solve linear systems and least squares problems.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#RLinearAlgebra.SolverRecipe","page":"Solvers Overview","title":"RLinearAlgebra.SolverRecipe","text":"SolverRecipe\n\nAn abstract supertype specifying a solver method with pre-allocated data structures given a coefficient matrix and constant vector.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#Solver-Structures","page":"Solvers Overview","title":"Solver Structures","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.Kaczmarz","page":"Solvers Overview","title":"RLinearAlgebra.Kaczmarz","text":"Kaczmarz <: Solver\n\nAn implementation of a Kaczmarz solver. Specifically, it is a solver that iteratively     updates an iterate by projecting the iterate onto (a subspace of) the row space of a     consistent linear system.\n\nMathematical Description\n\nLet A be an m times n matrix and consider the consistent linear system Ax=b.      We can view the solution to this linear system as lying at the intersection of the      row hyperplanes,      cap_i in 1 ldots mu in mathbbR^n  A_i cdot u = b_i     ,     where A_i cdot represents the i^textth row of A. One way to find      this interesection is to iteratively project some abritrary point, x from one      hyperplane to the next, through      x_+ = x + alpha fracb_i - lange A_icdot xrangle A_icdot     Doing this with random permutation of i can lead to a geometric convergence      [6].     Here alpha is viewed as an over-relaxation parameter and can improve convergence.      One can also generalize this procedure to blocks by considering the S being a      s times n random matrix. If we let tilde A = S A and tilde b = Sb      then we can perform block kaczmarz as described by [7] with      x_+ = x + alpha tilde A^top (tilde A tilde A^top)^dagger      (tilde b - tilde A x)     While, S is often random, in reality, whether S is deterministic or random is      quite flexible see [8] for more details.\n\nFields\n\nalpha::Float64, the over-relaxation parameter. It is multiplied by the update and can    affect convergence.\ncompressor::Compressor, a technique for forming the compressed rowspace of the linear    system.\nlog::Logger, a technique for logging the progress of the solver.\nerror::SolverError, a method for estimating the progress of the solver.\nsub_solver::SubSolver, a technique to perform the projection of the solution onto the    compressed rowspace.\n\nConstructor\n\nKaczmarz(;\n    compressor::Compressor = SparseSign(), \n    log::Logger = BasicLogger(),\n    error::SolverError = FullResidual(),\n    sub_solver::SubSolver = LQSolver(),\n    alpha::Float64 = 1.0\n)\n\nKeywords\n\ncompressor::Compressor, a technique for forming the compressed rowspace of the    linear system.\nlog::Logger, a technique for logging the progress of the solver.\nerror::SolverError, a method for estimating the progress of the solver.\nsub_solver::SubSolver, a technique to perform the projection of the solution onto the    compressed rowspace. When the compression_dim = 1 this is not used.\nalpha::Float64, the over-relaxation parameter. It is multiplied by the update and can    affect convergence. By default this value is 1.\n\nReturns\n\nA Kaczmarz object.\n\ninfo: Info\nThe alpha parameter should be in (02)  for convergence to be guaranteed. This  condition is not enforced in the constructor. There are some instances where setting  alpha = 2 can lead to non-convergent cycles [9].\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#RLinearAlgebra.KaczmarzRecipe","page":"Solvers Overview","title":"RLinearAlgebra.KaczmarzRecipe","text":"KaczmarzRecipe{\n    T<:Number, \n    V<:AbstractVector,\n    M<:AbstractMatrix, \n    VV<:SubArray,\n    MV<:SubArray,\n    C<:CompressorRecipe, \n    L<:LoggerRecipe,\n    E<:SolverErrorRecipe, \n    B<:SubSolverRecipe\n} <: SolverRecipe\n\nA mutable structure containing all information relevant to the Kaczmarz solver. It is     formed by calling the function complete_solver on Kaczmarz solver, which includes     all the user controlled parameters, and the linear system matrix A and constant      vector b.\n\nFields\n\ncompressor::CompressorRecipe, a technique for forming the compressed rowspace of the    linear system.\nlog::LoggerRecipe, a technique for logging the progress of the solver.\nerror::SolverErrorRecipe, a method for estimating the progress of the solver.\nsub_solver::SubSolverRecipe, a technique to perform the projection of the solution onto   the compressed rowspace.\nalpha::Float64, the over-relaxation parameter. It is multiplied by the update and can    affect convergence.\ncompressed_mat::AbstractMatrix, a matrix container for storing the compressed matrix.    Will be set to be the largest possible block size.\ncompressed_vec::AbstractVector, a vector container for storing the compressed constant   vector. Will be set to be the largest possible block size.\nsolution_vec::AbstractVector, a vector container for storing the solution to the linear   system.\nupdate_vec::AbstractVector, a vector container for storing the update to the linear    system.\nmat_view::SubArray, a container for storing a view of compressed matrix container.    Using views here allows for variable block sizes.\nvec_view::SubArray, a container for storing a view of the compressed vector container.   Using views here allows for variable block sizes.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#Exported-Functions","page":"Solvers Overview","title":"Exported Functions","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.complete_solver","page":"Solvers Overview","title":"RLinearAlgebra.complete_solver","text":"complete_solver(solver::Solver, x::AbstractVector, A::AbstractMatrix, b::AbstractVector)\n\nA function that generates a SolverRecipe given the      arguments.\n\nArguments\n\nsolver::Solver, a user-specified solver method.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nA SolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.rsolve!","page":"Solvers Overview","title":"RLinearAlgebra.rsolve!","text":"rsolve!(\n    solver::SolverRecipe, \n    x::AbstractVector, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that solves a linear system given the arguments.\n\nArguments\n\nsolver::SolverRecipe, a fully initialized realization for a    solver method for a specific linear system.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nReturns nothing. Updates the SolverRecipe and x in place.\n\n\n\n\n\nrsolve!(\n    solver::Solver, \n    x::AbstractVector, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that solves a linear system given the arguments.\n\nArguments\n\nsolver::Solver, a user-specified solver method.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nx::AbstractVector, a proposed solution to a linear system or least squares    problem.\nA SolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#Internal-Functions","page":"Solvers Overview","title":"Internal Functions","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.kaczmarz_update!","page":"Solvers Overview","title":"RLinearAlgebra.kaczmarz_update!","text":"kaczmarz_update!(solver::KaczmarzRecipe)\n\nA function that performs the Kaczmarz update when the compression dimension is one.      If a is the resulting compression of the coefficient matrix,      and c is the resulting compression of the constant vector,      then we perform the update: x = x - alpha (a^top x -c)  a_2^2. \n\nArguments\n\nsolver::KaczmarzRecipe, the solver information required for performing the update.\n\nOutputs\n\nreturns nothing\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.kaczmarz_update_block!","page":"Solvers Overview","title":"RLinearAlgebra.kaczmarz_update_block!","text":"kaczmarz_update_block!(solver::KaczmarzRecipe)\n\nA function that performs the kaczmarz update when the compression dim is greater than 1.       In the block case where the compressed matrix tilde A, and the compressed      contant vector tilde b, we perform the updated:      x = x - alpha tilde A^top (tilde A tilde A^top)^dagger     (tilde Ax-tilde b).\n\nArguments\n\nsolver::KaczmarzRecipe, the solver information required for performing the update.\n\nOutputs\n\nreturns nothing\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.dotu","page":"Solvers Overview","title":"RLinearAlgebra.dotu","text":"dotu(a::AbstractArray, b::AbstractArray)\n\nA function that computes the non conjugate dot product between two vectors. It is equivalent     to calling dot(conj(a), b).\n\nArguments\n\na::AbstractArray, a vector being dot producted (is labeled as a array to allow for    views).\nb::AbstractArray, a vector being dot producted (is labeled as a array to allow for    views).\n\nReturns\n\nA scalar that is the non-conjugated dot product between two vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#ApproximatorErrors","page":"ApproximatorErrors","title":"ApproximatorErrors","text":"","category":"section"},{"location":"api/approximator_errors/","page":"ApproximatorErrors","title":"ApproximatorErrors","text":"Pages = [\"approximator_errors.md\"]","category":"page"},{"location":"api/approximator_errors/#Abstract-Types","page":"ApproximatorErrors","title":"Abstract Types","text":"","category":"section"},{"location":"api/approximator_errors/#RLinearAlgebra.ApproximatorError","page":"ApproximatorErrors","title":"RLinearAlgebra.ApproximatorError","text":"ApproximatorError\n\nAn abstract supertype for structures containing user-controlled parameters corresponding to methods that evaluate the quality of a low-rank approximation of a matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximator_errors/#RLinearAlgebra.ApproximatorErrorRecipe","page":"ApproximatorErrors","title":"RLinearAlgebra.ApproximatorErrorRecipe","text":"ApproximatorErrorRecipe\n\nAn abstract supertype for structures containing user-controlled parameters, matrix dependent parameters and preallocated memory corresponding to methods that evaluate the quality of a low-rank approximation of a matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximator_errors/#ApproximatorError-Structures","page":"ApproximatorErrors","title":"ApproximatorError Structures","text":"","category":"section"},{"location":"api/approximator_errors/#Exported-Functions","page":"ApproximatorErrors","title":"Exported Functions","text":"","category":"section"},{"location":"api/approximator_errors/#RLinearAlgebra.complete_approximator_error","page":"ApproximatorErrors","title":"RLinearAlgebra.complete_approximator_error","text":"complete_approximator_error(\n    error::ApproximatorError, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that generates an ApproximatorErrorRecipe     given the arguments.\n\nArguments\n\nerror::ApproximatorError, a data structure containing   the user-defined parameters associated with a particular low-rank approximation error   method.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorErrorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#RLinearAlgebra.compute_approximator_error","page":"ApproximatorErrors","title":"RLinearAlgebra.compute_approximator_error","text":"compute_approximator_error(\n    error::ApproximatorError, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that computes the approximation error of an     ApproximatorRecipe for a matrix A.\n\nArguments\n\nerror::ApproximatorError, a data structure containing   the user-defined parameters associated with a particular low-rank approximation error   method.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nReturns the error::Float64 \n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#RLinearAlgebra.compute_approximator_error!","page":"ApproximatorErrors","title":"RLinearAlgebra.compute_approximator_error!","text":"compute_approximator_error!(\n    error::ApproximatorErrorRecipe, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that computes the approximation error of an     ApproximatorRecipe for a matrix A.\n\nArguments\n\nerror::ApproximatorErrorRecipe, a fully initialized   realization for a low rank approximation error method for a particular matrix.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nReturns the error::Float64 \n\n\n\n\n\n","category":"function"},{"location":"dev/checklists/compressors/#Compressors-checklist","page":"Compressors","title":"Compressors checklist","text":"","category":"section"},{"location":"dev/checklists/compressors/","page":"Compressors","title":"Compressors","text":"If you are implementing a compression method for the library, make sure you have completed  the following steps before making a pull request. ","category":"page"},{"location":"dev/checklists/compressors/","page":"Compressors","title":"Compressors","text":"1. Implementation\n- [ ] Create a file in the directory `src/Compressors`.\n- [ ] Create a Compressor structure with n_rows and n_cols as well as other user-controlled \nparameters.\n- [ ] Create a constructor with keyword default values for your struct.\n- [ ] Create a CompressorRecipe structure that uses the parameters from the Compressor \nstructure to preallocate memory.\n- [ ] Create a `complete_compressor` function that takes as inputs of the Compressor, A, x,b\nand returns a CompressorRecipe\n- [ ] Create a `update_compressor!` function that generates new random values for a random\ncomponents of the Compressor \n- [ ] a 5 input `mul!` function for  applying a compressor to a matrix from the left\n- [ ] a 5 input `mul!` function for  applying a compressor to a matrix from the right \n- [ ] a 5 input `mul!` function for  applying a compressor to a vector\n- [ ] a 5 input `mul!` function for  applying the adjoint of the compressor to a vector\n- [ ] Add an include(\"Compressors/[YOURFILE]\") at bottom of page \n- [ ] Add import statements to src/RLinearAlgebra.jl with any functions from other packages \nthat you use.\n- [ ] Add your Compressor and CompressorRecipe to src/RLinearAlgebra.jl.\n- [ ] Add your Compressor and CompressorRecipe to docs/src/api/compressors.md \nunder the appropiate heading. \n- [ ] Add a procedural test to test/linear_samplers. Be sure to check that the functions \nwork as intended and all warnings/assertions are displayed.\n2. Pull request\n- [ ] Give a specific title to pull request.\n- [ ] Lay out the features added to the pull request.\n- [ ] Tag two people to review your pull request.","category":"page"},{"location":"tutorials/getting_started/#Use-Case:-Solving-a-Least-Squares-Problem-with-the-Sparse-Sign-Method","page":"Getting started","title":"Use Case: Solving a Least-Squares Problem with the Sparse Sign Method","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"This guide demonstrates how to use the SparseSign compression method from the RLinearAlgebra.jl package to solve an overdetermined linear system (i.e., a least-squares problem) of the form:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"min_x Ax - b_2^2","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We will follow the design philosophy of RLinearAlgebra.jl by composing different modules (Solver, Compressor, Logger, etc.) to build and solve the problem.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorials/getting_started/#1.-Problem-Setup","page":"Getting started","title":"1. Problem Setup","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Let's define a specific linear system Ax = b. ","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To verify the accuracy of the final result, suppose that we know the true solution of the system, x_texttrue, and then use it and a random generated matrix A to generate the vector b.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Matrix A: A random 1000 times 20 matrix.\nVector b: Calculated as b = A x_texttrue, with dimensions 1000 times 1.\nGoal: Find a solution x that is as close as possible to x_texttrue.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To achieve this, we need to import the required libraries and create the matrix A and vector b as defined above. We will also set an initial guess, x_init, for the solver.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Import relevant libraries\nusing RLinearAlgebra, Random, LinearAlgebra\n\n\n# Define the dimensions of the linear system\nnum_rows, num_cols = 1000, 20\n\n# Create the matrix A and a known true solution x_true\nA = randn(Float64, num_rows, num_cols);\nx_true = randn(Float64, num_cols);\n\n# Calculate the right-hand side vector b from A and x_true\nb = A * x_true;\n\n# Set an initial guess for the solution vector x (typically a zero vector)\nx_init = zeros(Float64, num_cols);\n\nprintln(\"Dimensions:\")\nprintln(\" - Matrix A: \", size(A))\nprintln(\" - Vector b: \", size(b))\nprintln(\" - True solution x_true: \", size(x_true))\nprintln(\" - Initial guess x_init: \", size(x_true))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorials/getting_started/#2.-Create-compressors","page":"Getting started","title":"2. Create compressors","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"In practice, we may encounter a much larger A matrix than what we have here. Solving the problem with such a large matrix can slow down the performance of iterative algorithms that we will use to solve the least square problem. Therefore, we will use a randomized sketching technique to compress the matrix A and the corresponding vector b to a lower dimension, while preserving the essential geometric information of the system.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Here, we will use the sparse sign method.","category":"page"},{"location":"tutorials/getting_started/#(a)-Configure-the-SparseSign-Compressor","page":"Getting started","title":"(a) Configure the SparseSign Compressor","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"The idea of randomized methods is to reduce the scale of the original problem when the dimention of matrix A is too big, using a random \"sketch\" or \"compression\" matrix, S. Here, we choose SparseSign as our Compressor. This compressor generates a sparse matrix whose non-zero elements are +1 or -1 (with scaling). More information can be found here.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We will configure a compression matrix S that compresses the 100 rows of the original system down to 30 rows.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# The goal is to compress the 100 rows of A to 300 rows\ncompression_dim = 300\n# We want each row of the compression matrix S to have 5 non-zero elements\nnon_zeros = 5\n\n# Configure the SparseSign compressor\n# - cardinality=Left(): Indicates the compression matrix S will be \n#    left-multiplied with A (SAx = Sb).\n# - compression_dim: The compressed dimension (number of rows).\n# - nnz: The number of non-zero elements per column (left)/row (right) in S. \n# - type: The element type for the compression matrix.\nsparse_compressor = SparseSign(\n    cardinality=Left(),\n    compression_dim=compression_dim,\n    nnz=non_zeros,\n    type=Float64\n)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorials/getting_started/#(b)-Build-the-SparseSign-recipe","page":"Getting started","title":"(b) Build the SparseSign recipe","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"After configuring the compressor, we need to combine it with our specific matrix A to create a SparseSignRecipe. This recipe contains the generated sparse matrix and all necessary information to perform the compression efficiently.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Pass the compressor configuration and the original matrix A to\n# create the final compression recipe.\nS = complete_compressor(sparse_compressor, A)\n\n# You can closely look at the compression recipe you created.\nprintln(\" - Compression matrix is applied to left or right: \", S.cardinality)\nprintln(\" - Compression matrix's number of rows: \", S.n_rows)\nprintln(\" - Compression matrix's number of columns: \",  S.n_cols)\nprintln(\" - The number of nonzeros in each column (left)/row (right) of compression matrix: \",  S.nnz)\nprintln(\" - Compression matrix's nonzero entry values: \",  S.scale)\nprintln(\" - Compression matrix: \",  S.op)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Oops, I suddenly felt 300 rows is not a small enough size, and want to change the dimension to 10. Then I need to  respecify the SparseSign compressor and build the recipe again:","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Change the dimension of the compressor. Similarly, you can use the idea \n# for other configurations' changes.\nsparse_compressor.compression_dim = 10\n\n# Rebuild the compressor recipe\nS = complete_compressor(sparse_compressor, A)\nprintln(\"Compression matrix's number of rows: \", S.n_rows)","category":"page"},{"location":"tutorials/getting_started/#(c)-Apply-the-sparse-sign-matrix-to-the-system","page":"Getting started","title":"(c) Apply the sparse sign matrix to the system","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"While the solver can use the S recipe to perform multiplications on-the-fly, it can sometimes be useful to form the compressed system explicitly. We can use * for this.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Form the compressed system SAx = Sb\nSA = S * A\nSb = S * b\n\nprintln(\"Dimensions of the compressed system:\")\nprintln(\" - Matrix SA: \", size(SA))\nprintln(\" - Vector Sb: \", size(Sb))","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorials/getting_started/#3.-Create-solver","page":"Getting started","title":"3. Create solver","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"With the problem and compressor defined, the next step is to choose and configure a solver. Here, we choose to use the  Kaczmarz solver. We configure it by passing in \"ingredient\" objects for each of its main functions: compressing the system (already done), logging progress, and checking for errors.","category":"page"},{"location":"tutorials/getting_started/#(a)-Configure-the-logger-and-stopping-rules","page":"Getting started","title":"(a)  Configure the logger and stopping rules","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"To monitor the solver, we will use a BasicLogger. This object will serve two purposes: record the error history, and tell the solver when to stop.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"We will configure it to stop after a maximum of 50 iterations or if the calculated error drops below a tolerance of 1e-6.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Configure the logger to control the solver's execution\nlogger = BasicLogger(\n    max_it = 50,\n    threshold = 1e-6,\n    collection_rate = 5\n)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorials/getting_started/#(b)-Build-the-Kaczmarz-Solver","page":"Getting started","title":"(b) Build the Kaczmarz Solver","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Now, we assemble our configured components (compressor S, logger L) into the main Kaczmarz solver object. We will use the default methods for error checking and the sub-solver to be LQ factorization (LQSolver).","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Create the Kaczmarz solver object by passing in the ingredients\nkaczmarz_solver = Kaczmarz(\n    compressor = sparse_compressor,\n    log = logger,\n    sub_solver = LQSolver()\n)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Before we can run the solver, we must call complete_solver. This function takes the solver configurations and the specific problem data A, b, x_init and creates a KaczmarzRecipe. The recipe pre-allocates all the necessary memory buffers for efficient computation.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Create the solver recipe by combining the solver and the problem data\nsolver_recipe = complete_solver(kaczmarz_solver, x_init, A, b)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorials/getting_started/#4.-Solve-the-Compressed-System","page":"Getting started","title":"4. Solve the Compressed System","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"With the recipe fully prepared, we can now call rsolve! to run the Kaczmarz algorithm. The function will iterate until the stopping criterion in the logger is met.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"The rsolve! function will modify x_init in-place, updating it with the calculated solution.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# Run the solver!\nrsolve!(solver_recipe, x_init, A, b)\n\n# The solution is now stored in the updated x_init vector\nsolution = x_init;","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"","category":"page"},{"location":"tutorials/getting_started/#5.-Verify-the-result","page":"Getting started","title":"5. Verify the result","text":"","category":"section"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"Finally, let's check how close our calculated solution is to the known x_true. We can do this by calculating the Euclidean norm of the difference between the two vectors. A small error norm indicates a successful approximation.","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"# We can inspect the logger's history to see the convergence\nerror_history = solver_recipe.log.hist;\nprintln(\" - Solver stopped at iteration: \", solver_recipe.log.iteration)\nprintln(\" - Final error: \", error_history[solver_recipe.log.record_location - 1])\n\n# Calculate the norm of the error\nerror_norm = norm(solution - x_true)\nprintln(\" - Norm of the error between the solution and x_true: \", error_norm)","category":"page"},{"location":"tutorials/getting_started/","page":"Getting started","title":"Getting started","text":"As you can see, by using the modular Kaczmarz solver, we were able to configure a randomized block-based method and find a solution vector that is very close to the true solution. ","category":"page"},{"location":"#RLinearAlgebra","page":"Home","title":"RLinearAlgebra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RLinearAlgebra is a Julia library for the  development and application of randomized algorithms to the problems of forming low rank  approximations to matrices and finding the solution of linear systems and least squares  problems.  Because of the large diversity of randomized techniques, rather than offering isolated  routine implementations of algorithms, this library implements a series of extendable data  structures and methods which allow code reuse.","category":"page"},{"location":"#Documentation-structure","page":"Home","title":"Documentation structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation serves both as a manual to the library and as an introduction to  randomized linear approximation techniques and randomized linear algebra solvers.  We divide it in four parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorial: examples of how to solve linear systems and least squares problems with   RLinearAlgebra and how to extend the library.\nManual: here we offer an introduction to solving linear systems with randomized linear    algebra techniques, compressing a matrix, and forming a low-rank approximation of a matrix.    We introduce theoretical foundations and we provide code examples with RLinearAlgebra.\nAPI: a detailed description of all the data structures and methods of the library.\nDevelopment: detailed instructions on how to contribute to the library.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is supported by the National Science Foundation Office of Advanced  Cyberinfrastructure under awards  2309445 and  2309446. This material is based upon work supported by the U.S. Department of Energy, Office of  Science, under contract number DE-AC02-06CH11357.","category":"page"},{"location":"api/contents/#Randomized-Linear-Solver-Reference","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"","category":"section"},{"location":"api/contents/","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"Pages=[\n  \"approximators.md\",  \n  \"approximator_errors.md\",\n  \"compressors.md\",\n  \"solvers.md\",\n  \"solver_error.md\",\n  \"sub_solvers.md\",\n  \"loggers.md\"]","category":"page"}]
}
