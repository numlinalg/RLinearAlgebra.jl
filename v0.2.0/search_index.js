var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"dev/design/#Design","page":"Design of Library","title":"Design","text":"","category":"section"},{"location":"dev/design/#Overview-Library-Goals","page":"Design of Library","title":"Overview Library Goals","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"RLinearAlgebra.jl implements randomized numerical linear algebra (RNLA) routines for two tasks: (1) solving a matrix equations and (2) forming a low-rank approximation  to matrices.  The primary tool Randomized Linear Algebra uses to accomplish these tasks is multiplying the large matrix system by a smaller randomized matrix to compress the  large matrix. In the literature this process if often referred to as sampling or sketching, RLinearAlgebra.jl refers to this process as compression. ","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The library is organized with main techniques falling into one of three types:  Approximators, Compressors, and Solvers. Solvers feature their own set of  sub-techniques: Loggers, SolverErrors, and SubSolvers that facilitate solving. Approximators have only one set of sub-techniques known as ApproximatorErrors.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"RLinearAlgebra.jl is designed so that the codebase has a good balance between efficiency  and modularity. RLinearAlgebra.jl tries to achieve these goals by introducing two  structures, one that contains user-controlled parameters which takes the form of  [Technique] and a second that is used by the technique to execute the techniques because it contains the necessary preallocated memory and is known as a [Technique]Recipe.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"We can see an example of the difference between the two structures when considering an  implementation of compression with Gaussian matrices. In this implementation we wish to  have the user specify a compression dimension and size without having to know the dimension of the matrix the sketch is applied to. The Gaussian structure facilitates this by having  two fields n_rows  and n_cols with the default for both being zero. When the user then  constructs this structure the can specify the dimension and direction of the compression  by specifying the number of rows or columns they wish for the compression matrix to have. If the user wanted a Gaussian matrix with 3 rows they would call  Gaussian(n_rows = 3). We then turn this dimensional information into an usable compression matrix by using the complete_compressor function to form a GaussianRecipe. This  GaussianRecipe contains Fields n_rows = 3, n_cols set to be the number of rows in the compressor, and a Gaussian matrix of the size specified by n_rows and n_cols.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Once a [Technique]Recipe has been created, this data structure can then be used to  execute a particular technique. The command to execute each technique varies by the class  of techniques, as such we lay out the specifics for each type of techniques in the following  section.","category":"page"},{"location":"dev/design/#Technique-Types","page":"Design of Library","title":"Technique Types","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Overall, there are three top-level technique types: (1) Compressors, (2) Solvers, and  (3) Approximators, with the latter two also having additional sets of technique types used in the execution of the top-level techniques. We group the discussions of the technique  classes by top-level technique.","category":"page"},{"location":"dev/design/#Compressors","page":"Design of Library","title":"Compressors","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"When implementing a Compressor, RLinearAlgebra requires an mutable Compressor  structure, a mutable CompressorRecipe structure, a complete_compressor function, a  update_compressor! function, and for five input mul! functions (one for applying the  compressor to vectors, one for applying the adjoint of a compressor to a vector,  and two for applying the compressor to matrices). ","category":"page"},{"location":"dev/design/#Compressor-Structure","page":"Design of Library","title":"Compressor Structure","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Every compression technique needs a place to store user-controlled parameters.  This will be accomplished by the immutable Compressor structure.  We present an example structure used for the Sparse Sign technique.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"struct SparseSign <: Compressor\n    n_rows::Int64\n    n_cols::Int64\n    nnz::Int64\nend","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"You will first notice that n_rows and n_cols are fields present in the Compressor,  these fields allow for the user to specify either the number of rows or the number of  columns they wish the compressor to have. Both n_rows and n_cols are required for  every Compressor structure. Beyond those fields the technique will dictate the other  parameters that should be made available to the user. In addition to the structure, there  should be a constructor for the structure that accepts keyword inputs for each  field of the Compressor structure. For example in the SparseSign case we define,","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function SparseSign(;n_rows::Int64 = 0, n_cols::Int64 = 0, nnz::Int64 = 8)\n    # Partially construct the sparse sign datatype\n    return SparseSign(n_rows, n_cols, nnz)\nend","category":"page"},{"location":"dev/design/#CompressorRecipe-Structure","page":"Design of Library","title":"CompressorRecipe Structure","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"To form the compressor from the user-inputted information, we need information about the  linear system. Once this information is attained preallocations of the necessary memory can  be done. These preallocations are then stored in the CompressorRecipe structure. Because this structure has all of the preallocated memory for applying the compression technique it is this structure that can be applied to matrices and vectors. ","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"As example, we have included the CompressorRecipe for the sparse sign compressor. This structure importantly includes the size of the compressor in the n_rows and n_cols  fields","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct SparseSignRecipe <: CompressorRecipe\n    n_rows::Int64\n    n_cols::Int64\n    max_idx::Int64\n    nnz::Int64\n    scale::Float64\n    idxs::Vector{Int64}\n    signs::Vector{Bool}\nend","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Here we have the required n_rows and n_cols fields for all compressors. The  remaining fields are specific to the sparse sign compression technique. ","category":"page"},{"location":"dev/design/#complete_compressor","page":"Design of Library","title":"complete_compressor","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"To create the CompressorRecipe from linear system information and the user-controlled  parameters, we use the function complete_compressor(::Compressor, ::AbsractMatrix),  if vector information is required we can also define  complete_compressor(::Compressor, ::AbsractMatrix, ::AbstractVector).  An example of how this is done for the sparse sign case can be seen below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_compressor(sparse_info::SparseSign, A::AbstractMatrix)\n    n_rows = sparse_info.n_rows\n    n_cols = sparse_info.n_cols\n    # FInd the zero dimension and set it to be the dimension of A\n    if n_rows == 0 && n_cols == 0\n        # by default we will compress the row dimension to size 2\n        n_cols = size(A, 1)\n        n_rows = 2\n        # correct these sizes\n        initial_size = max(n_rows, n_cols)\n        sample_size = min(n_rows, n_cols)\n    elseif n_rows == 0 && n_cols > 0\n        # Assuming that if n_rows is not specified we compress column dimension\n         n_rows = size(A, 2)\n         # If the user specifies one size as nonzero that is the sample size\n         sample_size = n_cols\n         initial_size = n_rows\n    elseif n_rows > 0 && n_cols == 0\n        n_cols = size(A, 1)\n        sample_size = n_rows\n        initial_size = n_cols\n    else\n        if n_rows == size(A, 2)\n            initial_size = n_rows\n            sample_size = n_cols\n        elseif n_cols == size(A, 2)\n            initial_size = n_cols\n            sample_size == n_rows\n        else\n            @assert false \"Either you inputted row or column dimension must match \\\\\n            the column or row dimension of the matrix.\"\n        end\n    end\n\n    nnz = (sparse_info.nnz == 8) ? min(8, sample_size) : sparse_info.nnz\n    @assert nnz <= sample_size \"Number of non-zero indices, $nnz, must be less than \\\\ \n        compression dimension, $sample_size.\"\n    idxs = Vector{Int64}(undef, nnz * initial_size)\n    start = 1\n    for i in 1:initial_size\n        # every grouping of nnz entries corresponds to each row/column in sample\n        stop = start + nnz - 1\n        # Sample indices from the intial_size\n        @views sample!(\n            1:sample_size, \n            idxs[start:stop], \n            replace = false, \n            ordered = true\n        )\n        start = stop + 1\n    end\n    \n    # Store signs as a boolean to save memory\n    signs = bitrand(nnz * initial_size)\n    scale = 1 / sqrt(nnz)\n    \n    return SparseSignRecipe(n_rows, n_cols, sample_size, nnz, scale, idxs, signs)\nend","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The complete_compressor function assumes that if the user inputs only n_rows or n_cols  in the Compressor structure this is the desired compression dimension. If they input  neither, it creates a compressor with a compression dimension of two and  if the input both and neither is consistent with  a dimension of the inputted linear system it returns an error. Otherwise, it assumes the  inconsistent dimension is the compression dimension. Once the sizes of the compressor have  been determined it next allocates the memory necessary for storing the initial compressor and packages these allocations with the size information into the CompressorRecipe.","category":"page"},{"location":"dev/design/#update_compressor!","page":"Design of Library","title":"update_compressor!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"To generate a new version of the compressor we can call the function update_compressor!,  this function simply changes the random components of the CompressorRecipe. In the sparse  sign case this means updating the nonzero indices and the signs as can be seen in the  following example code.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function update_compressor!(\n                            S::SparseSignRecipe, \n                            A::AbstractMatrix, \n                            b::AbstractVector, \n                            x::AbstractVector\n                           )\n    # Sample_size will be the minimum of the two size dimensions of `S`\n    sample_size = min(S.n_rows, S.n_cols)\n    initial_size = max(S.n_rows, S.n_cols)\n    start = 1\n    for i in 1:sample_size\n        # every grouping of nnz entries corresponds to each row/column in sample\n        stop = start + S.nnz - 1\n        # Sample indices from the intial_size\n        @views sample!(\n            1:sample_size, \n            S.idxs[start:stop], \n            replace = false, \n            ordered = true\n        )\n        start = stop + 1\n    end\n    # There is no inplace update of bitrand and using sample is slower\n    S.signs .= bitrand(S.nnz * initial_size) \n    return\nend","category":"page"},{"location":"dev/design/#mul!","page":"Design of Library","title":"mul!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The last pieces of code that every compression technique requires are the mul! functions.  For these functions we follow the conventions laid out in the LinearAlgebra library where  there are five inputs (C, A, S, alpha, beta) and it outputs C = beta * C + alpha * A * S. The mul! functions that should be implemented are two for applying the compression matrix to vectors, one in standard orientation and one for when the adjoint of the compressor is  applied to the vector. Additionally, two mul! functions should be implemented for when  the compression matrix is applied to a matrix, one for when the compression matrix, S, is  applied from the left, i.e. AS, and one for when the compression matrix is applied from the  right, i.e. SA. ","category":"page"},{"location":"dev/design/#Solvers","page":"Design of Library","title":"Solvers","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A Solver technique is any technique that aims to find a vector x such that either  Ax = b or x = min_u A u - b_2^2. Solvers rely on compression techniques,  logging techniques, error techniques, and sub-solver techniques. We first discuss  implementation requirements for the sub-techniques and then discuss how we can use these  when creating a solver structure.","category":"page"},{"location":"dev/design/#Loggers","page":"Design of Library","title":"Loggers","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Loggers are structures with two goals (1) log a progress value produced by an error metric and (2) evaluate whether that error is sufficient for stopping. The user controlled inputs for a logging technique are contained in the Logger structure.","category":"page"},{"location":"dev/design/#Logger","page":"Design of Library","title":"Logger","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The Logger structure is where the user inputs any information required  to logging progress and stopping the method. The Logger is required to have a field for  max_it, threshold_info, and stopping_criterion. The max_it field is a field for the maximum number of iterations of the method. The stopping_criterion is a field that contains a function that returns a stopping decision based on the information in the  LoggerRecipe and the Tuple of information supplied by the user in the threshold_info  field. It is important to note that constructors for these techniques should have keyword  inputs with predefined defaults. We present an example of the Logger structure for a  BasicLogger below","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"struct BasicLogger <: Logger\n    max_it::Int64\n    collection_rate::Int64\n    threshold_info::Union{Float64, Tuple}\n    stopping_criterion::Function\nend","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Aside from the required parameters the BasicLogger also features a collection rate  parameter to allow the user to specify how often they wish for the LoggerRecipe to log  progress.","category":"page"},{"location":"dev/design/#LoggerRecipe","page":"Design of Library","title":"LoggerRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The LoggerRecipe will contain the user-controlled parameters from the Logger as well as  memory for storing the logged information. All LoggerRecipes  must contain a max_it field and a converged field, where the converged field is a  boolean indicating if the method has converged. An example of a LoggerRecipe is presented  below for the BasicLoggerRecipe.  This Logger has a vector for the history of the progress  metric, a field whose inclusion is strongly suggested. It also has record_location field  to keep track of where the next observed progress estimate should be placed depending  on the collection_rate.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct BasicLoggerRecipe{F} <: LoggerRecipe where F<:Function\n    max_it::Int64\n    err::Float64\n    threshold_info::Union{Float64, Tuple}\n    iteration::Int64\n    record_location::Int64\n    collection_rate::Int64\n    converged::Bool\n    stopping_criterion::F\n    hist::Vector{Float64}\nend","category":"page"},{"location":"dev/design/#complete_logger","page":"Design of Library","title":"complete_logger","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"As with the other techniques, complete_logger  takes a Logger data structure and  performs the appropriate allocations to generate a LoggerRecipe. An example of this  function for BasicLogger is presented below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_logger(logger::BasicLogger, A::AbstractMatrix)\n    # We will run for a number of iterations equal to 3 itmes the number of rows if maxit is\n    # not set\n    max_it = logger.max_it == 0 ? 3 * size(A, 1) : logger.max_it\n\n    max_collection = Int(ceil(max_it / logger.collection_rate))\n    # use one more than max it form collection\n    hist = zeros(max_collection + 1)\n    return BasicLoggerRecipe{typeof(logger.stopping_criterion)}(max_it,\n                                                                0.0,\n                                                                logger.threshold_info,\n                                                                1,\n                                                                1,\n                                                                logger.collection_rate,\n                                                                false,\n                                                                logger.stopping_criterion,\n                                                                hist\n                                                               )\nend","category":"page"},{"location":"dev/design/#update_logger!","page":"Design of Library","title":"update_logger!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"As with the compressors update_logger! performs an in-place update of the  LoggerRecipe using the inputted progress metric and iteration of the method. An example of  the update_logger! function for the BasicLoggerRecipe is included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function update_logger!(logger::BasicLoggerRecipe, err::Float64, iteration::Int64)\n    logger.iteration = iteration\n    logger.err = err\n    if rem(iteration, logger.collection_rate) == 0\n        logger.hist[logger.record_location] = err\n        logger.record_location += 1\n    end\n    # Always check max_it stopping criterion\n    # Compute in this way to avoid bounds error from searching in the max_it + 1 location\n    logger.converged = iteration <= logger.max_it ? logger.stopping_criterion(logger) : \n        false\n    return\n\nend","category":"page"},{"location":"dev/design/#Stopping-Functions","page":"Design of Library","title":"Stopping Functions","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"As was noted in the description of the required fields for the Logger the user should  have the opportunity to input a stopping function that should take the input of a  LoggerRecipe to which it updates the value of the converged field if stopping should  occur. An example implementation of function for threshold stopping, stop when progress  the metric falls below a particular threshold is presented below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function threshold_stop(log::LoggerRecipe)\n    return log.err < log.threshold_info\nend","category":"page"},{"location":"dev/design/#SolverErrors","page":"Design of Library","title":"SolverErrors","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"For computing the progress of a solver it is important to include implementations of  particular error techniques. These typically will be techniques like the residual or  compressed residual, but could be more complicated techniques like an estimate of backwards stability. ","category":"page"},{"location":"dev/design/#SolverError","page":"Design of Library","title":"SolverError","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a structure that holds user-controlled parameters for a progress estimation  technique. For basic techniques like the residual where no user-controlled parameters are  required this will simply be an empty structure. We have included an example of a  SolverError structure for the residual computations. It is important to note that  constructors for these techniques should have keyword inputs with predefined defaults.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"struct FullResidual <: SolverError\n\nend","category":"page"},{"location":"dev/design/#SolverErrorRecipe","page":"Design of Library","title":"SolverErrorRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This structure contains the user-controlled parameters from the SolverError as well  memory allocations of a size determined based on the linear system. An example for a  residual technique has been included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct FullResidualRecipe{V<:AbstractVector} <: SolverErrorRecipe\n    residual::V\nend","category":"page"},{"location":"dev/design/#complete_error","page":"Design of Library","title":"complete_error","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"To generate the SolverErrorRecipe from the information in the linear system and  SolverError we use the function complete_error. This function should be implemented to take the inputs of the SolverError, a matrixArepresenting the linear system, and a  vectorb` representing the constant vector of the linear system. An example of this  function for the residual error technique has been included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_error(error::FullResidual, A::AbstractMatrix, b::AbstractVector)\n    return FullResidualRecipe{typeof(b)}(zeros(size(b,1)))\nend","category":"page"},{"location":"dev/design/#compute_error","page":"Design of Library","title":"compute_error","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"To excute the technique we call the function compute_error with the inputs of the  SolverErrorRecipe, Solver, coefficient matrix A, and constant vector b. This  function then performs the necessary computations to return a single value indication of the progress of the solver. An example of this for the residual technique that returns the norm- squared of the residual is included below.  ","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function compute_error(\n        error::FullResidualRecipe, \n        solver::KaczmarzRecipe, \n        A::AbstractMatrix, \n        b::AbstractVector\n    )::Float64\n    copyto!(error.residual, b)\n    mul!(error.residual, A, solver.solution_vec, -1.0, 1.0)\n    return dot(error.residual, error.residual)\nend","category":"page"},{"location":"dev/design/#SubSolvers","page":"Design of Library","title":"SubSolvers","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Although, randomized solvers are used to solve a larger linear system. They typically rely on using compressors to generate a compressed linear system that can be easily solved  using standard techniques. The specifics of the 'standard' techniques is typically not  specified. For instance, if the compressed system is a least squares problem one could solve this system with a QR algorithm or LSQR and potentially get vastly different performance results. To allow the user to experiment with different techniques for solving the  compressed linear system, we introduce the SubSolver data structures.","category":"page"},{"location":"dev/design/#SubSolver","page":"Design of Library","title":"SubSolver","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a data structure that allows the user to specify how they wish to solve the compressed linear systems generated in the solving process. When the solver type is a direct method it is possible for there to be no user inputs in this data structure. For iterative methods there could be extensive user-controlled parameters included in this structure. For  example, for a LSQR SubSolver the user could input the maximum of iterations, a  preconditioner type, or stopping thresholds. We have included an example of the SubSolver structure for the LQSolver, which is an approach for solving undetermined linear systems  and does not have any user-controlled parameters associated with it. It is important to note  that constructors for these techniques should have keyword inputs with predefined defaults.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"struct LQSolver <: SubSolver\n\nend","category":"page"},{"location":"dev/design/#SubSolverRecipe","page":"Design of Library","title":"SubSolverRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a data structure that contains the preallocated memory necessary for solving the  linear system. ","category":"page"},{"location":"dev/design/#complete_solver","page":"Design of Library","title":"complete_solver","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a function that takes a SubSolver and the linear system as input and uses these  inputs to output a SubSolverRecipe.","category":"page"},{"location":"dev/design/#update*sub*solver","page":"Design of Library","title":"updatesubsolver","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a function that updates the preallocated memory in the SubSolverRecipe with  the relevant information for the new compressed linear system. ","category":"page"},{"location":"dev/design/#ldiv!","page":"Design of Library","title":"ldiv!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A function that uses the SubSolverRecipe to solve the compressed linear system.","category":"page"},{"location":"dev/design/#Solvers-2","page":"Design of Library","title":"Solvers","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"With an understanding of all of these sub techniques, we can discuss how to use these  methods to implement a Solver technique. The first data structure required for a solver is  the Solver structure.","category":"page"},{"location":"dev/design/#Solver","page":"Design of Library","title":"Solver","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The Solver data structure is a structure where the user can input values of user-controlled  parameters specific to a particular type of solver. This typically involves the user inputting the structures associated with their desired Compressor, Logger, Error, and  SubSolver, as well as any parameters like step-sizes associated with the particular  randomized solver they are using. As an example, we have included the Solver structure  associated with the Kaczmarz solver. It is important to note that constructors for these techniques should have keyword inputs with predefined defaults.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct Kaczmarz <: Solver \n    alpha::Float64\n    S::Compressor\n    log::Logger\n    error::SolverError\n    sub_solver::SubSolver\nend","category":"page"},{"location":"dev/design/#SolverRecipe","page":"Design of Library","title":"SolverRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The SolverRecipe will contain all the preallocated memory associate with the solver, the  solver specific user-controlled parameters, and all recipes associated with the  sub-techniques included in the Solver structure. We have included an example for the  KaczmarzRecipe below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct KaczmarzRecipe{T<:Number, \n                              V<:AbstractVector,\n                              M<:AbstractMatrix, \n                              VV<:SubArray,\n                              MV<:SubArray,\n                              C<:CompressorRecipe, \n                              L<:LoggerRecipe,\n                              E<:SolverErrorRecipe, \n                              B<:SubSolverRecipe\n                             } <: SolverRecipe\n    S::C\n    log::L\n    error::E\n    sub_solver::B\n    alpha::Float64\n    compressed_mat::M\n    compressed_vec::V\n    solution_vec::V\n    update_vec::V\n    mat_view::MV\n    vec_view::VV\nend","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The first four fields are associated with the sub-techniques for the solver. The alpha  field is a user defined value and the remaining fields are preallocated space for storing the result of the compression and the solution vector.","category":"page"},{"location":"dev/design/#complete_solver-2","page":"Design of Library","title":"complete_solver","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The complete_solver function performs the necessary computations and allocations to change a Solver structure into a SolverRecipe. In the example code below for a Kaczmarz solver these computations include running complete_[technique] for the compression, logging,  error, and sub solver techniques, as well as allocating memory for storing the compressed  matrix and compressed vector, the solution vector, and update vector. The views  allocated by this function should be replicated in other multi-compression solver structures  to allow for varying sizes of the compression matrix.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_solver(\n        solver::Kaczmarz, \n        x::AbstractVector, \n        A::AbstractMatrix, \n        b::AbstractVector\n    )\n    # Dimension checking will be performed in the complete_compressor\n    compressor = complete_compressor(solver.S, A, b)\n    logger = complete_logger(solver.log, A, b)\n    error = complete_error(solver.error, A, b) \n    # Check that required fields are in the types\n    @assert isdefined(error, :residual) \"ErrorRecipe $(typeof(error)) does not contain the\\ \nfield 'residual' and is not valid for a kaczmarz solver.\"\n    @assert isdefined(logger, :converged) \"LoggerRecipe $(typeof(logger)) does not contain\\\n the field 'converged' and is not valid for a kaczmarz solver.\"\n    # Assuming that max_it is defined in the logger\n    alpha::Float64 = solver.alpha \n    # We assume the user is using compressors to only decrease dimension\n    n_rows::Int64 = compressor.n_rows\n    n_cols::Int64 = compressor.n_cols\n    sample_size = n_rows\n    initial_size = n_cols\n    rows_a, cols_a = size(A)\n    # Allocate the information in the buffer using the types of A and b\n    compressed_mat = typeof(A)(undef, sample_size, cols_a)\n    compressed_vec = typeof(b)(undef, sample_size) \n    # Since sub_solver is applied to compressed matrices use here\n    sub_solver = complete_sub_solver(solver.sub_solver, compressed_mat, compressed_vec)\n    mat_view = view(compressed_mat, 1:sample_size, :)\n    vec_view = view(compressed_vec, 1:sample_size)\n    solution_vec = x\n    update_vec = typeof(x)(undef, cols_a)\n    return KaczmarzRecipe{eltype(A), \n                          typeof(b), \n                          typeof(A), \n                          typeof(vec_view),\n                          typeof(mat_view),\n                          typeof(compressor),\n                          typeof(logger),\n                          typeof(error),\n                          typeof(sub_solver)\n                         }(compressor, \n                           logger, \n                           error,\n                           sub_solver,\n                           alpha,\n                           compressed_mat,\n                           compressed_vec,\n                           solution_vec,\n                           update_vec,\n                           mat_view,\n                           vec_view\n                          )\nend","category":"page"},{"location":"dev/design/#rsolve!","page":"Design of Library","title":"rsolve!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Every implementation of a Solver technique should include a rsolve! function that performs in-place updates to a solution vector and SolverRecipe. An example of such an  implementation for a Kaczmarz solver is included below. To the greatest extent possible the implementation should be written in a way that avoids new memory allocations. This means making use in-place update functions like mul! or ldiv! rather than * or \\.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function rsolve!(\n        solver::KaczmarzRecipe, \n        x::AbstractVector, \n        A::AbstractMatrix, \n        b::AbstractVector\n    )\n    solver.solution_vec = x\n    err = 0.0\n    for i in 1:solver.log.max_it\n        err = compute_error(solver.error, solver, A, b)\n        # Update log adds value of err to log and checks stopping\n        update_logger!(solver.log, err, i)\n        if solver.log.converged\n            return solver.solution_vec, solver.log\n        end\n\n        # generate a new version of the compression matrix\n        update_compressor!(solver.S, A, b, x)\n        # based on size of new compressor update views of matrix\n        # this should not result in new allocations\n        rows_s, cols_s =  size(solver.S)\n        solver.mat_view = view(solver.compressed_mat, 1:rows_s, :)\n        solver.vec_view = view(solver.compressed_vec, 1:rows_s)\n        # compress the matrix and constant vector\n        mul!(solver.mat_view, solver.S, A)\n        mul!(solver.vec_view, solver.S, b)\n        # Compute the block residual\n        mul!(solver.vec_view, solver.mat_view, solver.solution_vec, -1.0, 1.0)\n        # sub-solver needs to designed for new compressed matrix\n        update_sub_solver!(solver.sub_solver, solver.mat_view)\n        # use sub-solver to find update the solution\n        sub_solve!(solver.update_vec, solver.sub_solver, solver.vec_view)\n        # Using over-relaxation parameter, alpha, to update solution\n        solver.solution_vec .+= solver.alpha .* solver.update_vec \n    end\n\n    return solver.solution_vec, solver.log\nend","category":"page"},{"location":"dev/design/#Approximators","page":"Design of Library","title":"Approximators","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"Aside from solving linear systems, Randomized Linear Algebra has also been proven to be extremely useful for generating low rank approximations to linear systems. These low-rank  approximations can then be used to solve linear systems or perform more efficient matrix-matrix multiplications. The main types of low rank approximation methods implemented in this version of the library are random range finder techniques like random SVD, CUR  type methods, and Nystrom Methods. Low rank approximations can be formed simply by calling  the rapproximate function. Once a Low-rank approximation has been formed it can then be  applied either as a preconditioner by calling the ldiv! function or multiplied by calling  the mul! function. Each of the low rank approximation technique requires the implementation of the following data structures and functions.","category":"page"},{"location":"dev/design/#Approximator","page":"Design of Library","title":"Approximator","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This is a data structure that contains the user defined parameters for an approximator. An  example of this structure for the RangeFinder decomposition is included below. In the case  of the randomized range finder the only real user controlled parameter is the sketch size, which is controlled by the Compressor. It should be noted that constructors for these  structures should be based around keyword inputs with preset defaults. ","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct RangeFinder <: Approximator\n    S::Compressor\n    error::ErrorMethod\nend","category":"page"},{"location":"dev/design/#ApproximatorRecipe","page":"Design of Library","title":"ApproximatorRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"This a data structure that contains preallocated memory and the user-controlled parameters  for a specific approximation method. An example of this data structure for a RangeFinder  decomposition is included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct RangeFinderRecipe <: ApproximatorRecipe\n    S::CompressorRecipe\n    error::ErrorMethodRecipe\n    compressed_mat::AbstractMatrix\n    approx_range::AbstractMatrix\nend","category":"page"},{"location":"dev/design/#complete_approximator","page":"Design of Library","title":"complete_approximator","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The complete_approximator function takes the matrix A and the  Approximator data structure to output an ApproximatorRecipe with properly allocated  storage for the low-rank approximation. An example of this function for the  RangeFinderRecipe is included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_approximator(approx::RangeFinder, A::AbstractMatrix)\n    S = complete_compressor(approx.S, A)\n    err = complete_error(approx.error, A)\n    s_rows, s_cols = size(S)\n    a_rows, a_cols = size(A)\n    compressed_mat = Matrix{eltype(A)}(undef, a_rows, s_cols)\n    approx_range = Matrix{eltype(A)}(undef, a_rows, s_cols) \n    return RangeFinderRecipe(S, err, compressed_mat, approx_range)\nend","category":"page"},{"location":"dev/design/#rapproximate!","page":"Design of Library","title":"rapproximate!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A function that returns an ApproximatorRecipe and approximation error value for a particular approximation method. The returned ApproximatorRecipe can then be used for  matrix multiplication or preconditioning through the use of the mul! and ldiv! functions respectively. An example of this function for the RangeFinderRecipe is included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function r_approximate!(\n    approximator::RangeFinderRecipe\n    A::AbstractMatrix\n)\n    m, n = size(A)\n    update_compressor!(aproximator.S)\n    # compuress the matrix\n    mul!(compressed_mat, A, aproximator.S)\n    # Array is required to compute the skinny qr\n    approximator.approx_range .= Array(qr(compressed_mat).Q)\n    err = compute_error(aproximator.error, A)\n    return approximator, error\nend","category":"page"},{"location":"dev/design/#ldiv!-2","page":"Design of Library","title":"ldiv!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A function that solves the system Mx = b for x where M is a low rank approximation  matrix. This is useful for preconditioning linear systems. When there is no obvious way to use the low rank approximation to solve this system the implementation will be the same as the implementation for mul!.","category":"page"},{"location":"dev/design/#mul!-2","page":"Design of Library","title":"mul!","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A function that multiplies a low rank approximation with a matrix. This should be  implemented as the five input mul! function. For these functions we follow the conventions  laid out in the LinearAlgebra library where there are five inputs (C, A, S, alpha, beta) and  it outputs C = beta * C + alpha * A * S.","category":"page"},{"location":"dev/design/#Approximation-Error","page":"Design of Library","title":"Approximation Error","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"For the Approximators an important sub-techniques are those that verify the accuracy of a particular approximation. These methods can be exact, as in the case of computing A - QQA_F, where Q is a row-space approximator or approximate such as the  AS - QQAS_F where S is a Gaussian matrix with 10 column vectors.","category":"page"},{"location":"dev/design/#ApproximatorError","page":"Design of Library","title":"ApproximatorError","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The ApproximatorError data structure is a data structure that takes the user controlled  parameters for a method that computes the approximation error, e.g A - QQA for a  particular approximation method. In cases where this error is an exact approximation no  user-controlled parameters may be needed and the ApproximatorError can be implemented as  an empty data structure. If user-controlled parameters are necessary then constructors should be implemented that take in keyword arguments with defaults. We have included an  example data structure for a method that computes the projected error, A - QQA, below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct ProjectedError <: ApproximatorError\n\nend\n","category":"page"},{"location":"dev/design/#ApproximatorErrorRecipe","page":"Design of Library","title":"ApproximatorErrorRecipe","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"An ApproximatorErrorRecipe contains the user-controlled parameters and preallocated memory  for a method that computes the approximation error, e.g A - QQ'A for a particular  approximation method.  ","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"mutable struct ProjectedErrorRecipe{T, M{T}} <: ApproximatorErrorRecipe \n    where M <: AbstractMatrix\n    error::Float64\n    large_buff_mat::M\n    small_buffer_mat::M\nend","category":"page"},{"location":"dev/design/#complete_error-2","page":"Design of Library","title":"complete_error","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"The complete_error function takes the information from a ApproximatorError and an AbstractMatrix to create an ApproximatorErrorRecipe. An example for the  ProjectedError structure is included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function complete_error(error::ProjectedError, S::CompressorRecipe, A::AbstractMatrix)\n    row_s, col_s = size(S)\n    row_a, col_a = size(A)\n    T = eltype(A)\n    M = Matrix{T}\n    small_buffer_mat = M(undef, col_s, col_a) \n    large_buffer_mat = M(undef, row, col_a) \n    return ProjectedErrorRecipe{T, M}(0.0, large_buffer_mat, small_buffer_mat)\nend","category":"page"},{"location":"dev/design/#compute_error-2","page":"Design of Library","title":"compute_error","text":"","category":"section"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"A function that computes the error of a particular approximation method with respect to the  matrix A for a particular approximation technique. An example for ProjectedError is  included below.","category":"page"},{"location":"dev/design/","page":"Design of Library","title":"Design of Library","text":"function compute_error(\n        error::ProjectedErrorRecipe,\n        approximator::RandRangeFinderRecipe,\n        A::AbstractMatrix\n    )\n    mul!(error.small_buffer_mat, approximator.row_space', A)\n    mul!(error.large_buffer_mat, approximator.row_space, error.small_buffer_mat)\n    error.large_buffer_mat .-= A\n    error.error = norm(error.large_buffer_mat)\n    return error.error\nend","category":"page"},{"location":"dev/style_guide/#Style-Guide","page":"Style Guide","title":"Style Guide","text":"","category":"section"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"Pages=[\"styleguide.md\"]","category":"page"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"When writing code for RLinearAlgebra.jl we expect the code to be written in accordance  with the BLUE style.","category":"page"},{"location":"dev/style_guide/#Documentation","page":"Style Guide","title":"Documentation","text":"","category":"section"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"This section describes the writing style that should be used when writing documentation for  RLinearAlgebra.jl. Many of these ideas for these suggestions come from JUMP.  Overall when documenting the code one should follow these recommendations:     - Be concise     - Prefer lists over long sentences     - Use numbers when describing an ordered set of ideas     - Use bullets when these is no specific order","category":"page"},{"location":"dev/style_guide/#Docstrings","page":"Style Guide","title":"Docstrings","text":"","category":"section"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"- Every new **function** and **data structure** needs to have a docstring\n- Use properly punctuated complete sentences","category":"page"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"Below, we provide an example of a function docstring and a data structure docstring.","category":"page"},{"location":"dev/style_guide/#Function-Docstring","page":"Style Guide","title":"Function Docstring","text":"","category":"section"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    myFunction(args; kwargs...)\n    \nA couple of sentences describing the function. These sentences should describe what inputs \nare required and what is output by the function.\n\n### Arguments\n- `arg1`, description of arg 1\n\n### Outputs\nThe result of calling the function. This should be either the data structure that is \nmodified or what is returned.\n\nA citation from the package DocumenterCitations.\n\"\"\"\n","category":"page"},{"location":"dev/style_guide/#Data-Structure-Docstring","page":"Style Guide","title":"Data Structure Docstring","text":"","category":"section"},{"location":"dev/style_guide/","page":"Style Guide","title":"Style Guide","text":"\"\"\"\n    YourStructure <: YourStructuresSuperType\n\nA brief sentence describing the purpose of the structure.\n\nA citation in MLA format if the function comes from another author's work.\n\n### Fields\n- `S::FieldType`, brief description of field purpose\n\nInclude a sentence or two describing how the constructors work. Please be sure to include \nthe default values of the constructor.\n\"\"\"\n","category":"page"},{"location":"api/sub_solvers/#SubSolvers","page":"SubSolvers","title":"SubSolvers","text":"","category":"section"},{"location":"api/sub_solvers/","page":"SubSolvers","title":"SubSolvers","text":"Pages = [\"sub_solvers.md\"]","category":"page"},{"location":"api/sub_solvers/#Abstract-Types","page":"SubSolvers","title":"Abstract Types","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.SubSolver","page":"SubSolvers","title":"RLinearAlgebra.SubSolver","text":"SubSolver\n\nAn abstract supertype for structures that contain user-controlled parameters  for a linear solver applied to compressed matrix blocks. \n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.SubSolverRecipe","page":"SubSolvers","title":"RLinearAlgebra.SubSolverRecipe","text":"SubSolverRecipe\n\nAn abstract supertype for structures that contain user-controlled parameters, linear system specific parameters and preallocated memory for a linear solver applied to compressed matrix blocks. \n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#SubSolver-Structures","page":"SubSolvers","title":"SubSolver Structures","text":"","category":"section"},{"location":"api/sub_solvers/#Exported-Functions","page":"SubSolvers","title":"Exported Functions","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.complete_sub_solver","page":"SubSolvers","title":"RLinearAlgebra.complete_sub_solver","text":"complete_sub_solver(solver::SubSolver, A::AbstractMatrix)\n\nA function that takes the user-controlled parameters from the SubSolver data structure      and the matrix A and uses this information to create the SubSolverRecipe.\n\nArguments\n\nsolver::SubSolver, the SubSolver structure that contains the user controlled    parameters.\nA::AbstractMatrix, the matrix that the SubSolverRecipe will contain.\n\nOutputs\n\nWill return a SubSolverRecipe that can be applied to a vector.\n\n\n\n\n\n","category":"function"},{"location":"api/sub_solvers/#RLinearAlgebra.update_sub_solver!","page":"SubSolvers","title":"RLinearAlgebra.update_sub_solver!","text":"update_sub_solver!(solver::SubSolverRecipe, A::AbstractMatrix)\n\nA function that updates the structure of SubSolverRecipe with information from the matrix     A. These updates typically require preforming decompositons or updating pointers.\n\nArguments\n\nsolver::SubSolverRecipe, the SubSolverRecipe structure that can be applied    to a matrix or vector.\nA::AbstractMatrix, the matrix that the SubSolverRecipe will contain.\n\nOutputs\n\nModifies the SubSolverRecipe in place and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#Compressors","page":"Compressors","title":"Compressors","text":"","category":"section"},{"location":"api/compressors/","page":"Compressors","title":"Compressors","text":"Pages = [\"compressors.md\"]","category":"page"},{"location":"api/compressors/#Abstract-Types","page":"Compressors","title":"Abstract Types","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.Compressor","page":"Compressors","title":"RLinearAlgebra.Compressor","text":"Compressor\n\nAn abstract supertype for structures that contain user-controlled parameters corresponding to techniques that compress a matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CompressorRecipe","page":"Compressors","title":"RLinearAlgebra.CompressorRecipe","text":"CompressorRecipe\n\nAn abstract supertype for structures that contain both the user-controlled parameters in the Compressor and the memory allocations necessary for applying the  compression technique to a particular linear system.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CompressorAdjoint","page":"Compressors","title":"RLinearAlgebra.CompressorAdjoint","text":"CompressorAdjoint{S<:CompressorRecipe} <: CompressorRecipe\n\nA structure for the adjoint of a compression recipe.\n\nFields\n\nParent::CompressorRecipe, the CompressorRecipe the adjoint is being applied to..\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#Compressor-Structures","page":"Compressors","title":"Compressor Structures","text":"","category":"section"},{"location":"api/compressors/#Exported-Functions","page":"Compressors","title":"Exported  Functions","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.complete_compressor","page":"Compressors","title":"RLinearAlgebra.complete_compressor","text":"complete_compressor(compressor::Compressor, A::AbstractMatrix, b::AbstractVector)\n\nA function that uses the information in the Compressor, the matrix A,  and the constrant vector b to form a CompressorRecipe that can then be multiplied with matrices and vectors.\n\nArguments\n\ncompress::Compressor, a compressor object.\nA::AbstractMatrix, a matrix that the returned CompressorRecipe may be applied to.\nb::AbstractVector, a vector that the returned CompressorRecipe may be applied to.\n\nOutputs\n\nA CompressorRecipe that can be applied to matrices and vectors through the use of the    multiplication functions.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.update_compressor!","page":"Compressors","title":"RLinearAlgebra.update_compressor!","text":"update_compressor!(S::CompressorRecipe, A::AbstractMatrix, b::AbstractVector)\n\nA function that updates a CompressorRecipe with new random components, possibly based on information contained in A::AbstractMatrix and b::AbstractMatrix.\n\nArguments\n\nS::CompressorRecipe, A preallocated CompressorRecipe.\nA::AbstractMatrix, a matrix that could be used to update the compressor.\nb::AbstractVector, a vector that could be used to update the compressor.\n\nOutputs\n\nWill generate an updated version of S based on the information obtained from A, b.   For some compression techniques that are data oblivious this simply means generating new   random entries in S.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#Internal-Functions","page":"Compressors","title":"Internal Functions","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.left_mat_mul_dimcheck","page":"Compressors","title":"RLinearAlgebra.left_mat_mul_dimcheck","text":"left_mat_mul_dimcheck(C::AbstractMatrix, S::CompressorRecipe, A::AbstractMatrix)\n\nFunction to test the dimensions of the CompressorRecipe and matrices when applying a      compression matrix to a matrix from the left.\n\nArguments\n\nC::AbstractMatrix, A matrix where the output will be stored.\nS::CompressorRecipe, The compression matrix information.\nA::AbstractMatrix, The matrix the compressor is being applied to from the left.\n\nOutputs\n\nWill assert an error if one of the relevant dimensions of the three inputs is incompatible    with the others.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.right_mat_mul_dimcheck","page":"Compressors","title":"RLinearAlgebra.right_mat_mul_dimcheck","text":"right_mat_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix), S::CompressorRecipe\n\nFunction to test the dimensions of the CompressorRecipe and matrices when applying a      compression matrix to a matrix from the right. \n\nArguments\n\nC::AbstractMatrix, A matrix where the output will be stored.\nS::CompressorRecipe, The compression matrix information.\nA::AbstractMatrix, The matrix the compressor is being applied to from the right.\n\nOutputs\n\nWill assert an error if one of the relevant dimensions of the three inputs is incompatible   with the others.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.vec_mul_dimcheck","page":"Compressors","title":"RLinearAlgebra.vec_mul_dimcheck","text":"vec_mul_dimcheck(C::AbstractMatrix, S::CompressorRecipe, A::AbstractMatrix)\n\nFunction to test the dimensions of the CompressorRecipe and matrices when applying a      compression matrix to a vector.\n\nArguments\n\nx::AbstractVector, A vector where the output will be stored.\nS::CompressorRecipe, The compression matrix information.\nA::AbstractVector, The vector that the compressor is being applied to.\n\nOutputs\n\nWill assert an error if one of the relevant dimensions of the three inputs is incompatible    with the others.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#Loggers","page":"Loggers","title":"Loggers","text":"","category":"section"},{"location":"api/loggers/","page":"Loggers","title":"Loggers","text":"Pages = [\"loggers.md\"]","category":"page"},{"location":"api/loggers/#Abstract-Types","page":"Loggers","title":"Abstract Types","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.Logger","page":"Loggers","title":"RLinearAlgebra.Logger","text":"Logger\n\nAn abstract supertype for structures that contain user-controlled parameters for a logger,  which has the goal of recording the progress of a linear solver and evaluating convergence.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#RLinearAlgebra.LoggerRecipe","page":"Loggers","title":"RLinearAlgebra.LoggerRecipe","text":"LoggerRecipe\n\nAn abstract supertype for structures that contain user-controlled parameters and preallocated memory for a logger, which has the goal of recording the progress of a linear  solver and evaluating convergence.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#Logger-Structures","page":"Loggers","title":"Logger Structures","text":"","category":"section"},{"location":"api/loggers/#Exported-Functions","page":"Loggers","title":"Exported Functions","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.complete_logger","page":"Loggers","title":"RLinearAlgebra.complete_logger","text":"complete_logger(logger::Logger, A::AbstractMatrix, b::AbstractVector)\n\nA function that combines the user-controlled information contained in the Logger,      the matrix A, and vector b. to produce a logger recipe.\n\nArguments\n\nlogger::Logger, the Logger data structure containing user-controlled parameters.\nA::AbstractMatrix, the matrix in the linear system.\nb::AbstractVector, the constant vector in the linear system.\n\nOutputs\n\nReturns a LoggerRecipe with appropiate parameter and memory allocations.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.update_logger!","page":"Loggers","title":"RLinearAlgebra.update_logger!","text":"update_logger!(logger::LoggerRecipe, err::Float64, iteration::Int64)\n\nA function that updates the history and convergence information in the logger recipe.\n\nArguments\n\nloggger::LoggerRecipe, the LoggerRecipe being updated.\nerr::Float64, the value of the progress estimator.\niteration::Int64, the iteration of the linear solver.\n\nOutputs\n\nPerforms an inplace update to the history and convergence information contained in the    LoggerRecipe.\n\n\n\n\n\n","category":"function"},{"location":"dev/checklists/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"dev/checklists/","page":"Overview","title":"Overview","text":"The purpose of this page is to maintain checklists of tasks to complete when adding new  methods to the library. These checklists are organized by method.","category":"page"},{"location":"dev/checklists/#Create-issue-and-use-it!","page":"Overview","title":"Create issue and use it!","text":"","category":"section"},{"location":"dev/checklists/","page":"Overview","title":"Overview","text":"Please add a brief introduction when you create an issue. After the introduction, copy and paste the corresponding checklist.  You can check the  boxes after you finish each steps, to help you contribute smoothly!","category":"page"},{"location":"dev/checklists/","page":"Overview","title":"Overview","text":"For example, If I want to add a moving_average logging method to the package, I will create an issue as follows:","category":"page"},{"location":"dev/checklists/","page":"Overview","title":"Overview","text":"# Introduction\nAdd the moving average method for both full and sketching residual. For more details, please see [the paper](https://arxiv.org/abs/2208.04989).\n# Checklist \n## Implementation\n1. Method's core codes (`src/Solvers/Loggers`):\n    - [ ] Create a file in the directory `src/Solvers/Loggers`. For example, `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `Logger` struct with `max_it`, `collection_rate`, `threshold_info`, `stopping_criterion`, any other method-needed parameters, and argument validations to check invalid inputs. For example, `BasicLogger<:Logger`.\n    - [ ] Create a constructor with keyword default values for your `Logger` struct. For example, \n    ```\n        BasicLogger(;\n            max_it = 0, \n            collection_rate = 1, \n            threshold = 0.0,\n            stopping_criterion = threshold_stop \n        ) = BasicLogger(max_it, collection_rate, threshold, stopping_criterion)\n    ```\n    - [ ] Add documentation for this `Logger` struct, with mainly 5 parts: brief introduction, fields introduction, constructor and its keywords, what the constructor returns, and what the argument validations throw. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `LoggerRecipe` struct that uses the parameters from the `Logger` struct to preallocate memory. For example, `BasicLoggerRecipe{F<:Function} <: LoggerRecipe`.\n    - [ ] Create a `complete_logger` function that takes the `logger` struct as an input, and returns the `LoggerRecipe` struct you defined last step. For example, `complete_logger(logger::BasicLogger)`.\n    - [ ] Add documentation for this `LoggerRecipe` struct, with mainly 2 parts: brief introduction, fields introduction. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `update_logger!` function to log the errors as the iteration goes on, and stop the logging with convergence status or the maximum iteration limit. For example, \n    ```\n        update_logger!(logger::BasicLoggerRecipe, error::Float64, iteration::Int64)\n    ```\n    - [ ] Create a `reset_logger!` function to clean the history log information after convergence or exceed the maximum iteration. For example, `reset_logger!(logger::BasicLoggerRecipe)`.\n    - [ ] Create a `threshold_stop` function as the convergent stopping criterion designed for your `Logger` struct. For example, `threshold_stop(log::BasicLoggerRecipe)`\n    - [ ] Add documentation for this `threshold_stop` function, with mainly 3 parts: brief introduction, arguments introduction, and returns. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] **Optional**: If you have any helper functions that needed for your implementation, please implement them in a folder at `src/Solvers/Loggers`.\n2. Package structure cooperation (`src/Solvers/Loggers.jl`, `src/RLinearAlgebra.jl`, `src/refs.bib`):  \n    - [ ] Add an include(\"Loggers/[YOURFILE]\") at bottom of the page, `src/Solvers/Loggers.jl`.\n    - [ ] Add import statements to `src/RLinearAlgebra.jl` with any functions from other packages that you use.\n    - [ ] Export your `Logger`, `LoggerRecipe`, any structs and functions you needed for your logger method to work in `src/RLinearAlgebra.jl`.\n    - [ ] Add your `Logger`, `LoggerRecipe`, needed structs and functions to `docs/src/api.loggers.md`, under the appropriate heading.\n    - [ ] If there are any new-added references, please add in `src/refs.bib`.\n3. Tests (`test/Solvers/Loggers`):\n    - [ ] Add a procedural test to `test/Solvers/Loggers`. Be sure to check that the functions work as intended and all warnings/assertions are displayed. For example, `test/Solvers/Loggers/basic_logger.jl`.\n    - [ ] After finish implementing, you can goes to the julia's package environment by type `]` in the julia command line and run `test` to test whether you can pass all the tests.\n\n## Pull request\n- [ ] Give a specific title to pull request.\n- [ ] Lay out the features added to the pull request.\n- [ ] Tag two people to review your pull request.\n- [ ] **Optional**: If possible, please also add Copilot as a reviewer and choose to adopt its suggestions if reasonable.","category":"page"},{"location":"dev/checklists/","page":"Overview","title":"Overview","text":"Note that, the checklist is copied from Loggers","category":"page"},{"location":"api/approximators/#Approximators","page":"Approximators Overview","title":"Approximators","text":"","category":"section"},{"location":"api/approximators/","page":"Approximators Overview","title":"Approximators Overview","text":"Pages = [\"approximators.md\"]","category":"page"},{"location":"api/approximators/#Abstract-Types","page":"Approximators Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.Approximator","page":"Approximators Overview","title":"RLinearAlgebra.Approximator","text":"Approximator \n\nAn abstract supertype for structures that store user-controlled parameters corresponding to  technqiues that form low-rank approximations of the matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.ApproximatorRecipe","page":"Approximators Overview","title":"RLinearAlgebra.ApproximatorRecipe","text":"ApproximatorRecipe\n\nAn abstract supertype for structures that store user-controlled parameters, linear system dependent parameters and preallocated memory corresponding to techniques that form low-rank  approximations of the matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.ApproximatorAdjoint","page":"Approximators Overview","title":"RLinearAlgebra.ApproximatorAdjoint","text":"ApproximatorAdjoint{S<:ApproximatorRecipe} <: ApproximatorRecipe\n\nA structure for the adjoint of a approximator recipe.\n\nFields\n\n-Parent::ApproximatorRecipe, the approximator that we compute the adjoint of.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#Approximator-Structures","page":"Approximators Overview","title":"Approximator Structures","text":"","category":"section"},{"location":"api/approximators/#Exported-Functions","page":"Approximators Overview","title":"Exported Functions","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.rapproximate","page":"Approximators Overview","title":"RLinearAlgebra.rapproximate","text":"rapproximate(approximator::Approximator, A::AbstractMatrix)\n\nA function that computes a Low-Rank approximation of the matrix A using the information      in the provided Approximator data structure.\n\nArguments\n\napproximator::Approximator, an approximation technique for computing a low-rank    approximation of the matrix A.\nA::AbstractMatrix, the matrix being approximated.\n\nOutputs\n\nAn ApproximatorRecipe containing a low rank approximation of the matrix A.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rapproximate!","page":"Approximators Overview","title":"RLinearAlgebra.rapproximate!","text":"rapproximate!(approximator::ApproximatorRecipe, A::AbstractMatrix)\n\nA function that computes a Low-Rank approximation of the matrix A using the information      in the provided ApproximatorRecipe data structure.\n\nArguments\n\napproximator::ApproximatorRecipe, a data structure for storing the low rank    approximation to the matrix A.\nA::AbstractMatrix, the matrix being approximated.\n\nOutputs\n\nPerforms an inplace update of the ApproximatorRecipe.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.complete_approximator","page":"Approximators Overview","title":"RLinearAlgebra.complete_approximator","text":"complete_approximator(approximator::Approximator, A::AbstractMatrix)\n\nA function that uses information in the matrix A and user-controlled parameters in the      Approximator to form an ApproximatorRecipe with appropiate memory allocations.\n\nArguments\n\napproximator::Approximator, a data structure containing the user-controlled parameters   relating to a particular low rank approximation.\n\n-A::AbstractMatrix, a matrix that we wish to approximate.\n\nOutputs\n\nReturns an ApproximatorRecipe with memory preallocated for forming and storing   the desired low rank approximation.\n\n\n\n\n\n","category":"function"},{"location":"dev/contributing/#Contributing","page":"Contributing Overview","title":"Contributing","text":"","category":"section"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"Pages=[\"contributing.md\"]","category":"page"},{"location":"dev/contributing/#Improve-the-documentation","page":"Contributing Overview","title":"Improve the documentation","text":"","category":"section"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"If you have ever been reading the documentation and been unsure about a description or      instruction, the documentation can be improved. Since you are the person finding this       gap in the documentation, you are also the person in the best position to fix it.","category":"page"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"The documentation is written in Markdown and built using      Documenter.jl.      The source code for all the docs is      here. ","category":"page"},{"location":"dev/contributing/#Bug-Reports","page":"Contributing Overview","title":"Bug Reports","text":"","category":"section"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"If you find a bug in our software we would love to know about it. You can make an issue  relating to a bug report here. ","category":"page"},{"location":"dev/contributing/#Feature-Requests","page":"Contributing Overview","title":"Feature Requests","text":"","category":"section"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"Have a new method that you think would be a valuable addition to the package?      Make a feature request      and let us know about it. Please provide details of why this feature would be valuable      and if possible point us to resources to help us better understand the feature.","category":"page"},{"location":"dev/contributing/#Contribute-code","page":"Contributing Overview","title":"Contribute code","text":"","category":"section"},{"location":"dev/contributing/","page":"Contributing Overview","title":"Contributing Overview","text":"You can also contribute code to RLinearAlgebra.jl. Before contributing make sure that you      are familiar with Git,      GitHub,       Julia package development,     and the Design of the RLinearAlgebra.jl.     Once you are familiar with these items you can contribute to RLinearAlgebra.jl by      following the steps laid out in the      JUMP guide.","category":"page"},{"location":"dev/checklists/loggers/#Loggers-checklist","page":"Loggers","title":"Loggers checklist","text":"","category":"section"},{"location":"dev/checklists/loggers/","page":"Loggers","title":"Loggers","text":"If you are implementing a logging method for the library, make sure you have completed  the following steps before making a pull request. In the following guides, BasicLogger method is used as an example.","category":"page"},{"location":"dev/checklists/loggers/","page":"Loggers","title":"Loggers","text":"## Implementation\n1. Method's core codes (`src/Solvers/Loggers`):\n    - [ ] Create a file in the directory `src/Solvers/Loggers`. For example, `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `Logger` struct with `max_it`, `collection_rate`, `threshold_info`, `stopping_criterion`, any other method-needed parameters, and argument validations to check invalid inputs. For example, `BasicLogger<:Logger`.\n    - [ ] Create a constructor with keyword default values for your `Logger` struct. For example, \n    ```\n        BasicLogger(;\n            max_it = 0, \n            collection_rate = 1, \n            threshold = 0.0,\n            stopping_criterion = threshold_stop \n        ) = BasicLogger(max_it, collection_rate, threshold, stopping_criterion)\n    ```\n    - [ ] Add documentation for this `Logger` struct, with mainly 5 parts: brief introduction, fields introduction, constructor and its keywords, what the constructor returns, and what the argument validations throw. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `LoggerRecipe` struct that uses the parameters from the `Logger` struct to preallocate memory. For example, `BasicLoggerRecipe{F<:Function} <: LoggerRecipe`.\n    - [ ] Create a `complete_logger` function that takes the `logger` struct as an input, and returns the `LoggerRecipe` struct you defined last step. For example, `complete_logger(logger::BasicLogger)`.\n    - [ ] Add documentation for this `LoggerRecipe` struct, with mainly 2 parts: brief introduction, fields introduction. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] Create a `update_logger!` function to log the errors as the iteration goes on, and stop the logging with convergence status or the maximum iteration limit. For example, \n    ```\n        update_logger!(logger::BasicLoggerRecipe, error::Float64, iteration::Int64)\n    ```\n    - [ ] Create a `reset_logger!` function to clean the history log information after convergence or exceed the maximum iteration. For example, `reset_logger!(logger::BasicLoggerRecipe)`.\n    - [ ] Create a `threshold_stop` function as the convergent stopping criterion designed for your `Logger` struct. For example, `threshold_stop(log::BasicLoggerRecipe)`\n    - [ ] Add documentation for this `threshold_stop` function, with mainly 3 parts: brief introduction, arguments introduction, and returns. For more details, you can check `src/Solvers/Loggers/basic_logger.jl`.\n    - [ ] **Optional**: If you have any helper functions that needed for your implementation, please implement them in a folder at `src/Solvers/Loggers`.\n2. Package structure cooperation (`src/Solvers/Loggers.jl`, `src/RLinearAlgebra.jl`, `src/refs.bib`):  \n    - [ ] Add an include(\"Loggers/[YOURFILE]\") at bottom of the page, `src/Solvers/Loggers.jl`.\n    - [ ] Add import statements to `src/RLinearAlgebra.jl` with any functions from other packages that you use.\n    - [ ] Export your `Logger`, `LoggerRecipe`, any structs and functions you needed for your logger method to work in `src/RLinearAlgebra.jl`.\n    - [ ] Add your `Logger`, `LoggerRecipe`, needed structs and functions to `docs/src/api.loggers.md`, under the appropriate heading.\n    - [ ] If there are any new-added references, please add in `src/refs.bib`.\n3. Tests (`test/Solvers/Loggers`):\n    - [ ] Add a procedural test to `test/Solvers/Loggers`. Be sure to check that the functions work as intended and all warnings/assertions are displayed. For example, `test/Solvers/Loggers/basic_logger.jl`.\n    - [ ] After finish implementing, you can goes to the julia's package environment by type `]` in the julia command line and run `test` to test whether you can pass all the tests.\n\n## Pull request\n- [ ] Give a specific title to pull request.\n- [ ] Lay out the features added to the pull request.\n- [ ] Tag two people to review your pull request.\n- [ ] **Optional**: If possible, please also add Copilot as a reviewer and choose to adopt its suggestions if reasonable.","category":"page"},{"location":"api/solver_errors/#SolverErrors","page":"SolverErrors","title":"SolverErrors","text":"","category":"section"},{"location":"api/solver_errors/","page":"SolverErrors","title":"SolverErrors","text":"Pages = [\"solver_error.md\"]","category":"page"},{"location":"api/solver_errors/#Abstract-Types","page":"SolverErrors","title":"Abstract Types","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.SolverError","page":"SolverErrors","title":"RLinearAlgebra.SolverError","text":"SolverError\n\nAn abstract supertype for structures that contain the user-controlled parameters for techniques that evaluates the quality of solution from a linear solver.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#RLinearAlgebra.SolverErrorRecipe","page":"SolverErrors","title":"RLinearAlgebra.SolverErrorRecipe","text":"SolverErrorRecipe\n\nAn abstract supertype for structures that contain the user-controlled parameters, linear  system dependent parameters, and preallocated memory for techniques that evaluate the  solution to a liear solver..\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#SolverError-Structures","page":"SolverErrors","title":"SolverError Structures","text":"","category":"section"},{"location":"api/solver_errors/#Exported-Functions","page":"SolverErrors","title":"Exported Functions","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.complete_solver_error","page":"SolverErrors","title":"RLinearAlgebra.complete_solver_error","text":"complete_solver_error(\n    error::SolverError, \n    ::AbstractMatrix, \n    ::AbstractVector\n)\n\nA function that generates a SolverErrorRecipe using the user defined inputs of a SolverError     and information from the matrix A and vector b.\n\nArguments\n\nerror::SolverError, a data structure that stores the user defined parameters relating to \n\nan error method.\n\nA::AbstractMatrix, the coefficient matrix.\nb::AbstractVector, the constant vector.\n\nOutputs\n\nA Float64 representing the progress of the solver. \n\n\n\n\n\n","category":"function"},{"location":"api/solver_errors/#RLinearAlgebra.compute_solver_error","page":"SolverErrors","title":"RLinearAlgebra.compute_solver_error","text":"compute_solver_error(\n    error::ErrorRecipe, \n    solver::Solver, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that evaluates the quality of a solution from a linear solver.\n\nArguments\n\nerror::SolverErrorRecipe, a data structure that stores intermediate information relating    to the computation of an error metric. For instance, if computing the residual this    would be a buffer vector for storing the residual.\nsolver::SolverRecipe, the datastructure containing all the solver information.\nA::AbstractMatrix, the coefficient matrix.\nb::AbstractVector, the constant vector.\n\nOutputs\n\nA Float64 representing the progress of the solver. \n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#Solvers","page":"Solvers Overview","title":"Solvers","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers Overview","title":"Solvers Overview","text":"Pages = [\"solvers.md\"]","category":"page"},{"location":"api/solvers/#Abstract-Types","page":"Solvers Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.Solver","page":"Solvers Overview","title":"RLinearAlgebra.Solver","text":"Solver\n\nAn abstract supertype for structures that contain the user-controlled parameters for  techniques that solve a linear system Ax = b.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#RLinearAlgebra.SolverRecipe","page":"Solvers Overview","title":"RLinearAlgebra.SolverRecipe","text":"SolverRecipe\n\nAn abstract supertype for structures that contain the user-controlled parameters, linear system dependent parameters, and preallocated memory for techniques that solve a linear  system Ax = b.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#Solver-Structures","page":"Solvers Overview","title":"Solver Structures","text":"","category":"section"},{"location":"api/solvers/#Exported-Functions","page":"Solvers Overview","title":"Exported Functions","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.complete_solver","page":"Solvers Overview","title":"RLinearAlgebra.complete_solver","text":"complete_solver(solver::Solver, x::AbstractVector, A::AbstractMatrix, b::AbstractVector)\n\nA function that combines the information in the Solver data structure, matrix A, vector x, and vector b to for a SolverRecipe which can be used to solve the linear system.\n\nArguments\n\nsolver::Solver, a solver structure containing all the user defined parameters.\nx::AbstractVector, a vector that will be overwritten with the solution.\nA::AbstractMatrix, the coeficent matrix for the linear system.\nb::AbstractVector, the constant vector for the linear system.\n\nOutputs\n\nReturns a SolverRecipe.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.rsolve","page":"Solvers Overview","title":"RLinearAlgebra.rsolve","text":"rsolve(\n    solver::Solver, \n    x::AbstractVector, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that solves the linear system Ax=b or the least square problem     min_x Ax -b_2^2 using solving method specified by the solver     data structure.\n\nArguments\n\nsolver::Solver, a solver structure containing all the user defined parameters.\nx::AbstractVector, a vector that will be overwritten with the solution.\nA::AbstractMatrix, the coeficent matrix for the linear system.\nb::AbstractVector, the constant vector for the linear system.\n\nOutputs\n\nx::AbstractVector, the solution to the linear system.\nsolver_method, the SolverRecipe generating for applying the desired solving technique.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.rsolve!","page":"Solvers Overview","title":"RLinearAlgebra.rsolve!","text":"rsolve!(\n    solver::SolverRecipe, \n    x::AbstractVector, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that solve the linear system Ax=b or the least square problem     min_x Ax -b_2^2 using solving method specified by the solver     data structure. \n\nArguments\n\n-solver::SolverRecipe, a structure containing all relevant parameter values and memory     to solve a linear system with a speciefied technique.\n\nx::AbstractVector, a vector that will be overwritten with the solution.\nA::AbstractMatrix, the coeficent matrix for the linear system.\nb::AbstractVector, the constant vector for the linear system.\n\nOutputs\n\nThe function updates solver and x in-place.\n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#ApproximatorErrors","page":"ApproximatorErrors","title":"ApproximatorErrors","text":"","category":"section"},{"location":"api/approximator_errors/","page":"ApproximatorErrors","title":"ApproximatorErrors","text":"Pages = [\"approximator_error.md\"]","category":"page"},{"location":"api/approximator_errors/#Abstract-Types","page":"ApproximatorErrors","title":"Abstract Types","text":"","category":"section"},{"location":"api/approximator_errors/#RLinearAlgebra.ApproximatorError","page":"ApproximatorErrors","title":"RLinearAlgebra.ApproximatorError","text":"ApproxmatorError\n\nAn abstract supertype for structures containing user-controlled parameters corresponding to  methods that evaluate the quality of a Low-Rank approximation of a matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximator_errors/#RLinearAlgebra.ApproximatorErrorRecipe","page":"ApproximatorErrors","title":"RLinearAlgebra.ApproximatorErrorRecipe","text":"ApproxmatorErrorRecipe\n\nAn abstract supertype for structures containing user-controlled parameters, linear system dependent parameters and preallocated memory corresponding to methods that evaluate the  quality of a Low-Rank approximation of a matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximator_errors/#ApproximatorError-Structures","page":"ApproximatorErrors","title":"ApproximatorError Structures","text":"","category":"section"},{"location":"api/approximator_errors/#Exported-Functions","page":"ApproximatorErrors","title":"Exported Functions","text":"","category":"section"},{"location":"api/approximator_errors/#RLinearAlgebra.complete_approximator_error","page":"ApproximatorErrors","title":"RLinearAlgebra.complete_approximator_error","text":"completeapproximatorerror(         error::ApproximatorError,          S::CompressorRecipe,          A::AbstractMatrix     )\n\nA function that produces an ApproximatorErrorRecipe from an ApproximatorError,      CompressorRecipe, and AbstractMatrix.\n\nArguments\n\nerror::ApproximatorError, the user controlled parameters associated with the    approximation error.\nS::CompressorRecipe, the compressor information used for the low rank approximation.\nA::AbstractMatrix, the matrix being approximated.\n\nOutputs\n\nThe ApproximatorErrorRecipe corresponding to the ApproximatorError technique.\n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#RLinearAlgebra.compute_approximator_error","page":"ApproximatorErrors","title":"RLinearAlgebra.compute_approximator_error","text":"computeapproximatorerror(     error::ApproximatorErrorMethod,      approximator::Approximator,      A::AbstractMatrix )\n\nA function that evaluates the quality of an ApproximatorRecipe.\n\nArguments\n\nerror::ApproximatorErrorRecipe, the method for computing the \n\napproximation error.\n\napprox::ApproximatorRecipe, the low rank of the approximation of the matrix.\nA::AbstractMatrix, the matrix.\n\nOutputs\n\nThis function will return an error metric for the approximation of the matrix.\n\n\n\n\n\n","category":"function"},{"location":"dev/checklists/compressors/#Compressors-checklist","page":"Compressors","title":"Compressors checklist","text":"","category":"section"},{"location":"dev/checklists/compressors/","page":"Compressors","title":"Compressors","text":"If you are implementing a compression method for the library, make sure you have completed  the following steps before making a pull request. ","category":"page"},{"location":"dev/checklists/compressors/","page":"Compressors","title":"Compressors","text":"1. Implementation\n- [ ] Create a file in the directory `src/Compressors`.\n- [ ] Create a Compressor structure with n_rows and n_cols as well as other user-controlled \nparameters.\n- [ ] Create a constructor with keyword default values for your struct.\n- [ ] Create a CompressorRecipe structure that uses the parameters from the Compressor \nstructure to preallocate memory.\n- [ ] Create a `complete_compressor` function that takes as inputs of the Compressor, A, x,b\nand returns a CompressorRecipe\n- [ ] Create a `update_compressor!` function that generates new random values for a random\ncomponents of the Compressor \n- [ ] a 5 input `mul!` function for  applying a compressor to a matrix from the left\n- [ ] a 5 input `mul!` function for  applying a compressor to a matrix from the right \n- [ ] a 5 input `mul!` function for  applying a compressor to a vector\n- [ ] a 5 input `mul!` function for  applying the adjoint of the compressor to a vector\n- [ ] Add an include(\"Compressors/[YOURFILE]\") at bottom of page \n- [ ] Add import statements to src/RLinearAlgebra.jl with any functions from other packages \nthat you use.\n- [ ] Add your Compressor and CompressorRecipe to src/RLinearAlgebra.jl.\n- [ ] Add your Compressor and CompressorRecipe to docs/src/api/compressors.md \nunder the appropiate heading. \n- [ ] Add a procedural test to test/linear_samplers. Be sure to check that the functions \nwork as intended and all warnings/assertions are displayed.\n2. Pull request\n- [ ] Give a specific title to pull request.\n- [ ] Lay out the features added to the pull request.\n- [ ] Tag two people to review your pull request.","category":"page"},{"location":"#RLinearAlgebra","page":"Home","title":"RLinearAlgebra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RLinearAlgebra is a Julia library for the  development and application of randomized algorithms to the problems of forming low rank  approximations to matrices and finding the solution of linear systems of equations.  Because of the large diversity of randomized techniques, rather than offering isolated  routine implementations of algorithms, this library implements a series of extendable data  structures and methods which allow code reuse.","category":"page"},{"location":"#Documentation-structure","page":"Home","title":"Documentation structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation serves both as a manual to the library and as an introduction to  randomized linear approximation techniques and randomized linear algebra solvers.  We divide it in four parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorial: examples of how to solve linear systems with RLinearAlgebra and how to ","category":"page"},{"location":"","page":"Home","title":"Home","text":"extend the library.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Manual: here we offer an introduction to solving linear systems with randomized linear ","category":"page"},{"location":"","page":"Home","title":"Home","text":"algebra techniques, compressing a matrix, and forming a low-rank approximation of a matrix.  We introduce theoretical foundations and we provide code examples with RLinearAlgebra.","category":"page"},{"location":"","page":"Home","title":"Home","text":"API: a detailed description of all the data structures and methods of the library.\nDevelopment: detailed instructions on how to contribute to the library.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is supported by the National Science Foundation Office of Advanced  Cyberinfrastructure under awards  2309445 and  2309446. This material is based upon work supported by the U.S. Department of Energy, Office of  Science, under contract number DE-AC02-06CH11357.","category":"page"},{"location":"api/contents/#Randomized-Linear-Solver-Reference","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"","category":"section"},{"location":"api/contents/","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"Pages=[\n  \"approximators.md\",  \n  \"approximator_error.md\",\n  \"compressors.md\",\n  \"solvers.md\",\n  \"solver_error.md\",\n  \"sub_solvers.md\",\n  \"loggers.md\"]","category":"page"}]
}
