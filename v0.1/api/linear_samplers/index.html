<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Linear Samplers · RLinearAlgebra</title><meta name="title" content="Linear Samplers · RLinearAlgebra"/><meta property="og:title" content="Linear Samplers · RLinearAlgebra"/><meta property="twitter:title" content="Linear Samplers · RLinearAlgebra"/><meta name="description" content="Documentation for RLinearAlgebra."/><meta property="og:description" content="Documentation for RLinearAlgebra."/><meta property="twitter:description" content="Documentation for RLinearAlgebra."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">RLinearAlgebra</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../man/cls_overview/">Consistent Linear Systems</a></li><li><a class="tocitem" href="../../man/tracking_overview/">Tracking</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linear_rsolve/">Randomized Linear Solvers</a></li><li class="is-active"><a class="tocitem" href>Linear Samplers</a><ul class="internal"><li><a class="tocitem" href="#Abstract-Types"><span>Abstract Types</span></a></li><li><a class="tocitem" href="#Vector-Row-Samplers"><span>Vector Row Samplers</span></a></li><li><a class="tocitem" href="#Vector-Column-Samplers"><span>Vector Column Samplers</span></a></li><li><a class="tocitem" href="#Block-Vector-Row-Samplers"><span>Block Vector Row Samplers</span></a></li><li><a class="tocitem" href="#Block-Vector-Col-Samplers"><span>Block Vector Col Samplers</span></a></li><li><a class="tocitem" href="#Sample-Function"><span>Sample Function</span></a></li><li><a class="tocitem" href="#Internal-Functions"><span>Internal Functions</span></a></li><li><a class="tocitem" href="#Matrix-Induced-Probability-Distributions"><span>Matrix Induced Probability Distributions</span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Linear Subsolvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../linear_solver_routines/">Main Solvers</a></li><li><a class="tocitem" href="../linear_solver_helpers/">Solver Helpers</a></li></ul></li><li><a class="tocitem" href="../linear_solver_logs/">Linear Solver Logs</a></li><li><a class="tocitem" href="../linear_solver_stops/">Linear Solver Stop Criteria</a></li><li><a class="tocitem" href="../low_rank_approximations/">Low Rank Approximations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">Developers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../dev/contributing/">Contributing</a></li><li><a class="tocitem" href="../../dev/styleguide/">Style Guide</a></li><li><a class="tocitem" href="../../dev/checklists/">Checklists</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Linear Samplers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Linear Samplers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/numlinalg/RLinearAlgebra.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/master/docs/src/api/linear_samplers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Linear-Samplers"><a class="docs-heading-anchor" href="#Linear-Samplers">Linear Samplers</a><a id="Linear-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Samplers" title="Permalink"></a></h1><ul><li><a href="#Linear-Samplers">Linear Samplers</a></li><li class="no-marker"><ul><li><a href="#Abstract-Types">Abstract Types</a></li><li><a href="#Vector-Row-Samplers">Vector Row Samplers</a></li><li><a href="#Vector-Column-Samplers">Vector Column Samplers</a></li><li><a href="#Block-Vector-Row-Samplers">Block Vector Row Samplers</a></li><li><a href="#Block-Vector-Col-Samplers">Block Vector Col Samplers</a></li><li><a href="#Sample-Function">Sample Function</a></li><li><a href="#Internal-Functions">Internal Functions</a></li><li><a href="#Matrix-Induced-Probability-Distributions">Matrix Induced Probability Distributions</a></li></ul></li></ul><h2 id="Abstract-Types"><a class="docs-heading-anchor" href="#Abstract-Types">Abstract Types</a><a id="Abstract-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Abstract-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysSampler" href="#RLinearAlgebra.LinSysSampler"><code>RLinearAlgebra.LinSysSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysSampler</code></pre><p>Abstract supertype for sampling, sketching or deterministically selecting components     of a linear system.</p><p><strong>Aliases</strong></p><ul><li><code>LinSysSketch</code></li><li><code>LinSysSelect</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers.jl#L24-L33">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowSampler" href="#RLinearAlgebra.LinSysVecRowSampler"><code>RLinearAlgebra.LinSysVecRowSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowSampler &lt;: LinSysSampler</code></pre><p>Abstract supertype for sampling, sketching or deterministically selecting a row space     element from a linear system.</p><p><strong>Aliases</strong></p><ul><li><code>LinSysVecRowSketch</code></li><li><code>LinSysVecRowSelect</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers.jl#L38-L47">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecColSampler" href="#RLinearAlgebra.LinSysVecColSampler"><code>RLinearAlgebra.LinSysVecColSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecColSampler &lt;: LinSysSampler</code></pre><p>Abstract supertype for sampling, sketching or deterministically selecting a column space     element from a linear system.</p><p><strong>Aliases</strong></p><ul><li><code>LinSysVecColSketch</code></li><li><code>LinSysVecColSelect</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers.jl#L53-L62">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkRowSampler" href="#RLinearAlgebra.LinSysBlkRowSampler"><code>RLinearAlgebra.LinSysBlkRowSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkRowSampler &lt;: LinSysSampler</code></pre><p>Abstract supertype for sampling, sketching or deterministically selecting a collection of     row space elements from a linear system.</p><p><strong>Aliases</strong></p><ul><li><code>LinSysBlkRowSketch</code></li><li><code>LinSysBlkRowSelect</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers.jl#L67-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkColSampler" href="#RLinearAlgebra.LinSysBlkColSampler"><code>RLinearAlgebra.LinSysBlkColSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkColSampler &lt;: LinSysSampler</code></pre><p>Abstract supertype for sampling, sketching or deterministically selecting a collection of     column space elements from a linear system.</p><p><strong>Aliases</strong></p><ul><li><code>LinSysBlkColSketch</code></li><li><code>LinSysBlkColSelect</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers.jl#L81-L90">source</a></section></article><h2 id="Vector-Row-Samplers"><a class="docs-heading-anchor" href="#Vector-Row-Samplers">Vector Row Samplers</a><a id="Vector-Row-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Row-Samplers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowDetermCyclic" href="#RLinearAlgebra.LinSysVecRowDetermCyclic"><code>RLinearAlgebra.LinSysVecRowDetermCyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowDetermCyclic &lt;: LinSysVecRowSelect</code></pre><p>An immutable structure without any fields. Specifies deterministic cycling through the equations of a linear system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_deterministic_cyclic.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowHopRandCyclic" href="#RLinearAlgebra.LinSysVecRowHopRandCyclic"><code>RLinearAlgebra.LinSysVecRowHopRandCyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowHopRandCyclic &lt;: LinSysVecRowSelect</code></pre><p>A mutable structure that specifies a cycling through the rows of a linear system, where the cycling order is determined randomly once the current cycling order has been used <code>hop</code> number of times. The solver randomly chooses the cycling order whenever necessary.</p><p><strong>Fields</strong></p><ul><li><code>order::Union{Vector{Int64},Nothing}</code></li><li><code>hop::Int64</code></li></ul><p><strong>Constructors</strong></p><ul><li><code>LinSysVecRowHopRandCyclic()</code> defaults to setting the <code>order</code> to <code>nothing</code> and the <code>hop</code>   to <code>5</code> (i.e., each ordering is used five times before sampling a new ordering).</li><li><code>LinSysVecRowHopRandCyclic(hop::Int64)</code> defaults to setting the <code>order</code> to <code>nothing</code> and   the <code>hop</code> to whatever is specified by the argument.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_hop_rand_cyclic.jl#L8-L24">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowOneRandCyclic" href="#RLinearAlgebra.LinSysVecRowOneRandCyclic"><code>RLinearAlgebra.LinSysVecRowOneRandCyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowOneRandCyclic &lt;: LinSysVecRowSelect</code></pre><p>A mutable structure with a field to store a cycling order. Randomly specifies a cycling order over the equations of a linear system. Once this ordering is specified, the ordering is kept fixed.</p><p><strong>Fields</strong></p><ul><li><code>order::Union{Vector{Int64},Nothing}</code></li></ul><p>Calling <code>LinSysVecRowOneRandCyclic()</code> defaults to setting <code>order</code> to <code>nothing</code>. The <code>sample</code> function will handle the re-initialization of the fields once the system is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_one_rand_cyclic.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowPropToNormSampler" href="#RLinearAlgebra.LinSysVecRowPropToNormSampler"><code>RLinearAlgebra.LinSysVecRowPropToNormSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowPropToNormSampler &lt;: LinSysVecRowSampler</code></pre><p>A mutable structure that specifies sampling from the rows of the equation where the probability of selecting a given equation is proportional to the sum of squares of the coefficients of the given equation. The solver will appropriately initialize the distribution.</p><p>See Strohmer, T., Vershynin, R. A Randomized Kaczmarz Algorithm with Exponential Convergence. J Fourier Anal Appl 15, 262 (2009). https://doi.org/10.1007/s00041-008-9030-4</p><p><strong>Aliases</strong></p><ul><li><code>LinSysVecRowSVSampler</code></li></ul><p><strong>Fields</strong></p><ul><li><code>dist::Vector{Float64}</code>, probability vector representing a distribution over rows.</li></ul><p>Calling <code>LinSysVecRowPropToNormSampler()</code> or <code>LinSysVecRowSVSampler()</code> defaults <code>dist</code> to <code>[1.0]</code>.</p><div class="admonition is-info" id="Note-67974f892939ceca"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-67974f892939ceca" title="Permalink"></a></header><div class="admonition-body"><p>When <code>iter == 1</code>, the vector <code>dist</code> will be overwritten to ensure the correct probability weights. </p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_prop_to_norm_replace.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowRandCyclic" href="#RLinearAlgebra.LinSysVecRowRandCyclic"><code>RLinearAlgebra.LinSysVecRowRandCyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowRandCyclic &lt;: LinSysVecRowSelect</code></pre><p>A mutable structure with a field to store a cycling order. Randomly specifies a cycling order the equations of a linear system. Once this ordering is exhausted by the solver, a new random ordering is specified. This process is repeated</p><p><strong>Fields</strong></p><ul><li><code>order::Union{Vector{Int64},Nothing}</code></li></ul><p>Calling <code>LinSysVecRowOneRandCyclic()</code> defaults to setting <code>order</code> to <code>nothing</code>. The <code>sample</code> function will handle the re-initialization of the fields once the system is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_rand_cyclic.jl#L8-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowUnidSampler" href="#RLinearAlgebra.LinSysVecRowUnidSampler"><code>RLinearAlgebra.LinSysVecRowUnidSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowUnidSampler &lt;: LinSysVecRowSampler</code></pre><p>An immutable structure without fields that specifies randomly cycling from the rows of a linear system with uniform probability and with replacement.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_unid_replace.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowUnifSampler" href="#RLinearAlgebra.LinSysVecRowUnifSampler"><code>RLinearAlgebra.LinSysVecRowUnifSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowUnifSampler &lt;: LinSysVecRowSampler</code></pre><p>An immutable structure without fields that specifies taking a linear combination of all equations with the coefficients being independent uniform random variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_uniform.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowSparseUnifSampler" href="#RLinearAlgebra.LinSysVecRowSparseUnifSampler"><code>RLinearAlgebra.LinSysVecRowSparseUnifSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowSparseUnifSampler &lt;: LinSysVecRowSelect</code></pre><p>A mutable structure that specifies sampling a proporition of the rows of a linear system, scaling each using independent uniform  random variables, and then taking their sum. The proportion of rows sampled without replacement is given by (at most) <code>sparsity</code> which must be  between 0 and 1 (not inclusive).</p><p><strong>Fields</strong></p><ul><li><code>sparsity::Float64</code></li></ul><p><strong>Constructors</strong></p><ul><li><code>LinSysVecRowSparseUnifSampler()</code> defaults the <code>sparsity</code> level to 0.2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_uniform_sparse.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowGaussSampler" href="#RLinearAlgebra.LinSysVecRowGaussSampler"><code>RLinearAlgebra.LinSysVecRowGaussSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowGaussSampler &lt;: LinSysVecRowSampler</code></pre><p>An immutable structure without fields that specifies taking a linear combination of all equations with the coefficients being independent Gaussian random variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_gaussian.jl#L5-L10">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowSparseGaussSampler" href="#RLinearAlgebra.LinSysVecRowSparseGaussSampler"><code>RLinearAlgebra.LinSysVecRowSparseGaussSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowSparseGaussSampler &lt;: LinSysVecRowSelect</code></pre><p>A mutable structure that specifies sampling a proporition of the rows of a linear system, scaling each using independent Gaussian  random variables, and then taking their sum. The proportion of rows sampled without replacement is given by (at most) <code>sparsity</code> which must be  between 0 and 1 (not inclusive).</p><p><strong>Fields</strong></p><ul><li><code>sparsity::Float64</code></li></ul><p><strong>Constructors</strong></p><ul><li><code>LinSysVecRowSparseUnifSampler()</code> defaults the <code>sparsity</code> level to 0.2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_gaussian_sparse.jl#L8-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowMaxResidual" href="#RLinearAlgebra.LinSysVecRowMaxResidual"><code>RLinearAlgebra.LinSysVecRowMaxResidual</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowMaxResidual &lt;: LinSysVecRowSelect</code></pre><p>An immutable structure without fields that specifies choosing the  linear equation in a system with the largest absolute residual at the current  iterate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_max_residual.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowResidCyclic" href="#RLinearAlgebra.LinSysVecRowResidCyclic"><code>RLinearAlgebra.LinSysVecRowResidCyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowResidCyclic &lt;: LinSysVecRowSelect</code></pre><p>A mutable structure with a field to store a cycling order. When the ordering  is not specified, the ordering is filled by looking at the residuals at the current iterate and ordering by decreasing residual. Once the order is exhausted a new order is selected. </p><p><strong>Fields</strong></p><ul><li><code>order::Vector{Int64}</code></li></ul><p>Calling <code>LinSysVecRowResidCyclic()</code> defaults to setting <code>order</code> to an empty array.  The <code>sample</code> function will handle the re-initialization of the fields once the  system is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_cyclic_residual.jl#L6-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowMaxDistance" href="#RLinearAlgebra.LinSysVecRowMaxDistance"><code>RLinearAlgebra.LinSysVecRowMaxDistance</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowMaxDistance &lt;: LinSysVecRowSelect</code></pre><p>An immutable structure without fields that specifies choosing the  linear equation in a system with the largest distance between the current iterate and the hyperplane specified by the equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_max_distance.jl#L6-L12">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecRowDistCyclic" href="#RLinearAlgebra.LinSysVecRowDistCyclic"><code>RLinearAlgebra.LinSysVecRowDistCyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecRowDistCyclic &lt;: LinSysVecRowSelect</code></pre><p>A mutable structure with a field to store a cycling order. When the ordering  is not specified, the ordering is filled in two steps. First, the distances  between the current iterate and all hyperplanes as specified by the equations of the system. Then, the ordering is the indices of these distances in decreasing  order.</p><p><strong>Fields</strong></p><ul><li><code>order::Vector{Int64}</code></li></ul><p>Calling <code>LinSysVecRowDistCyclic()</code> defaults to setting <code>order</code> to an empty array.  The <code>sample</code> function will handle the re-initialization of the fields once the  system is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_row_cyclic_distance.jl#L6-L21">source</a></section></article><h2 id="Vector-Column-Samplers"><a class="docs-heading-anchor" href="#Vector-Column-Samplers">Vector Column Samplers</a><a id="Vector-Column-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Column-Samplers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecColDetermCyclic" href="#RLinearAlgebra.LinSysVecColDetermCyclic"><code>RLinearAlgebra.LinSysVecColDetermCyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecColDetermCyclic &lt;: LinSysVecColSelect</code></pre><p>An immutable structure without any fields. Specifies deterministic cycling through the columns of a linear system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_col_deterministic_cyclic.jl#L8-L13">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysVecColOneRandCyclic" href="#RLinearAlgebra.LinSysVecColOneRandCyclic"><code>RLinearAlgebra.LinSysVecColOneRandCyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecColOneRandCyclic &lt;: LinSysVecColSelect</code></pre><p>A mutable structure with a field to store a cycling order. Randomly specifies a cycling order over the equations of a linear system. Once this ordering is specified, the ordering is kept fixed.</p><p><strong>Fields</strong></p><ul><li><code>order::Vector{Int64}</code></li></ul><p>Calling <code>LinSysVecColOneRandCyclic()</code> defaults to setting <code>order</code> to <code>nothing</code>. The <code>sample</code> function will handle the re-initialization of the fields once the system is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/vec_col_one_rand_cyclic.jl#L8-L20">source</a></section></article><h2 id="Block-Vector-Row-Samplers"><a class="docs-heading-anchor" href="#Block-Vector-Row-Samplers">Block Vector Row Samplers</a><a id="Block-Vector-Row-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Vector-Row-Samplers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkRowCountSketch" href="#RLinearAlgebra.LinSysBlkRowCountSketch"><code>RLinearAlgebra.LinSysBlkRowCountSketch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkRowCountSketch &lt;: LinSysBlkRowSampler</code></pre><p>A mutable structure that represents the CountSketch algorithm for rows.  The assumption is that <code>A</code> is fully known (that is, the sampling procedure is not used in a streaming context).</p><p>See Kenneth L. Clarkson and David P. Woodruff. 2017.      &quot;Low-Rank Approximation and Regression in Input Sparsity Time.&quot;     J. ACM 63, 6, Article 54 (February 2017), 45 pages.      https://doi.org/10.1145/3019134</p><p>The explicit sketch matrix is mentioned in Section 1.2 - Techniques (row version) of the aforementioned paper. See this <a href="https://wangshusen.github.io/code/countsketch.html">website</a> for a visual explanation of the column version.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, is the number of rows in the sketched matrix <code>S * A</code>.</li><li><code>S::Union{Matrix{Int64}, Nothing}</code>, buffer matrix for storing the sampling matrix <code>S</code>.</li></ul><p>Additional Constructors:</p><p>Calling <code>LinSysBlkRowCountSketch(block_size)</code> defaults to <code>LinSysBlkRowCountSketch(block_size, nothing)</code>. Calling <code>LinSysBlkRowCountSketch()</code> defaults to <code>LinSysBlkRowCountSketch(2, nothing)</code>. </p><p>!!! Remark &quot;Implementation Note&quot;      Current implementation does not take advantage of sparse matrix data structures or operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_row_count_sketch.jl#L10-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkRowGaussSampler" href="#RLinearAlgebra.LinSysBlkRowGaussSampler"><code>RLinearAlgebra.LinSysBlkRowGaussSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkRowGaussSampler &lt;: LinSysBlkRowSampler</code></pre><p>A mutable structure with fields to handle Guassian row sketching where a Gaussian matrix is multiplied by the matrix <code>A</code> from the left. </p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, specifies the size of each block.</li><li><code>sketch_matrix::Union{AbstractMatrix, Nothing}</code>, the buffer for storing the Gaussian sketching matrix.</li><li><code>scaling::Float64</code>, the standard deviation of the sketch, is set to be sqrt(block_size/numberOfRows).</li></ul><p><strong>Constructors</strong></p><p>Calling <code>LinSysBlkRowGaussSampler()</code> defaults to setting <code>block_size</code> to 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_row_gaussian.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkRowReplace" href="#RLinearAlgebra.LinSysBlkRowReplace"><code>RLinearAlgebra.LinSysBlkRowReplace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkRowReplace &lt;: LinSysBlkRowSampler</code></pre><p>A mutable structure with fields to store information for a sampling method that forms a new block by uniformly sampling rows of <code>A</code> without replacement,  also known as vanilla block randomized Kaczmarz. </p><p>Necoara, Ion. “Faster Randomized Block Kaczmarz Algorithms.” SIAM J. Matrix Anal. Appl. 40 (2019): 1425-1452.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, specifies the size of each block.</li><li><code>block::Vector{Int64}</code>, the list of all the rows in each block.</li></ul><p><strong>Constructors</strong></p><p>Calling <code>LinSysBlkRowReplace()</code> defaults to setting <code>block_size</code> to 2. The <code>sample</code> function will handle the re-initialization of the fields once the system is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_row_rand_replace.jl#L2-L18">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkRowRandCyclic" href="#RLinearAlgebra.LinSysBlkRowRandCyclic"><code>RLinearAlgebra.LinSysBlkRowRandCyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkRowRandCyclic &lt;: LinSysBlkRowSampler</code></pre><p>A mutable structure with fields to handle randomly permuted block sampling. After all blocks are called,  a new random ordering is created. </p><p><strong>Fields</strong></p><ul><li><code>n_blocks::Int64</code>, Variable that contains the number of blocks overall.</li><li><code>order::Union{Vector{Int64}, Nothing}</code>, The order that the blocks will be used to    generate updates.</li><li><code>blocks::Union{Vector{Vector{Int64}}, Nothing}</code>, The list of all the row in each block.</li><li><code>block_size::Union{Int64, Nothing}</code>, Variable that represents the smallest sketching    block size in iterations. Used in moving average method. </li></ul><p><strong>Constructors</strong></p><p>Calling <code>LinSysBlkColRandCyclic()</code> defaults to setting <code>n_blocks</code> to 2 and <code>blocks</code> to be sequentially ordered.  These values can be changed using the respective keyword arguments. The <code>sample</code> function will handle the re-initialization of the fields once the system is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_row_rand_cyclic.jl#L2-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkRowSelectWoReplacement" href="#RLinearAlgebra.LinSysBlkRowSelectWoReplacement"><code>RLinearAlgebra.LinSysBlkRowSelectWoReplacement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkRowSelectWoReplacement &lt;: LinSysBlkRowSampler</code></pre><p>A mutable struct that represents sampling rows from <code>A</code> without replacement using an arbitrary weight/probability vector.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, number of rows sampled (i.e., number of rows in <code>S * A</code>).</li><li><code>probability::Union{Weights, Vector{Float64}, Nothing}</code>, vector that represents a probability distribution over the rows of <code>A</code>. Requirements are that the probabilities sum to 1, are non-negative, <code>probability</code> has the same length as number of rows in <code>A</code>, and <code>probability</code> has at least as many positive entries as <code>block_size</code>. If <code>probability</code> is unspecified in the constructor, <code>sample</code> will default to a uniform distribution over rows of <code>A</code>.</li><li><code>population::Union{Vector{Int64}, Nothing}</code>, buffer array to hold <code>collect(1:size(A)[1])</code> used in <code>sample</code>.</li><li><code>rows_sampled::Union{Vector{Int64}, Nothing}</code>, buffer array to hold index of rows sampled from <code>A</code>.</li><li><code>S::Union{Matrix{Int64}, Nothing}</code>, buffer array to hold sketched matrix <code>S</code>.</li></ul><p>Calling <code>LinSysBlkRowSelectWoReplacement()</code> defaults to <code>LinSysBlkRowSelectWoReplacement(2, nothing, nothing, nothing, nothing)</code>.</p><p>An additional constructor is provided with keyword arguments <code>block_size</code> and <code>probability</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_row_sample_wo_replacement.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkRowFJLT" href="#RLinearAlgebra.LinSysBlkRowFJLT"><code>RLinearAlgebra.LinSysBlkRowFJLT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkRowFJLT &lt;: LinSysBlkRowSampler</code></pre><p>A mutable structure with fields to handle FJLT row sketching. At each iteration,  this procedure generates a matrix of the form S = G H D where G is sparse matrix with  the non-zero entries being drawn from a gaussian distribution, H is a Hadamard matrix,  and D is a diagonal matrix with a rademacher vector on the diagonal.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, the size of the sketching dimension</li><li><code>sparsity::Float64</code>, the sparsity of the sampling matrix</li><li><code>padded_size::Int64</code>, the size of the matrix when padded</li><li><code>sampling_matrix::Union{SparseMatrixCSC, Nothing}</code>, storage for sparse sketching matrix </li><li><code>hadamard::Union{AbstractMatrix, Nothing}</code>, storage for the hadamard matrix.</li><li><code>Ap::Union{AbstractMatrix, Nothing}</code>, storage for padded matrix</li><li><code>bp::Union{AbstractMatrix, Nothing}</code>, storage for padded vector</li><li><code>scaling::Float64</code>, storage for the scaling of the sketches.</li></ul><p>Calling <code>LinSysBlkRowFJLT()</code> defaults to setting <code>sparsity</code> to .3 and the blocksize to 2.</p><p>Ailon, Nir, and Bernard Chazelle. &quot;The fast Johnson–Lindenstrauss transform and approximate nearest neighbors.&quot;  SIAM Journal on computing 39.1 (2009): 302-322. https://doi.org/10.1137/060673096</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_row_FJLT.jl#L1-L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkRowSRHT" href="#RLinearAlgebra.LinSysBlkRowSRHT"><code>RLinearAlgebra.LinSysBlkRowSRHT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkRowSRHT &lt;: LinSysBlkRowSampler</code></pre><p>A mutable structure with fields to handle SRHT row sketching. At each iteration, this  procedure generates a matrix of the form S = R H D where R is a subset of the identity  matrix, H is a Hadamard matrix, and D is a diagonal matrix with a rademacher vector on  the diagonal.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, the size of blocks being chosen</li><li><code>padded_size::Int64</code>, the size of the matrix when padded</li><li><code>block::Union{Vector{Int64}, Nothing}</code>, storage for block indices</li><li><code>hadamard::Union{AbstractMatrix, Nothing}</code>, storage for the hadamard matrix.</li><li><code>Ap::Union{AbstractMatrix, Nothing}</code>, storage for padded matrix</li><li><code>bp::Union{AbstractMatrix, Nothing}</code>, storage for padded vector</li><li><code>scaling::Float64</code>, storage for the scaling of the sketches.</li></ul><p>Calling <code>LinSysBlkRowSRHT()</code> defaults to setting <code>block_size</code> to 2.</p><p>Nguyen, Nam H., Thong T. Do, and Trac D. Tran. &quot;A fast and efficient algorithm for low-rank approximation of a matrix.&quot;  Proceedings of the forty-first annual ACM symposium on Theory of computing. 2009. https://doi.org/10.1145/1536414.1536446</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_row_SRHT.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkRowSparseSign" href="#RLinearAlgebra.LinSysBlkRowSparseSign"><code>RLinearAlgebra.LinSysBlkRowSparseSign</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkRowSparseSign &lt;: LinSysBlkRowSampler</code></pre><p>A mutable structure with fields to handle sparse sign row sketching where a sparse sign matrix is multiplied by the matrix <code>A</code> from the left. More details of the methods are mentioned in the  section 9.2 of </p><p>Martinsson P-G, Tropp JA. &quot;Randomized numerical linear algebra: Foundations and algorithms.&quot;  Acta Numerica. 2020;29:403-572. doi:10.1017/S0962492920000021.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, represents the embedding dimension of the sketch matrix.</li><li><code>numsigns::Int64</code>, storing how many signs we need to have for each column of the    sketch matrix, which can be chosen from <code>{2, 3, ..., block_size}</code>.</li><li><code>sketch_matrix::Union{AbstractMatrix, Nothing}</code>, buffer for storing the sparse sign sketching matrix.</li><li><code>scaling::Float64</code>, the standard deviation of the sketch, set to <code>sqrt(n / numsigns)</code>, calculated    only in the first iteration.</li><li><code>row_indices::Union{Vector{Int64}, Nothing}</code>, buffer for storing the sparse signs places    in each column.</li></ul><p><strong>Constructors</strong></p><ul><li><code>LinSysBlkRowSparseSign()</code> defaults to setting <code>block_size</code> to <code>min(size(A, 1), 8)</code> and    <code>numsigns</code> to <code>min(block_size, 8)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_row_sparse_sign.jl#L3-L27">source</a></section></article><h2 id="Block-Vector-Col-Samplers"><a class="docs-heading-anchor" href="#Block-Vector-Col-Samplers">Block Vector Col Samplers</a><a id="Block-Vector-Col-Samplers-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Vector-Col-Samplers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkColCountSketch" href="#RLinearAlgebra.LinSysBlkColCountSketch"><code>RLinearAlgebra.LinSysBlkColCountSketch</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkColCountSketch &lt;: LinSysBlkColSampler</code></pre><p>A mutable structure that represents the CountSketch algorithm for columns. The assumption is that <code>A</code> is fully known (that is, the sampling procedure is not used in a streaming context).</p><p>See Kenneth L. Clarkson and David P. Woodruff. 2017.      &quot;Low-Rank Approximation and Regression in Input Sparsity Time.&quot;     J. ACM 63, 6, Article 54 (February 2017), 45 pages.      https://doi.org/10.1145/3019134</p><p>The explicit sketch matrix is mentioned in Section 1.2 - Techniques (row version) of the aforementioned paper. See this <a href="https://wangshusen.github.io/code/countsketch.html">website</a> for a visual explanation of the column version.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, is the number of columns in the sketched matrix <code>A * S</code></li><li><code>S::Union{Matrix{Int64}, Nothing}</code>, buffer matrix for storing the sampling matrix <code>S</code>.</li></ul><p>Additional Constructors:</p><p>Calling <code>LinSysBlkColCountSketch(block_size)</code> defaults to <code>LinSysBlkColCountSketch(block_size, nothing)</code>. Calling <code>LinSysBlkColCountSketch()</code> defaults to <code>LinSysBlkColCountSketch(2, nothing)</code>. </p><p>!!! Remark &quot;Implementation Note&quot;     Current implementation does not take advantage of sparse matrix data structures or operations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_col_count_sketch.jl#L10-L37">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkColGaussSampler" href="#RLinearAlgebra.LinSysBlkColGaussSampler"><code>RLinearAlgebra.LinSysBlkColGaussSampler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkColGaussSampler &lt;: LinSysBlkColSampler</code></pre><p>A mutable structure with fields to handle Guassian column sketching where a Gaussian matrix is multiplied by the matrix <code>A</code> from the right.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, specifies the size of each block.</li><li><code>sketch_matrix::Union{AbstractMatrix, Nothing}</code>, the buffer for storing the Gaussian sketching matrix.</li><li><code>scaling::Float64</code>, the standard deviation of the sketch, is set to be sqrt(block_size/numberOfColumns).</li></ul><p><strong>Constructors</strong></p><p>Calling <code>LinSysBlkColGaussSampler()</code> defaults to setting <code>block_size</code> to 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_col_gaussian.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkColReplace" href="#RLinearAlgebra.LinSysBlkColReplace"><code>RLinearAlgebra.LinSysBlkColReplace</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysVecBlkColReplace &lt;: LinSysBlkColSampler</code></pre><p>A mutable structure with fields to store information for a sampling method that forms a new block by uniformly sampling columns of <code>A</code> without replacement.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, specifies the size of each block.</li><li><code>block::Vector{Int64}</code>, the list of all the rows in each block.</li></ul><p><strong>Constructors</strong></p><p>Calling <code>LinSysBlkColReplace()</code> defaults to setting <code>block_size</code> to 2. The <code>sample</code> function will handle the initialization of the fields once the system is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_col_rand_replace.jl#L2-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkColRandCyclic" href="#RLinearAlgebra.LinSysBlkColRandCyclic"><code>RLinearAlgebra.LinSysBlkColRandCyclic</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkColRandCyclic &lt;: LinSysBlkColSampler</code></pre><p>A mutable structure with fields to handle randomly permuted block sampling.  After all blocks are called, a new random ordering is created. </p><p><strong>Fields</strong></p><ul><li><code>n_blocks::Int64</code>, Variable that contains the number of blocks overall.</li><li><code>order::Union{Vector{Int64}, Nothing}</code>, The order that the blocks will be used    to generate updates.</li><li><code>blocks::Union{Vector{Vector{Int64}}, Nothing}</code>, The vector containing all the groupings    of column indices.</li><li><code>block_size::Union{Int64, Nothing}</code>, Variable that represents the smallest sketching    block size in iterations. Used in moving average method. </li></ul><p><strong>Constructors</strong></p><p>Calling <code>LinSysBlkColRandCyclic()</code> defaults to setting <code>n_blocks</code> to 2 and <code>blocks</code> to be sequentially ordered.  These values can be changed using the respective keyword arguments.  The <code>sample</code> function will handle the re-initialization of the fields once the system is provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_col_rand_cyclic.jl#L2-L21">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkColSelectWoReplacement" href="#RLinearAlgebra.LinSysBlkColSelectWoReplacement"><code>RLinearAlgebra.LinSysBlkColSelectWoReplacement</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkColSelectWoReplacement &lt;: LinSysBlkColSampler</code></pre><p>A mutable struct that represents sampling columns from <code>A</code> without replacement using an arbitrary weight/probability vector.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, number of columns sampled (i.e., number of columns in <code>A * S</code>)</li><li><code>probability::Union{Weights, Vector{Float64}, Nothing}</code>, vector that represents a probability distribution over the columns of <code>A</code>. Requirements are that the probabilities sum to 1, are non-negative, <code>probability</code> has the same length as number of columns in <code>A</code>, and <code>probability</code> has at least as many positive entries as <code>block_size</code>. If <code>probability</code> is unspecified in the constructor, <code>sample</code> will default to a uniform distribution over columns of <code>A</code>.</li><li><code>population::Union{Vector{Int64}, Nothing}</code>, buffer array to hold the vector <code>collect(1:size(A)[2])</code> in the <code>sample</code> function.</li><li><code>col_sampled::Union{Vector{Int64}, Nothing}</code>, buffer array to hold index of columns sampled from <code>A</code>.</li><li><code>S::Union{Matrix{Int64}, Nothing}</code>, buffer array to hold sketching matrix <code>S</code>.</li></ul><p>Calling <code>LinSysBlkColSelectWoReplacement()</code> defaults to <code>LinSysBlkColSelectWoReplacement(2, nothing, nothing, nothing, nothing)</code>.</p><p>An additional constructor is provided with the keyword arguments <code>block_size</code> and <code>probability</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_col_sample_wo_replacement.jl#L11-L28">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkColFJLT" href="#RLinearAlgebra.LinSysBlkColFJLT"><code>RLinearAlgebra.LinSysBlkColFJLT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkColFJLT &lt;: LinSysBlkColSampler</code></pre><p>A mutable structure with fields to handle FJLT column sketching. At each iteration, this  procedure generates a matrix of the form S = D H G where G is sparse matrix with the non-zero  entries being drawn from a gaussian distribution, H is a Hadamard matrix, and D is a diagonal  matrix with a rademacher vector on the diagonal.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, the size of the sketching dimension</li><li><code>sparsity::Float64</code>, the sparsity of the sampling matrix, should be between 0 and 1</li><li><code>padded_size::Int64</code>, the size of the matrix when padded</li><li><code>sampling_matrix::Union{SparseMatrixCSC, Nothing}</code>, storage for sparse sketching matrix </li><li><code>hadamard::Union{AbstractMatrix, Nothing}</code>, storage for the hadamard matrix.</li><li><code>Ap::Union{AbstractMatrix, Nothing}</code>, storage for padded matrix</li><li><code>bp::Union{AbstractMatrix, Nothing}</code>, storage for padded vector</li><li><code>scaling::Float64</code>, storage for the scaling of the sketches.</li></ul><p>Calling <code>LinSysBlkColFJLT()</code> defaults to setting <code>sparsity</code> to .3 and the blocksize to 2.</p><p>Ailon, Nir, and Bernard Chazelle. &quot;The fast Johnson–Lindenstrauss transform and approximate nearest neighbors.&quot;  SIAM Journal on computing 39.1 (2009): 302-322. https://doi.org/10.1137/060673096</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_col_FJLT.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkColSRHT" href="#RLinearAlgebra.LinSysBlkColSRHT"><code>RLinearAlgebra.LinSysBlkColSRHT</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkColSRHT &lt;: LinSysBlkColSampler</code></pre><p>A mutable structure with fields to handle SRHT column sketching. At each iteration, this  procedure generates a matrix of the form S = D H R where R is a subset of the identity  matrix, H is a Hadamard matrix, and D is a diagonal matrix with a rademacher vector on  the diagonal.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, the size of blocks being chosen</li><li><code>padded_size::Int64</code>, the size of the matrix when padded</li><li><code>block::Union{Vector{Int64}, Nothing}</code>, storage for block indices</li><li><code>hadamard::Union{AbstractMatrix, Nothing}</code>, storage for the hadamard matrix.</li><li><code>Ap::Union{AbstractMatrix, Nothing}</code>, storage for padded matrix</li><li><code>signs::Union{Vector{Bool}, Nothing}</code>, storage for random sign flips.</li><li><code>scaling::Float64</code>, storage for the scaling of the sketches.</li></ul><p>Calling <code>LinSysBlkColSRHT()</code> defaults to setting <code>block_size</code> to 2.</p><p>Nguyen, Nam H., Thong T. Do, and Trac D. Tran. &quot;A fast and efficient algorithm for low-rank approximation of a matrix.&quot;  Proceedings of the forty-first annual ACM symposium on Theory of computing. 2009. https://doi.org/10.1145/1536414.1536446</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_col_SRHT.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.LinSysBlkColSparseSign" href="#RLinearAlgebra.LinSysBlkColSparseSign"><code>RLinearAlgebra.LinSysBlkColSparseSign</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">LinSysBlkColSparseSign &lt;: LinSysBlkColSampler</code></pre><p>A mutable structure with fields to handle sparse sign column sketching where a sparse sign matrix is multiplied by the matrix <code>A</code> from the right. More details of the methods are mentioned in the  section 9.2 of </p><p>Martinsson P-G, Tropp JA. &quot;Randomized numerical linear algebra: Foundations and algorithms.&quot;  Acta Numerica. 2020;29:403-572. doi:10.1017/S0962492920000021.</p><p><strong>Fields</strong></p><ul><li><code>block_size::Int64</code>, represents the embedding dimension of the sketch matrix.</li><li><code>numsigns::Int64</code>, buffer for storing how many signs we need to have for each row of the    sketch matrix, which can be chosen from <code>{2, 3, ..., block_size}</code>.</li><li><code>sketch_matrix::Union{AbstractMatrix, Nothing}</code>, buffer for storing the sparse sign sketching matrix.</li><li><code>scaling::Float64</code>, the standard deviation of the sketch, set to <code>sqrt(n / numsigns)</code>, calculated    only in the first iteration.</li><li><code>col_indices::Union{Vector{Int64}, Nothing}</code>, buffer for storing the sparse signs places    in each row.</li></ul><p><strong>Constructors</strong></p><ul><li><code>LinSysBlkColSparseSign()</code> defaults to setting <code>block_size</code> to <code>min(size(A, 2), 8)</code> and    <code>numsigns</code> to <code>min(block_size, 8)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/block_col_sparse_sign.jl#L3-L26">source</a></section></article><h2 id="Sample-Function"><a class="docs-heading-anchor" href="#Sample-Function">Sample Function</a><a id="Sample-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Sample-Function" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.sample-Tuple{Nothing, AbstractArray, AbstractVector, AbstractVector, Int64}" href="#RLinearAlgebra.sample-Tuple{Nothing, AbstractArray, AbstractVector, AbstractVector, Int64}"><code>RLinearAlgebra.sample</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample(type::T where T&lt;:LinSysSampler,
    A::AbstractArray,
    b::AbstractVector,
    x::AbstractVector,
    iter::Int64)</code></pre><p>A common interface for specifying different strategies for sampling, selecting or sketching     a linear system specified by <code>A</code> and <code>b</code>. The <code>type</code> argument is used to select the an     appropriately defined strategy. The argument <code>x</code> is the current iterate value for the     solution. The arguent <code>iter</code> is the iteration counter.</p><p>The value(s) returned by sample depend on the subtype of <code>LinSysSampler</code> being used.     Specifically,</p><ul><li>For <code>T&lt;:LinSysVecRowSampler</code>, a vector in the row space of <code>A</code> and constant are returned</li><li>For <code>T&lt;:LinSysVecColSampler</code>, a vector of <code>length(x)</code>, the matrix <code>A</code>,   and a scalar-valued residual are returned.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers.jl#L98-L115">source</a></section></article><h2 id="Internal-Functions"><a class="docs-heading-anchor" href="#Internal-Functions">Internal Functions</a><a id="Internal-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.init_blocks_cyclic!" href="#RLinearAlgebra.init_blocks_cyclic!"><code>RLinearAlgebra.init_blocks_cyclic!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">init_blocks_cyclic!(type::Union{LinSysBlkColRandCyclic,LinSysBlkRowRandCyclic}, dim::Int64)</code></pre><p>This function intializes the <code>blockSize</code>, <code>n_blocks</code>, and <code>order</code> values for the <code>LinSysBlkColRandCyclic</code>  and <code>LinSysBlkRowRandCyclic</code> data structures. If a set of blocks is already defined by the user then it  warns the user which block indices are unused. If the blocks are not premade, it simply allocates block  indices sequentially with a size that is floor(<code>n_blocks/dim</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/linear_sampler_helpers/helpers_cyclic.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.fwht!" href="#RLinearAlgebra.fwht!"><code>RLinearAlgebra.fwht!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fwht!(x::AbstractVector; signs=ones(Bool, size(x)), scaling = 1)</code></pre><p>Performs a Fast Walsh Hadamard Transform (FWHT), modifying the vector <code>x</code>. This means that  if you want an unmodified version of <code>x</code> you should copy it before calling this function.  <code>signs</code> allows the user to input a boolean vector that flips the signs of the entries  of the vector <code>x</code> before applying the transform. <code>scaling</code> allows the user to scale the  result of the transform. Choosing a scaling of 1/sqrt{size(x)} will result in the FWHT  being an orthogonal transform.</p><p>!!! Note: To avoid log computation at every call the function does not check that the dimension  is a power of 2. This must be done by a separate function at an earlier point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/linear_sampler_helpers/hadamard.jl#L1-L13">source</a></section></article><h2 id="Matrix-Induced-Probability-Distributions"><a class="docs-heading-anchor" href="#Matrix-Induced-Probability-Distributions">Matrix Induced Probability Distributions</a><a id="Matrix-Induced-Probability-Distributions-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Induced-Probability-Distributions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.frobenius_norm_distribution" href="#RLinearAlgebra.frobenius_norm_distribution"><code>RLinearAlgebra.frobenius_norm_distribution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">frobenius_norm_distribution(A::AbstractMatrix, row_distribution::Bool)</code></pre><p>Given a matrix <code>A</code> and an indication of whether a distribution over rows or columns should be created in <code>row_distribution</code>, return a probability vector.</p><p><strong>Method</strong></p><p>If <code>row_distribution = true</code>, <code>distribution[i]</code> will be the probability weight assigned to row <code>i</code> of <code>A</code>. It is computed as</p><p class="math-container">\[   ||A_{i,\cdot}||_2^2 / ||A||_F^2  \]</p><p>where <span>$A_{i, \cdot}$</span> is the <span>$i^{th}$</span> row of <code>A</code>, <span>$||\cdot||_2$</span> is the L2 norm, and <span>$||\cdot||_F$</span> is the Frobenius norm.</p><p>If <code>row_distribution = false</code>, <code>distribution[i]</code> will be the probability weight assigned to column <code>i</code> of <code>A</code>. It is computed by an analogous formula as above, however with the norm squared of the rows of <code>A</code> replace by the norm squared of the columns of <code>A</code>. </p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix</code>, matrix for which a distribution over rows or columns is desired.</li><li><code>row_distribution::Bool</code>, indication whether a distribution over rows or columns   is desired.</li></ul><p><strong>Return</strong></p><ul><li><code>distribution::Vector{Float64}</code>, vector of probabilities. Will be of length <code>size(A, 1)</code>    if <code>row_distribution = true</code>, otherwise will be of length <code>size(A, 2)</code>.</li></ul><div class="admonition is-warning" id="Warning-1cb26b874703d232"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-1cb26b874703d232" title="Permalink"></a></header><div class="admonition-body"><p>If <code>A</code> is sparse, the implementation does not account for this.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/linear_sampler_helpers/induced_distributions/frobenius_norm.jl#L6-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="RLinearAlgebra.leverage_score_distribution" href="#RLinearAlgebra.leverage_score_distribution"><code>RLinearAlgebra.leverage_score_distribution</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">leverage_score_distribution(A::AbstractMatrix, row_distribution::Bool)</code></pre><p>Given a matrix <code>A</code>, compute a distribution over rows or columns of the matrix, as      indicated by <code>row_distribution</code>, by using the leverage scores of the matrix.</p><p><strong>References(s)</strong></p><p>Drineas, Magdon-Ismail, Mahoney, and Woodruff. &quot;Fast Approximation of Matrix Coherence and Statistical Leverage&quot;. arxiv, https://arxiv.org/abs/1109.3843v2.</p><p><strong>Method</strong></p><p>If <code>row_distribution = true</code>, then we compute the thin QR decomposition of <code>A</code>. Take <span>$Q_1$</span> to be the thin Q. The probability weight assigned to row <span>$i$</span> of <code>A</code> is</p><p class="math-container">\[    ||Q_1[i, :]||_2^2 / ||Q_1||_F^2,\]</p><p>where <span>$Q_1[i, :]$</span> is the <span>$i^{th}$</span> row of <span>$Q_1$</span>, <span>$||\cdot||_2$</span> is the L2 norm, and <span>$||\cdot||_F$</span> is the frobenius norm.</p><p>If <code>row_distribution = false</code>, then we carry out the same procedure on <span>$A^\intercal$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>A::AbstractMatrix</code>, matrix for which a distribution over rows or columns is desired.</li><li><code>row_distribution::Bool</code>, indication whether a distribution over rows or columns   is desired.</li></ul><div class="admonition is-info" id="Note-962142115695fd74"><header class="admonition-header">Note<a class="admonition-anchor" href="#Note-962142115695fd74" title="Permalink"></a></header><div class="admonition-body"><p>As we take the QR decomposition of <code>A</code>, we enforce that <code>size(A)[1] &gt;= size(A)[2]</code>  when <code>row_distribution = true</code>, and <code>size(A&#39;)[1] &gt;= size(A&#39;)[2]</code> when  <code>row_distribution = false</code>.</p></div></div><p><strong>Return</strong></p><ul><li><code>distribution::Vector{Float64}</code>, vector of probabilities. Will be of length <code>size(A, 1)</code>    if <code>row_distribution = true</code>, otherwise will be of length <code>size(A, 2)</code>.</li></ul><div class="admonition is-warning" id="Warning-923e84ce601ff437"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-923e84ce601ff437" title="Permalink"></a></header><div class="admonition-body"><p>If <code>A</code> is sparse, the implementation does not account for this. The distribution vector is always initialized to be of type <code>Vector{Float64}</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/numlinalg/RLinearAlgebra.jl/blob/61eba4cab8fd3757402ef74aa524ca37fc701905/src/linear_samplers/linear_sampler_helpers/induced_distributions/leverage_scores.jl#L6-L48">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../linear_rsolve/">« Randomized Linear Solvers</a><a class="docs-footer-nextpage" href="../linear_solver_routines/">Main Solvers »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Thursday 10 July 2025 09:21">Thursday 10 July 2025</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
