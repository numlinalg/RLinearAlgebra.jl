var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"P.-G. Martinsson and J. Tropp. Randomized Numerical Linear Algebra: Foundations &amp; Algorithms (2020).\n\n\n\nN. Ailon and B. Chazelle. The Fast Johnson–Lindenstrauss Transform and Approximate Nearest Neighbors. SIAM Journal on Computing 39, 302–322 (2009).\n\n\n\nN. Halko, P. G. Martinsson and J. A. Tropp. Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review 53, 217–288 (2011).\n\n\n\n","category":"page"},{"location":"api/sub_solvers/#SubSolvers","page":"SubSolvers","title":"SubSolvers","text":"","category":"section"},{"location":"api/sub_solvers/","page":"SubSolvers","title":"SubSolvers","text":"Pages = [\"sub_solvers.md\"]","category":"page"},{"location":"api/sub_solvers/#Abstract-Types","page":"SubSolvers","title":"Abstract Types","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.SubSolver","page":"SubSolvers","title":"RLinearAlgebra.SubSolver","text":"SubSolver\n\nAn abstract supertype for structures specifying solution methods for a linear system or least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.SubSolverRecipe","page":"SubSolvers","title":"RLinearAlgebra.SubSolverRecipe","text":"SubSolverRecipe\n\nAn abstract supertype for structures with pre-allocated memory for methods that solve a linear system or least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#SubSolver-Structures","page":"SubSolvers","title":"SubSolver Structures","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.LQSolver","page":"SubSolvers","title":"RLinearAlgebra.LQSolver","text":"LQSolver <: SubSolver\n\nA type containing information relevant to solving the linear subsystems created by the      Solver routines with the LQ factorization. As there are no user controlled parameters,      if the user wishes to use this method they can simply specify LQSolver().\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.LQSolverRecipe","page":"SubSolvers","title":"RLinearAlgebra.LQSolverRecipe","text":"LQSolverRecipe <: SubSolverRecipe{M<:AbstractArray}\n\nA mutable type containing informtation relevant to solving the linear subsytems created by      the Solver routines with the LQ factorization.\n\nFields\n\nA::M, The matrix in the linear system that will be solved with the LQ solver.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.QRSolver","page":"SubSolvers","title":"RLinearAlgebra.QRSolver","text":"QRSolver <: SubSolver\n\nA type containing information relevant to solving the linear subsystems created by the      Solver routines with the QR factorization. As there are no user controlled parameters,      if the user wishes to use this method they can simply specify QRSolver().\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.QRSolverRecipe","page":"SubSolvers","title":"RLinearAlgebra.QRSolverRecipe","text":"QRSolverRecipe{M<:AbstractArray} <: SubSolverRecipe\n\nA mutable type containing information relevant to solving the linear subsystems created by      the Solver routines with the QR factorization.\n\nFields\n\nA::M, The matrix in the linear system that will be solved with the QR solver.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#Exported-Functions","page":"SubSolvers","title":"Exported Functions","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.complete_sub_solver","page":"SubSolvers","title":"RLinearAlgebra.complete_sub_solver","text":"complete_sub_solver(solver::SubSolver, A::AbstractArray)\n\nA function that generates a SubSolverRecipe given the      arguments.\n\nArguments\n\nsolver::SubSolver, a user-specified sub-solving method.\nA::AbstractArray, a coefficient matrix or vector. \n\nReturns\n\nA SubSolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/sub_solvers/#RLinearAlgebra.update_sub_solver!","page":"SubSolvers","title":"RLinearAlgebra.update_sub_solver!","text":"update_sub_solver!(solver::SubSolverRecipe, A::AbstractArray)\n\nA function that updates the SubSolver in place given      arguments.\n\nArguments\n\nsolver::SubSolverRecipe, a fully initialized realization for a   linear sub-solver.\nA::AbstractArray, a coefficient matrix or vector. \n\nReturns\n\nModifies the SubSolverRecipe in place given the arguments.and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#Compressors","page":"Compressors Overview","title":"Compressors","text":"","category":"section"},{"location":"api/compressors/","page":"Compressors Overview","title":"Compressors Overview","text":"Pages = [\"compressors.md\"]","category":"page"},{"location":"api/compressors/#Abstract-Types","page":"Compressors Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.Compressor","page":"Compressors Overview","title":"RLinearAlgebra.Compressor","text":"Compressor\n\nAn abstract supertype for structures that contain user-controlled parameters corresponding to techniques that compress a matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CompressorRecipe","page":"Compressors Overview","title":"RLinearAlgebra.CompressorRecipe","text":"CompressorRecipe\n\nAn abstract supertype for structures that contain both the user-controlled parameters in the Compressor and the memory allocations necessary for applying the compression technique to a particular set of matrices and vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CompressorAdjoint","page":"Compressors Overview","title":"RLinearAlgebra.CompressorAdjoint","text":"CompressorAdjoint{S<:CompressorRecipe}\n\nA structure for the adjoint of a compression recipe.\n\nFields\n\nParent::CompressorRecipe, the CompressorRecipe the adjoint is being applied to.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Cardinality","page":"Compressors Overview","title":"RLinearAlgebra.Cardinality","text":"Cardinality\n\nAn abstract type for types that specify whether a compressor will be applied from the left or the right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Left","page":"Compressors Overview","title":"RLinearAlgebra.Left","text":"Left <: Cardinality\n\nA struct indicating matrix multiplication from the left.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Right","page":"Compressors Overview","title":"RLinearAlgebra.Right","text":"Right <: Cardinality\n\nA struct indicating matrix multiplication from the right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Undef","page":"Compressors Overview","title":"RLinearAlgebra.Undef","text":"Undef <: Cardinality\n\nA struct indicating matrix multiplication is undefined.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#Compressor-Structures","page":"Compressors Overview","title":"Compressor Structures","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.Gaussian","page":"Compressors Overview","title":"RLinearAlgebra.Gaussian","text":"Gaussian <: Compressor\n\nA specification for a Gaussian compressor.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress.\n\nIf we want to compress A from the left (i.e., we reduce the number of rows), then we create a Gaussian sketch matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Each entry of S is generated independently following N(0, 1/s), namely, a Gaussian distribution with mean being zero and variance being 1 divided by the compression dimension.\n\nIf A is compressed from the right, then we create a Gaussian sketch matrix, S, with dimension n times s, where s is the compression dimension that is supplied by the user. Each entry of S is generated independently following N(0, 1/s), namely, a Gaussian distribution with mean being zero and variance being 1 divided by the compression dimension.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in    the mathematical description.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nGaussian(;cardinality=Left(), compression_dim=2, type=Float64)\n\nArguments\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in    the mathemtical description. By default this is set to 2.\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA Gaussian object.\n\nThrows\n\nArgumentError if compression_dim is non-positive\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.GaussianRecipe","page":"Compressors Overview","title":"RLinearAlgebra.GaussianRecipe","text":"GaussianRecipe <: CompressorRecipe\n\nThe recipe containing all allocations and information for the Gaussian compressor.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The\n\nvalue is either Left() or Right().\n\ncompression_dim::Int64, the target compression dimension.\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nscale::Number, the standard deviation of Gaussian distribution during the \n\ncompression matrix generation.\n\nop::Matrix{Float64}, the Gaussian compression matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SparseSign","page":"Compressors Overview","title":"RLinearAlgebra.SparseSign","text":"SparseSign <: Compressor\n\nAn implementation of the sparse sign compression method. This method forms a sparse matrix with a fixed number of non-zeros per row or column depending on the direction that the compressor is being applied. See Section 9.2 of [1] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a sparse sign matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. In this case, each column of S is generated independently by the following steps:\n\nRandomly choose nnz components of the the s components of the column. Note, nnz  is supplied by the user.\nFor each selected component, randomly set it either to -1sqrttextnnz or  1sqrttextnnz with equal probability.\nSet the remaining components of the column to zero.\n\nIf A is compressed from the right, then we create a sparse sign matrix, S, with dimension n times s, where s is the compression dimension that is supplied by the user. In this case, each row of S is generated independently by the following steps:\n\nRandomly choose nnz components fo the s components of the row. Note, nnz  is supplied by the user.\nFor each selected component, randomly set it either to -1sqrttextnnz or  1sqrttextnnz with equal probability.\nSet the remaining components of the row to zero.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nnnz::Int64, the target number of nonzeros for each column or row of the spares sign   matrix.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nSparseSign(;carinality=Left(), compression_dim=2, nnz::Int64=8, type=Float64)\n\nKeywords\n\ncarinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\nnnz::Int64, the number of non-zeros per row/column in the sampling matrix. By default   this is set to min(compressiond_dim, 8).\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA SparseSign object.\n\nThrows\n\nArgumentError if compression_dim is non-positive, if nnz is exceeds   compression_dim, or if nnz is non-positive.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SparseSignRecipe","page":"Compressors Overview","title":"RLinearAlgebra.SparseSignRecipe","text":"SparseSignRecipe{C<:Cardinality} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the SparseSign compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to\n\nbe applied to a target matrix or operator. Values allowed are Left() or Right().\n\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nnnz::Int64, the number of non-zero entries in each row if cardinality==Left or the\n\nnumber of non-zero entries each column if cardinality==Right.\n\nscale::Vector{Number}, the set of values of the non-zero entries of the Spares Sign\n\ncompression matrix.\n\nop::SparseMatrixCSC, the Spares Sign compression matrix.\n\nConstructors\n\nSparseSignRecipe(\n    cardinality::C where C<:Cardinality,\n    compression_dim::Int64, \n    A::AbstractMatrix, \n    nnz::Int64, \n    type::Type{<:Number}\n)\n\nAn external constructor of SparseSignRecipe that is dispatched based on the  value of cardinality. See SparseSign for additional details. \n\nArguments\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The    value is either Left() or Right()\ncompression_dim::Int64, the target compression dimension.\nA::AbstractMatrix, a target matrix for compression. \nnnz::Int64, the number of nonzeros in the Sparse Sign compression matrix.\ntype::Type{<:Number}, the data type for the entries of the compression matrix.\n\nReturns\n\nA SparseSignRecipe object.\n\nwarning: Use `complete_compressor`\nWhile an external constructor is provided, it is mainly for internal use. To ensure cross library compatibility please use complete_compressor for forming the SparseSignRecipe.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.FJLT","page":"Compressors Overview","title":"RLinearAlgebra.FJLT","text":"FJLT <: Compressor\n\nAn implementation of the Fast Johnson-Lindenstrauss Transform method. This technique applies a sparse matrix, a Walsh-Hadamard transform, and a diagonal sign matrix to produce a sketch.  See [2] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Here S=KHD where \n\nK is a sparse matrix with  with dimension s times m, where each entry has    probability q of being non-zero, and, if it is non-zero, then its value is    drawn from an independent normal distribution with mean 0 and variance 1q;\nH is a Hadamard matrix of dimension m times m, which is implicitly applied    through the fast Walsh-Hadamard transform;\nD of is a diagonal matrix of dimension m times m with entries given by    independent Rademacher variables.\n\nIf we want to compress A from the right (i.e., we reduce the number of columns), then  we would apply S=DHK from the right where the dimensions of the matrices are adjusted  to reflect the number of columns in A.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nblock_size::Int64, the number of vectors in the padding matrix.\nsparsity::Int64, the desired sparsity of the matrix K.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nFJLT(;\n    cardinality=Left(),\n    compression_dim::Int64=2,\n    block_size::Int64=10,\n    sparsity::Float64=0.0,\n    type::Type{N}=Float64,\n) where {N<:Number}\n\nKeywords\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description. By default this is set to 2.\nblock_size::Int64, the number of vectors in the padding matrix.\nsparsity::Int64, the desired sparsity of the matrix K, by default sparsity will be    set to be minleft(14 log(n)^2  m 1right), see [2].\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA FJLT object.\n\nThrows\n\nArgumentError if compression_dim is non-positive, if sparsity is not in 01,   or if block_size is non-positive.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.FJLTRecipe","page":"Compressors Overview","title":"RLinearAlgebra.FJLTRecipe","text":"FJLTRecipe{C<:Cardinality, S<:SparseMatrixCSC, M<:AbstractMatrix} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the FJLT compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are Left() or Right().\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nsparsity:Float64, the sparsity, q, of the sparse component, K.\nscale::Float64, the factor to ensure the isopmorphism of the sketch.\nop::SparseMatrixCSC, the sparse matrix K in the mathematical description.\nsigns::BitVector, the vector of signs where 0 indicates negative one and 1 indicates   positive one. \npadding::AbstractMatrix, the matrix containing the padding for the matrix being sketched.\n\nConstructor\n\nFJLTRecipe(\n    compression_dim::Int64, \n    block_size::Int64,\n    cardinality::C where {C<:Cardinality},\n    sparsity::Float64,\n    A::AbstractMatrix, \n    type::Type{<:Number}\n)\n\nKeywords\n\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\nblock_size::Int64, the number of columns in the padding memory buffer.\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\nsparsity::Vector{Number}, the expected sparsity of the Sparse operator matrix.\nA::AbstractMatrix, the matrix being compressed.\ntype::Type{<:Number}, the type of elements in the compressor.\n\ninfo: Info\nIf the sparsity parameter is set to 0.0, then the sparsity will be set to  minleft(14 log(n)^2  m 1right), see [2].\n\nReturns\n\nA FJLTRecipe object.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#Exported-Functions","page":"Compressors Overview","title":"Exported  Functions","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.complete_compressor","page":"Compressors Overview","title":"RLinearAlgebra.complete_compressor","text":"complete_compressor(compressor::Compressor, A::AbstractMatrix)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nA::AbstractMatrix, a target matrix for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\ncomplete_compressor(compressor::Compressor, A::AbstractMatrix, b::AbstractVector)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\ncomplete_compressor(\n    compressor::Compressor, \n    x::AbstractVector\n    A::AbstractMatrix, \n    b::AbstractVector, \n)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nx::AbstractVector, a vector that ususally represents a current iterate    typically used in a solver.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.update_compressor!","page":"Compressors Overview","title":"RLinearAlgebra.update_compressor!","text":"update_compressor!(S::CompressorRecipe)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(S::CompressorRecipe, A::AbstractMatrix)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nA::AbstractMatrix, a target matrix for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(S::CompressorRecipe, A::AbstractMatrix, b::AbstractVector)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(\n    S::CompressorRecipe, \n    A::AbstractMatrix, \n    b::AbstractVector,\n    x::AbstractMatrix\n)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nx::AbstractVector, a vector that ususally represents a current iterate    typically used in a solver.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#Internal-Functions","page":"Compressors Overview","title":"Internal Functions","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.left_mul_dimcheck","page":"Compressors Overview","title":"RLinearAlgebra.left_mul_dimcheck","text":"left_mul_dimcheck(C::AbstractMatrix, S::CompressorRecipe, A::AbstractMatrix)\n\nA function that checks the compatibility of arguments for multiplication from the left.\n\nArguments\n\nC::AbstractMatrix, a matrix where the output will be stored.\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nA::AbstractMatrix, a target matrix for compression.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\nleft_mul_dimcheck(C::AbstractMatrix, S::CompressorAdjoint, A::AbstractMatrix)\n\nA function that checks the compatibility of arguments for multiplication from the left.\n\nArguments\n\nC::AbstractMatrix, a matrix where the output will be stored.\nS::CompressorAdjoint, the representation of an adjoint   of a compression operator.\nA::AbstractMatrix, a target matrix for compression.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.right_mul_dimcheck","page":"Compressors Overview","title":"RLinearAlgebra.right_mul_dimcheck","text":"right_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix, S::CompressorRecipe)\n\nA function that checks the compatibility of arguments for multiplication from the right.\n\nArguments\n\nC::AbstractMatrix, a matrix where the output will be stored.\nA::AbstractMatrix, a target matrix for compression.\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\nright_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix, S::CompressorAdjoint)\n\nA function that checks the compatibility of arguments for multiplication from the right.\n\nArguments\n\nC::AbstractMatrix, a matrix where the output will be stored.\nA::AbstractMatrix, a target matrix for compression.\nS::CompressorAdjoint, the representation of an adjoint   of a compression operator.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.sparse_idx_update!","page":"Compressors Overview","title":"RLinearAlgebra.sparse_idx_update!","text":"sparse_idx_update!(\n    values::Vector{Int64}, \n    max_sample_val::Int64, \n    n_samples::Int64, \n    sample_size::Int64\n)\n\nImplicitly splits values into n_samples components of size sample_size.  On each component, replaces the entries of each component with a random sample  without replacement of size sample_size from the set 1:max_sample_val.\n\nwarn: Warn\nvalues should have length equal to sample_size*n_samples, but this  is not checked. \n\nArguments\n\nvalues::Vector{Int64}, a vector containing samples from 1:max_sample_val.\nmax_sample_val::In64, implicitly supplies the set from which to sample,   1:max_sample_val.\nn_samples::Int64, the number of components that values is implicitly split into. \nsample_size::Int64, the size each component that values is split into.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.fwht!","page":"Compressors Overview","title":"RLinearAlgebra.fwht!","text":"fwht!(x::AbstractVector, signs::BitVector; scaling::Int64 = 1)\n\nPerforms an in-place Fast Walsh Hadamard Transform on the vector x.   signs allows the user to input a boolean vector that flips the signs of the entries  of the vector x before applying the transform. scaling allows the user to scale the  result of the transform. Choosing a scaling of 1/sqrt{size(x)} will result in the FWHT  being an orthogonal transform.\n\nArguments\n\nx::AbstractVector, the vector the FJLT will be applied to.\nsigns::Vector{Bool}, whether the sign of each entry is positive or negative.\n\nKeywords\n\nscaling::Number, how much the vector is scaled, by default this is 1.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#Loggers","page":"Loggers","title":"Loggers","text":"","category":"section"},{"location":"api/loggers/","page":"Loggers","title":"Loggers","text":"Pages = [\"loggers.md\"]","category":"page"},{"location":"api/loggers/#Abstract-Types","page":"Loggers","title":"Abstract Types","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.Logger","page":"Loggers","title":"RLinearAlgebra.Logger","text":"Logger\n\nAn abstract supertype for structures that record the progress of a SolverRecipe applied to a coefficient matrix and constant vector.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#RLinearAlgebra.LoggerRecipe","page":"Loggers","title":"RLinearAlgebra.LoggerRecipe","text":"LoggerRecipe\n\nAn abstract supertype for a structure that contains pre-allocated memory for a method that records the progress of a SolverRecipe.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#Logger-Structures","page":"Loggers","title":"Logger Structures","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.BasicLogger","page":"Loggers","title":"RLinearAlgebra.BasicLogger","text":"BasicLogger <: Logger\n\nThis is a mutable struct that contains the max_it parameter and stores the error metric      in a vector. Checks convergence of the solver based on the log information.\n\nFields\n\nmax_it::Int64, The maximum number of iterations for the solver. If not specified by the  user, it is set to 3 times the number of rows in the matrix.\nthreshold_info::Union{Float64, Tuple}, The parameters used for stopping the algorithm.\ncollection_rate::Int64, the rate that history is gathered. (Note: The last value is   always recorded.)\nstopping_criterion::Function, function that evaluates the stopping criterion.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#RLinearAlgebra.BasicLoggerRecipe","page":"Loggers","title":"RLinearAlgebra.BasicLoggerRecipe","text":"BasicLoggerRecipe <: LoggerRecipe\n\nThis is a mutable struct that contains the max_it parameter and stores the error metric      in a vector. Checks convergence of the solver based on the log information.\n\nFields\n\nmax_it::Int64, The maximum number of iterations for the solver.\nerror::Float64, The current error metric.\nthreshold_info::Union{Float64, Tuple}, The parameters used for stopping the algorithm.\niteration::Int64, the current iteration of the solver.\nrecord_location::Int64, the location in the history vector of the most recent entry.\ncollection_rate::Int64, the rate that history is gathered. (Note: The last value is   always recorded.)\nconverged::Bool, A boolean indicating whether the stopping criterion is satisfied.\nStoppingCriterion::Function, function that evaluates the stopping criterion.\nhist:AbstractVector, vector that contains the history of the error metric.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#Exported-Functions","page":"Loggers","title":"Exported Functions","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.complete_logger","page":"Loggers","title":"RLinearAlgebra.complete_logger","text":"complete_logger(logger::Logger)\n\nA function that generates a LoggerRecipe given the      arguments.\n\nArguments\n\nlogger::Logger, a user-specified logging method.\n\nReturns\n\nA LoggerRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.update_logger!","page":"Loggers","title":"RLinearAlgebra.update_logger!","text":"update_logger!(logger::LoggerRecipe, err::Float64, iteration::Int64)\n\nA function that updates the LoggerRecipe in place given      arguments.\n\nArguments\n\nlogger::LoggerRecipe, a fully initialized realization for a    logging method for a specific linear or least squares solver.\nerr::Real, an error value to be logged. \niteration::Int64, the iteration of the solver. \n\nReturns\n\nPerforms an inplace update to the LoggerRecipe and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.reset_logger!","page":"Loggers","title":"RLinearAlgebra.reset_logger!","text":"reset_logger!(logger::LoggerRecipe)\n\nA function that resets the LoggerRecipe in place.\n\nArguments\n\nlogger::LoggerRecipe, a fully initialized realization for a    logging method for a specific linear or least squares solver.\n\nReturns\n\nPerforms an inplace update to the LoggerRecipe and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.threshold_stop","page":"Loggers","title":"RLinearAlgebra.threshold_stop","text":"threshold_stop(log::BasicLoggerRecipe)\n\nFunction that takes an input threshold and stops when the most recent entry in the history vector is less than the threshold.\n\nArguments\n\nlog::LoggerRecipe, a structure containing the logger information\n\nBool\n\nReturns a Bool indicating if the stopping threshold is satisfied.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"api/distributions/","page":"Distributions","title":"Distributions","text":"Pages = [\"distributions.md\"]","category":"page"},{"location":"api/distributions/#Abstract-Types","page":"Distributions","title":"Abstract Types","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.Distribution","page":"Distributions","title":"RLinearAlgebra.Distribution","text":"Distribution\n\nAn abstract supertype for structures specifying distribution for indices in sampling methods.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#RLinearAlgebra.DistributionRecipe","page":"Distributions","title":"RLinearAlgebra.DistributionRecipe","text":"DistributionRecipe\n\nAn abstract supertype for structures with pre-allocated memory for distribution function     sampling methods.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#Distribution-Structures","page":"Distributions","title":"Distribution Structures","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.Uniform","page":"Distributions","title":"RLinearAlgebra.Uniform","text":"Uniform <: Distribution\n\nUniform distribution over the row/column index set of a matrix.\n\nMathematical Description\n\nDuring the sampling, the uniform distribution is defined on the domain of row/column  indices. If it's compressing from the left, then it means every row index has the same  probability weight. If it's compressing from the right, then it means every column index  has the same probability weight.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right()    or Undef().\nreplace::Bool, if true, then the sampling occurs with replacement; if false,    then the sampling occurs without replacement.\n\nConstructor\n\nUniform(;cardinality=Undef(), replace = false)\n\nReturns\n\nA Uniform object.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#RLinearAlgebra.UniformRecipe","page":"Distributions","title":"RLinearAlgebra.UniformRecipe","text":"UniformRecipe <: DistributionRecipe\n\nThe recipe containing all allocations and information for the uniform distribution.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The   value is either Left() or Right() or Undef().\nreplace::Bool, an option to replace or not during the sampling process based    on the given weights.\nstate_space::Vector{Int64}, the row/column index set.\nweights::ProbabilityWeights, the weights of each element in the state space.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#Exported-Functions","page":"Distributions","title":"Exported Functions","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.complete_distribution","page":"Distributions","title":"RLinearAlgebra.complete_distribution","text":"complete_distribution(distribution::Distribution, A::AbstractMatrix)\n\nA function that generates a DistributionRecipe given the      arguments.\n\nArguments\n\ndistribution::Distribution, a user-specified distribution function for sampling.\nA::AbstractMatrix, a coefficient matrix. \n\nOutputs\n\nA DistributionRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#RLinearAlgebra.update_distribution!","page":"Distributions","title":"RLinearAlgebra.update_distribution!","text":"update_distribution!(distribution::DistributionRecipe, A::AbstractMatrix)\n\nA function that updates the DistributionRecipe in place given      arguments.\n\nArguments\n\ndistribution::DistributionRecipe, a fully initialized realization of distribution.\nA::AbstractMatrix, a coefficient matrix. \n\nOutputs\n\nModifies the DistributionRecipe in place and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#RLinearAlgebra.sample_distribution!","page":"Distributions","title":"RLinearAlgebra.sample_distribution!","text":"sample_distribution!(x::AbstractVector, distribution::DistributionRecipe)\n\nA function that in place updates the x by given DistributionRecipe info.\n\nArguments\n\nx::AbstractVector, an abstract vector to store the sampled indices. \ndistribution::DistributionRecipe, a fully initialized realization of distribution.\n\nOutputs\n\nModifies the x in place by sampling that follows the weights and replacement given by \n\n'DistributionRecipe'.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#Internal-Functions","page":"Distributions","title":"Internal Functions","text":"","category":"section"},{"location":"api/approximators/#Approximators","page":"Approximators Overview","title":"Approximators","text":"","category":"section"},{"location":"api/approximators/","page":"Approximators Overview","title":"Approximators Overview","text":"Pages = [\"approximators.md\"]","category":"page"},{"location":"api/approximators/#Abstract-Types","page":"Approximators Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.Approximator","page":"Approximators Overview","title":"RLinearAlgebra.Approximator","text":"Approximator\n\nAn abstract supertype for structures that store user-controlled parameters corresponding to techniques that form low-rank approximations of the matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.ApproximatorRecipe","page":"Approximators Overview","title":"RLinearAlgebra.ApproximatorRecipe","text":"ApproximatorRecipe\n\nAn abstract supertype for structures that store user-controlled parameters, linear system dependent parameters and preallocated memory corresponding to techniques that form low-rank approximations of the matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.ApproximatorAdjoint","page":"Approximators Overview","title":"RLinearAlgebra.ApproximatorAdjoint","text":"ApproximatorAdjoint{S<:ApproximatorRecipe} <: ApproximatorRecipe\n\nA structure for the adjoint of an ApproximatorRecipe.\n\nFields\n\nParent::ApproximatorRecipe, the approximator that we compute the adjoint of.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeApproximator","page":"Approximators Overview","title":"RLinearAlgebra.RangeApproximator","text":"RangeApproximator\n\nAn abstract type for the structures that contain the user-controlled parameters  corresponding to the Approximator methods that produce an orthogonal approximation to the  range of a matrix A. This includes methods like the RandomizedSVD and  randomized rangefinder.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeApproximatorRecipe","page":"Approximators Overview","title":"RLinearAlgebra.RangeApproximatorRecipe","text":"RangeApproximatorRecipe\n\nAn abstract type for the structures that contain the user-controlled parameters,  linear system information, and preallocated memory for methods corresponding to the Approximator methods that produce an orthogonal approximation to the range of a matrix A. This includes methods like the RandomizedSVD and  randomized rangefinder.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#Approximator-Structures","page":"Approximators Overview","title":"Approximator Structures","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.RangeFinder","page":"Approximators Overview","title":"RLinearAlgebra.RangeFinder","text":"RangeFinder\n\nA struct that implements the Randomized Range Finder technique which uses compression from      the right to form an low-dimensional orthogonal matrix Q that approximates the      range of A. See [3] for additional details.\n\nMathematical Description\n\nSuppose we have a matrix A in mathbbR^m times n of which we wish to form a low      rank approximation that approximately captures the range of A. Specifically, we wish     to find an Orthogonal matrix Q such that QQ^top A approx A. \n\nA simple way to find such a matrix is to choose a ``k`` representing the number of \nvectors we wish to have in the subspace. Then we can generate a compression matrix \n``S\\in\\mathbb{R}^{n \\times k}`` and compute ``Q = \\text{qr}(AS)``. \nWith high probability we will have ``\\|A - QQ^\\top A\\|_2 \\leq\n(k+1) \\sigma_{k+1}``, where ``\\sigma_{k+1}`` is the ``k+1^\\text{th}`` singular value \nof A. This bound is often conservative when the singular values of ``A`` decay quickly. \nIn the case where the singular values decay slowly, by computing the qr factorization of\n``(AA^\\top)^q AS``, this is known as taking ``q`` power iterations. Power iterations \ndrive the ``k+1`` constant in front of ``\\sigma_{k+1}`` in the bound closer to 1, \nleading to more accurate approximations. One can also improve the stability of these \npower iterations be orthogonalizing each matrix in what is known as the random subspace \niteration.\n\nFields\n\ncompressor::Compressor, the technique that will compress the matrix from the right.\npower_its::Int64, the number of power iterations that should be performed.\nrand_subspace::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeFinderRecipe","page":"Approximators Overview","title":"RLinearAlgebra.RangeFinderRecipe","text":"RangeFinderRecipe\n\nA struct that contains the preallocated memory and completed compressor to form a     RangeFinder approximation to the matrix A.\n\nFields\n\ncompressor::CompressorRecipe, the compressor to be applied from the right to A.\npower_its::Int64, the number of power iterations that should be performed.\nrand_subspace::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\nrange::AbstractMatrix, the orthogonal matrix that approximates the range of A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#Exported-Functions","page":"Approximators Overview","title":"Exported Functions","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.complete_approximator","page":"Approximators Overview","title":"RLinearAlgebra.complete_approximator","text":"complete_approximator(approximator::Approximator, A::AbstractMatrix)\n\nA function that generates an ApproximatorRecipe given      arguments.\n\nArguments\n\napproximator::Approximator, a data structure containing the   user-defined parameters associated with a particular low-rank approximation.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rapproximate","page":"Approximators Overview","title":"RLinearAlgebra.rapproximate","text":"rapproximate(approximator::Approximator, A::AbstractMatrix)\n\nA function that computes a low-rank approximation of the matrix A     using the information in the provided Approximator data structure.\n\nArguments\n\napproximator::Approximator, a data structure containing the   user-defined parameters associated with a particular low-rank approximation.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rapproximate!","page":"Approximators Overview","title":"RLinearAlgebra.rapproximate!","text":"rapproximate!(approximator::ApproximatorRecipe, A::AbstractMatrix)\n\nA function that computes a low-rank approximation of the matrix A     using the information in the provided Approximator data structure.\n\nArguments\n\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#Internal-Functions","page":"Approximators Overview","title":"Internal Functions","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.rand_power_it","page":"Approximators Overview","title":"RLinearAlgebra.rand_power_it","text":"rand_power_it(approx::RangeFinderRecipe, A::AbstractMatrix)\n\nFunction that performs the randomized rangefinder procedure presented in Algortihm 4.3 of  [3].\n\nArguments\n\napprox::RangeFinderRecipe, a RangeFinderRecipe structure that contains the compressor\n\nrecipe.\n\nA::AbstractMatrix, the matrix being approximated.\n\nReturns\n\nQ::AbstractMatrix, an economical Q approximating the range of A.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rand_subspace_it","page":"Approximators Overview","title":"RLinearAlgebra.rand_subspace_it","text":"rand_subspace_it(approx::RangeFinderRecipe, A::AbstractMatrix)\n\nFunction that performs the randomized rangefinder procedure presented in Algortihm 4.4 of  [3].\n\nArguments\n\napprox::RangeFinderRecipe, a RangeFinderRecipe structure that contains the compressor\n\nrecipe.\n\nA::AbstractMatrix, the matrix being approximated.\n\nReturns\n\nQ::AbstractMatrix, an economical Q approximating the range of A.\n\n\n\n\n\n","category":"function"},{"location":"api/solver_errors/#SolverErrors","page":"SolverErrors","title":"SolverErrors","text":"","category":"section"},{"location":"api/solver_errors/","page":"SolverErrors","title":"SolverErrors","text":"Pages = [\"solver_errors.md\"]","category":"page"},{"location":"api/solver_errors/#Abstract-Types","page":"SolverErrors","title":"Abstract Types","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.SolverError","page":"SolverErrors","title":"RLinearAlgebra.SolverError","text":"SolverError\n\nAn abstract supertype for structures that track and/or evaluate the quality of a solution for a linear system or least squares.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#RLinearAlgebra.SolverErrorRecipe","page":"SolverErrors","title":"RLinearAlgebra.SolverErrorRecipe","text":"SolverErrorRecipe\n\nAn abstract supertype for structures that contain the user-controlled parameters, linear system dependent parameters, and preallocated memory for techniques that evaluate the solution to a linear solver.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#SolverError-Structures","page":"SolverErrors","title":"SolverError Structures","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.FullResidual","page":"SolverErrors","title":"RLinearAlgebra.FullResidual","text":"FullResidual <: SolverError\n\nA SolverError structure for computing the norm of the full residual, b-Ax.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#RLinearAlgebra.FullResidualRecipe","page":"SolverErrors","title":"RLinearAlgebra.FullResidualRecipe","text":"FullResidual <: SolverErrorRecipe\n\nA SolverErrorResidual structure for computing the norm of the full residual, b-Ax\n\nFields\n\nresidual::AbstractVector, a container for the residual b-Ax.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#Exported-Functions","page":"SolverErrors","title":"Exported Functions","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.complete_error","page":"SolverErrors","title":"RLinearAlgebra.complete_error","text":"complete_error(\n    error::SolverError, \n    solver::Solver,\n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that generates a SolverErrorRecipe given the      arguments.\n\nArguments\n\nerror::SolverError, a user-specified solver error method.\nsolver::Solver, a user-specified solver method.\nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nReturns\n\nA SolverErrorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solver_errors/#RLinearAlgebra.compute_error","page":"SolverErrors","title":"RLinearAlgebra.compute_error","text":"compute_error(\n    error::SolverErrorRecipe, \n    solver::SolverRecipe, \n    x::AbstractVector,\n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that evaluates the error for a proposed solution      vector.\n\nArguments\n\nerror::SolverErrorRecipe, a fully initialized realization for   a solver error method for a specific linear system or least squares problem.\nsolver::SolverRecipe, a fully initialized realization for a    solver method for a specific linear system.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nReturns\n\nReturns nothing\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#Solvers","page":"Solvers Overview","title":"Solvers","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers Overview","title":"Solvers Overview","text":"Pages = [\"solvers.md\"]","category":"page"},{"location":"api/solvers/#Abstract-Types","page":"Solvers Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.Solver","page":"Solvers Overview","title":"RLinearAlgebra.Solver","text":"Solver\n\nAn abstract supertype for structures that contain the user-controlled parameters for methods that solve linear systems and least squares problems.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#RLinearAlgebra.SolverRecipe","page":"Solvers Overview","title":"RLinearAlgebra.SolverRecipe","text":"SolverRecipe\n\nAn abstract supertype specifying a solver method with pre-allocated data structures given a coefficient matrix and constant vector.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#Solver-Structures","page":"Solvers Overview","title":"Solver Structures","text":"","category":"section"},{"location":"api/solvers/#Exported-Functions","page":"Solvers Overview","title":"Exported Functions","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.complete_solver","page":"Solvers Overview","title":"RLinearAlgebra.complete_solver","text":"complete_solver(solver::Solver, x::AbstractVector, A::AbstractMatrix, b::AbstractVector)\n\nA function that generates a SolverRecipe given the      arguments.\n\nArguments\n\nsolver::Solver, a user-specified solver method.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nA SolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.rsolve!","page":"Solvers Overview","title":"RLinearAlgebra.rsolve!","text":"rsolve!(\n    solver::SolverRecipe, \n    x::AbstractVector, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that solves a linear system given the arguments.\n\nArguments\n\nsolver::SolverRecipe, a fully initialized realization for a    solver method for a specific linear system.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nReturns nothing. Updates the SolverRecipe and x in place.\n\n\n\n\n\nrsolve!(\n    solver::Solver, \n    x::AbstractVector, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that solves a linear system given the arguments.\n\nArguments\n\nsolver::Solver, a user-specified solver method.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nx::AbstractVector, a proposed solution to a linear system or least squares    problem.\nA SolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#ApproximatorErrors","page":"ApproximatorErrors","title":"ApproximatorErrors","text":"","category":"section"},{"location":"api/approximator_errors/","page":"ApproximatorErrors","title":"ApproximatorErrors","text":"Pages = [\"approximator_errors.md\"]","category":"page"},{"location":"api/approximator_errors/#Abstract-Types","page":"ApproximatorErrors","title":"Abstract Types","text":"","category":"section"},{"location":"api/approximator_errors/#RLinearAlgebra.ApproximatorError","page":"ApproximatorErrors","title":"RLinearAlgebra.ApproximatorError","text":"ApproximatorError\n\nAn abstract supertype for structures containing user-controlled parameters corresponding to methods that evaluate the quality of a low-rank approximation of a matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximator_errors/#RLinearAlgebra.ApproximatorErrorRecipe","page":"ApproximatorErrors","title":"RLinearAlgebra.ApproximatorErrorRecipe","text":"ApproximatorErrorRecipe\n\nAn abstract supertype for structures containing user-controlled parameters, matrix dependent parameters and preallocated memory corresponding to methods that evaluate the quality of a low-rank approximation of a matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximator_errors/#ApproximatorError-Structures","page":"ApproximatorErrors","title":"ApproximatorError Structures","text":"","category":"section"},{"location":"api/approximator_errors/#Exported-Functions","page":"ApproximatorErrors","title":"Exported Functions","text":"","category":"section"},{"location":"api/approximator_errors/#RLinearAlgebra.complete_approximator_error","page":"ApproximatorErrors","title":"RLinearAlgebra.complete_approximator_error","text":"complete_approximator_error(\n    error::ApproximatorError, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that generates an ApproximatorErrorRecipe     given the arguments.\n\nArguments\n\nerror::ApproximatorError, a data structure containing   the user-defined parameters associated with a particular low-rank approximation error   method.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorErrorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#RLinearAlgebra.compute_approximator_error","page":"ApproximatorErrors","title":"RLinearAlgebra.compute_approximator_error","text":"compute_approximator_error(\n    error::ApproximatorError, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that computes the approximation error of an     ApproximatorRecipe for a matrix A.\n\nArguments\n\nerror::ApproximatorError, a data structure containing   the user-defined parameters associated with a particular low-rank approximation error   method.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nReturns the error::Float64 \n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#RLinearAlgebra.compute_approximator_error!","page":"ApproximatorErrors","title":"RLinearAlgebra.compute_approximator_error!","text":"compute_approximator_error!(\n    error::ApproximatorErrorRecipe, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that computes the approximation error of an     ApproximatorRecipe for a matrix A.\n\nArguments\n\nerror::ApproximatorErrorRecipe, a fully initialized   realization for a low rank approximation error method for a particular matrix.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nReturns the error::Float64 \n\n\n\n\n\n","category":"function"},{"location":"#RLinearAlgebra","page":"Home","title":"RLinearAlgebra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RLinearAlgebra is a Julia library for the  development and application of randomized algorithms to the problems of forming low rank  approximations to matrices and finding the solution of linear systems and least squares  problems.  Because of the large diversity of randomized techniques, rather than offering isolated  routine implementations of algorithms, this library implements a series of extendable data  structures and methods which allow code reuse.","category":"page"},{"location":"#Documentation-structure","page":"Home","title":"Documentation structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation serves both as a manual to the library and as an introduction to  randomized linear approximation techniques and randomized linear algebra solvers.  We divide it in four parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorial: examples of how to solve linear systems and least squares problems with   RLinearAlgebra and how to extend the library.\nManual: here we offer an introduction to solving linear systems with randomized linear    algebra techniques, compressing a matrix, and forming a low-rank approximation of a matrix.    We introduce theoretical foundations and we provide code examples with RLinearAlgebra.\nAPI: a detailed description of all the data structures and methods of the library.\nDevelopment: detailed instructions on how to contribute to the library.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is supported by the National Science Foundation Office of Advanced  Cyberinfrastructure under awards  2309445 and  2309446. This material is based upon work supported by the U.S. Department of Energy, Office of  Science, under contract number DE-AC02-06CH11357.","category":"page"},{"location":"api/contents/#Randomized-Linear-Solver-Reference","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"","category":"section"},{"location":"api/contents/","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"Pages=[\n  \"approximators.md\",  \n  \"approximator_errors.md\",\n  \"compressors.md\",\n  \"solvers.md\",\n  \"solver_error.md\",\n  \"sub_solvers.md\",\n  \"loggers.md\"]","category":"page"}]
}
