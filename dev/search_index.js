var documenterSearchIndex = {"docs":
[{"location":"api/linear_rsolve/#Randomized-Linear-Solver","page":"Randomized Linear Solvers","title":"Randomized Linear Solver","text":"","category":"section"},{"location":"api/linear_rsolve/","page":"Randomized Linear Solvers","title":"Randomized Linear Solvers","text":"Pages=[\"linear_rsolve.md\"]","category":"page"},{"location":"api/linear_rsolve/#Abstract-Types","page":"Randomized Linear Solvers","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_rsolve/","page":"Randomized Linear Solvers","title":"Randomized Linear Solvers","text":"RLSSolver","category":"page"},{"location":"api/linear_rsolve/#RLinearAlgebra.RLSSolver","page":"Randomized Linear Solvers","title":"RLinearAlgebra.RLSSolver","text":"RLSSolver{S<:LinSysSampler, R<:LinSysSolveRoutine,\n    L<:LinSysSolverLog, C<:LinSysStopCriterion}\n\nAn encapsulation for a (R)andomized (L)inear (S)ysterm Solver as a mutable structure.\n\nFields\n\nsampler::S, a procedure for sampling, sketching or selecting with respect to a linear   system.\nroutine::R, a routine for randomly generating the subproblem generated by the sampling,   sketching or selecting operation\nlog::L, a logger for the progress and behavior of the randomized linear system solver.\nstop::C, a stopping criterion for the randomized linear system solver.\nx::Union{Vector{Float64},Nothing}, the result produced by the randomized linear system   solver.\n\nConstructions\n\nRLSSolver(iter::Int64) specifies a solver with: random cyclic row sampling;  partially   orthogonalized row projections (memory of five) subproblem solver; a full residual   logger; and a maximum iteration stopping criterion specified by iter.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_rsolve/#Solver-Functions","page":"Randomized Linear Solvers","title":"Solver Functions","text":"","category":"section"},{"location":"api/linear_rsolve/","page":"Randomized Linear Solvers","title":"Randomized Linear Solvers","text":"rsolve\n\nrsolve!","category":"page"},{"location":"api/linear_rsolve/#RLinearAlgebra.rsolve","page":"Randomized Linear Solvers","title":"RLinearAlgebra.rsolve","text":"rsolve([solver::RLSSolver,] A, b)\n\nDeploys an iterative randomized solver for the linear system whose coefficient matrix is     encapsulated in A and whose constant vector is encapsulated in b. If the solver     is not specified, then the default RLSSolver is constructed and used with a maximum     number of iterations of 10 * length(b). See RLSSolver for more details on the     default solver.\n\nThe function returns the solution.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_rsolve/#RLinearAlgebra.rsolve!","page":"Randomized Linear Solvers","title":"RLinearAlgebra.rsolve!","text":"rsolve!([solver::RLSSolver,] A, b, x::AbstractVector)\n\nIdentical to rsolve except an initial iterate is supplied by the argument x. The     function overwrites the solution into the vector x.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_solver_routines/#Linear-Subsolvers","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"Pages=[\"linear_solver_routines.md\"]","category":"page"},{"location":"api/linear_solver_routines/#Abstract-Types","page":"Linear Subsolvers","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"LinSysSolveRoutine\n\nLinSysVecRowProjection\n\nLinSysVecColProjection\n\nLinSysBlkRowProjection\n\nLinSysBlkColProjection\n\nLinSysPreconKrylov","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysSolveRoutine","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysSolveRoutine","text":"LinSysSolveRoutine\n\nAbstract supertype that specifies the type of linear system solver routine being deployed.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjection","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecRowProjection","text":"LinSysVecRowProjection <: LinSysSolveRoutine\n\nAbstract supertype for vector row action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjection","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecColProjection","text":"LinSysVecColProjection <: LinSysSolveRoutine\n\nAbstract supertype for vector column action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysBlkRowProjection","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysBlkRowProjection","text":"LinSysBlkRowProjection <: LinSysSolveRoutine\n\nAbstract supertype for block row action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysBlkColProjection","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysBlkColProjection","text":"LinSysBlkColProjection <: LinSysSolveRoutine\n\nAbstract supertype for block column action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysPreconKrylov","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysPreconKrylov","text":"LinSysPreconKrylov <: LinSysSolveRoutine\n\nAbstract supertype for preconditioned Krylov solver.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Vector-Row-Solvers","page":"Linear Subsolvers","title":"Vector Row Solvers","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"LinSysVecRowProjStd\n\nLinSysVecRowProjPO\n\nLinSysVecRowProjFO","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjStd","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecRowProjStd","text":"LinSysVecRowProjStd <: LinSysVecRowProjection\n\nA mutable structure that represents a standard row projection method.\n\nAliases\n\nKaczmarz, see Kaczmarz, M. S. \"Approximate solution of systems of linear equations.\"   (1937). Original article is in German.\nART, see Gordon, Richard, Robert Bender, and Gabor T. Herman. \"Algebraic reconstruction   techniques (ART) for three-dimensional electron microscopy and X-ray photography.\"   Journal of theoretical Biology 29.3 (1970): 471-481.\n\nFields\n\nalpha::Float64, a relaxation parameter that should be set between 0.0 and 2.0\n\nCalling LinSysVecRowProjStd() defaults the relaxation parameter to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjPO","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecRowProjPO","text":"LinSysVecRowProjPO <: LinSysVecRowProjection\n\nA mutable structure that represents the standard row projection method     with orthogonalization of the current projection against a set of m previous     projection directions, where m is specified by the user.\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nα::Float64, the relaxation parameter (usually between 0.0 and 2.0)\nm::Int64, the number of previous directions against which to orthogonalize\nZ::Union{Vector{Vector{Float64}}, Nothing}, stores the m vectors against which the   current projection is orthogonalized against\n\nCalling LinSysVecRowProjPO() defaults the relaxation parameter to 1.0, the memory     parameter m to 5, and Z to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjFO","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecRowProjFO","text":"LinSysVecRowProjFO <: LinSysVecRowProjection\n\nA mutable structure that represents the standard row projection method with full orthogonalization against all previous projections. Equivalently, this type represents a solver for incrementally constructed matrix sketches.\n\nSee McCormick, S. F. \"The methods of Kaczmarz and row orthogonalization for solving linear     equations and least squares problems in Hilbert space.\" Indiana University Mathematics     Journal 26.6 (1977): 1137-1150. https://www.jstor.org/stable/24891603\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nS::Union{Matrix{Float64}, Nothing} is a matrix used for orthogonalizing against   all previous search directions.\n\nCalling LinSysVecRowProjFO() defaults to LinSysVecRowProjFO(nothing).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Vector-Column-Solvers","page":"Linear Subsolvers","title":"Vector Column Solvers","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"LinSysVecColProjStd\n\nLinSysVecColProjPO\n\nLinSysVecColProjFO","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjStd","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecColProjStd","text":"LinSysVecColProjStd <: LinSysVecColProjection\n\nA mutable structure that represents a standard column projection method.\n\nSee Luo, Zhi-Quan, and Paul Tseng. \"On the convergence of the coordinate descent method     for convex differentiable minimization.\" Journal of Optimization Theory and     Applications 72.1 (1992): 7-35.\n\nFor a generalization, see Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado.     \"An Implicit Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nAliases\n\nCoordinateDescent\nGaussSeidel\n\nFields\n\nalpha::Float64, a relaxation parameter that should be set between 0.0 and 2.0\n\nCalling LinSysVecColProjStd() defaults the relaxatoin parameter to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjPO","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecColProjPO","text":"LinSysVecColProjPO <: LinSysVecColProjection\n\nA mutable structure that represents the standard column projection method     with orthogonalization of the current projection against a set of m previous     projection directions, where m is specified by the user.\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nα::Float64, the relaxation parameter (usually between 0.0 and 2.0)\nm::Int64, the number of previous directions against which to orthogonalize\nZ::Union{Vector{Vector{Float64}}, Nothing}, stores the m vectors against which the   current projection is orthogonalized against\n\nCalling LinSysVecColProjPO() defaults the relaxation parameter to 1.0, the memory     parameter m to 5, and Z to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjFO","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecColProjFO","text":"LinSysVecColProjFO <: LinSysVecColProjection\n\nA mutable structure that represents the standard column projection method with full orthogonalization against all previous projections.\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nS::Union{Matrix{Float64}, Nothing} is a matrix used for orthogonalizing against   all previous search directions.\n\nCalling LinSysVecColProjFO() defaults to LinSysVecColProjFO(nothing).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Subsolver-Function","page":"Linear Subsolvers","title":"Subsolver Function","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"RLinearAlgebra.rsubsolve!(::Nothing,::AbstractVector,::Tuple,::Int64)","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.rsubsolve!-Tuple{Nothing, AbstractVector{T} where T, Tuple, Int64}","page":"Linear Subsolvers","title":"RLinearAlgebra.rsubsolve!","text":"rsubsolve!(\n    type::LinSysSolveRoutine,\n    x::AbstractVector,\n    samp::Tuple,\n    iter::Int64)\n\nA common interface for specifying different strategies for solving a subproblem generated     by a sampling, selecting or sketching operation on a linear system. The type argument     is used to select the appropriately defined strategy. The argument x is the current     iterate value for the solution. The argument samp depends on the subtype     of LinSysSolveRoutine that is being deployed and is described below. The iter     argument is the iteration counter.\n\nThe value of samp depends on the type of subtype of LinSysSolveRoutine being deployed. To describe this, let A be the coefficient matrix of the system, and b its constant vector.\n\nFor T<:LinSysVecRowProjection, samp is a two-dimensional tuple where the first   entry is a vector in the row space of A; and the second entry is a scalar value   corresponding to a linear combination of the elements of b.\nFor T<:LinSysVecColProjection, samp is a three-dimensional tuple where the first   entry is a vector of length(x) corresponding to the search direction; the second   entry is a matrix with the same number of rows as A (usually it is A);   and the third entry is a scalar-valued residual for the normal system corresponding   to samp[1]'* A' * (A * x - b).\n\nThe function rsubsolve! updates the quantity x and any fields of type that must be     updated.\n\n\n\n\n\n","category":"method"},{"location":"api/linear_solver_stops/#Linear-Solver-Stop-Criteria","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"Pages=[\"linear_solver_stops.md\"]","category":"page"},{"location":"api/linear_solver_stops/#Abstract-Types","page":"Linear Solver Stop Criteria","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"LinSysStopCriterion","category":"page"},{"location":"api/linear_solver_stops/#RLinearAlgebra.LinSysStopCriterion","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.LinSysStopCriterion","text":"LinSysStopCriterion\n\nAbstract supertype for specifying stopping criteria for randomized linear solver.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_stops/#Stopping-Criteria","page":"Linear Solver Stop Criteria","title":"Stopping Criteria","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"LSStopMaxIterations","category":"page"},{"location":"api/linear_solver_stops/#RLinearAlgebra.LSStopMaxIterations","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.LSStopMaxIterations","text":"LSStopMaxIterations <: LinSysStopCriterion\n\nA structure that specifies a maximum iteration stopping criterion. That is, once a method     achieves a certain number of iterations, it stops.\n\nFields\n\nmax_iter::Int64, the maximum number of iterations.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_stops/#Check-Stopping-Criterion-Function","page":"Linear Solver Stop Criteria","title":"Check Stopping Criterion Function","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"RLinearAlgebra.check_stop_criterion","category":"page"},{"location":"api/linear_samplers/#Linear-Samplers","page":"Linear Samplers","title":"Linear Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"Pages = [\"linear_samplers.md\"]","category":"page"},{"location":"api/linear_samplers/#Abstract-Types","page":"Linear Samplers","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysSampler\n\nLinSysVecRowSampler\n\nLinSysVecColSampler\n\nLinSysBlkRowSampler\n\nLinSysBlkColSampler","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysSampler","text":"LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting components     of a linear system.\n\nAliases\n\nLinSysSketch\nLinSysSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowSampler","text":"LinSysVecRowSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a row space     element from a linear system.\n\nAliases\n\nLinSysVecRowSketch\nLinSysVecRowSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecColSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecColSampler","text":"LinSysVecColSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a column space     element from a linear system.\n\nAliases\n\nLinSysVecColSketch\nLinSysVecColSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkRowSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkRowSampler","text":"LinSysBlkRowSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a collection of     row space elements from a linear system.\n\nAliases\n\nLinSysBlkRowSketch\nLinSysBlkRowSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkColSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkColSampler","text":"LinSysBlkColSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a collection of     column space elements from a linear system.\n\nAliases\n\nLinSysBlkColSketch\nLinSysBlkColSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Vector-Row-Samplers","page":"Linear Samplers","title":"Vector Row Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysVecRowDetermCyclic\n\nLinSysVecRowHopRandCyclic\n\nLinSysVecRowOneRandCyclic\n\nLinSysVecRowPropToNormSampler\n\nLinSysVecRowRandCyclic\n\nLinSysVecRowUnidSampler","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowDetermCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowDetermCyclic","text":"LinSysVecRowDetermCyclic <: LinSysVecRowSelect\n\nAn immutable structure without any fields. Specifies deterministic cycling through the equations of a linear system.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowHopRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowHopRandCyclic","text":"LinSysVecRowHopRandCyclic <: LinSysVecRowSelect\n\nA mutable structure that specifies a cycling through the rows of a linear system, where the cycling order is determined randomly once the current cycling order has been used hop number of times. The solver randomly chooses the cycling order whenever necessary.\n\nFields\n\norder::Union{Vector{Int64},Nothing}\nhop::Int64\n\nConstructors\n\nLinSysVecRowHopRandCyclic() defaults to setting the order to nothing and the hop   to 5 (i.e., each ordering is used five times before sampling a new ordering).\nLinSysVecRowHopRandCyclic(hop::Int64) defaults to setting the order to nothing and   the hop to whatever is specified by the argument.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowOneRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowOneRandCyclic","text":"LinSysVecRowOneRandCyclic <: LinSysVecRowSelect\n\nA mutable structure with a field to store a cycling order. Randomly specifies a cycling order over the equations of a linear system. Once this ordering is specified, the ordering is kept fixed.\n\nFields\n\norder::Union{Vector{Int64},Nothing}\n\nCalling LinSysVecRowOneRandCyclic() defaults to setting order to nothing. The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowPropToNormSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowPropToNormSampler","text":"LinSysVecRowPropToNormSampler{T} <: LinSysVecRowSampler where T <: Categorical\n\nA parametric mutable structure that specifies sampling from the rows of the equation where the probability of selecting a given equation is proportional to the sum of squares of the coefficients of the given equation. The solver will appropriately initialize the distribution.\n\nSee Strohmer, T., Vershynin, R. A Randomized Kaczmarz Algorithm with Exponential Convergence. J Fourier Anal Appl 15, 262 (2009). https://doi.org/10.1007/s00041-008-9030-4\n\nAliases\n\nLinSysVecRowSVSampler\n\nFields\n\ndist::T, a categorical probability distribution.\n\nCalling LinSysVecRowPropToNormSampler() or LinSysVecRowSVSampler() defaults dist to Categorical(1.0).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowRandCyclic","text":"LinSysVecRowRandCyclic <: LinSysVecRowSelect\n\nA mutable structure with a field to store a cycling order. Randomly specifies a cycling order the equations of a linear system. Once this ordering is exhausted by the solver, a new random ordering is specified. This process is repeated\n\nFields\n\norder::Union{Vector{Int64},Nothing}\n\nCalling LinSysVecRowOneRandCyclic() defaults to setting order to nothing. The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowUnidSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowUnidSampler","text":"LinSysVecRowUnidSampler <: LinSysVecRowSampler\n\nAn immutable structure without fields that specifies randomly cycling from the rows of a linear system with uniform probability and with replacement.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Vector-Column-Samplers","page":"Linear Samplers","title":"Vector Column Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysVecColDetermCyclic","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecColDetermCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecColDetermCyclic","text":"LinSysVecColDetermCyclic <: LinSysVecColSelect\n\nAn immutable structure without any fields. Specifies deterministic cycling through the columns of a linear system.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Sample-Function","page":"Linear Samplers","title":"Sample Function","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"RLinearAlgebra.sample(::Nothing,::AbstractArray,::AbstractVector,\n    ::AbstractVector,::Int64)","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.sample-Tuple{Nothing, AbstractArray, AbstractVector{T} where T, AbstractVector{T} where T, Int64}","page":"Linear Samplers","title":"RLinearAlgebra.sample","text":"sample(type::T where T<:LinSysSampler,\n    A::AbstractArray,\n    b::AbstractVector,\n    x::AbstractVector,\n    iter::Int64)\n\nA common interface for specifying different strategies for sampling, selecting or sketching     a linear system specified by A and b. The type argument is used to select the an     appropriately defined strategy. The argument x is the current iterate value for the     solution. The arguent iter is the iteration counter.\n\nThe value(s) returned by sample depend on the subtype of LinSysSampler being used.     Specifically,\n\nFor T<:LinSysVecRowSampler, a vector in the row space of A and constant are returned\nFor T<:LinSysVecColSampler, a vector of length(x), the matrix A,   and a scalar-valued residual are returned.\n\n\n\n\n\n","category":"method"},{"location":"api/linear_solver_logs/#Linear-Solver-Logs","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"Pages = [\"linear_solver_logs.md\"]","category":"page"},{"location":"api/linear_solver_logs/#Abstract-Types","page":"Linear Solver Logs","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"LinSysSolverLog","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LinSysSolverLog","page":"Linear Solver Logs","title":"RLinearAlgebra.LinSysSolverLog","text":"LinSysSolverLog\n\nAbstract supertype for logging information about a randomized linear system solver.\n\nNote, all descendants that are mutable structs must have fields\n\niterations::Int64, which tracks the number of iterations of the solver\nconverged::Bool, which tracks whether the solver has converged to the solution (by some   notion of convergence that is specified by the user).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#Loggers","page":"Linear Solver Logs","title":"Loggers","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"LSLogOracle\n\nLSLogFull","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LSLogOracle","page":"Linear Solver Logs","title":"RLinearAlgebra.LSLogOracle","text":"LSLogOracle <: LinSysSolverLog\n\nA mutable structure that stores information about a randomized linear solver's behavior.     The log assumes that the true solution of the system is known and will be supplied.     The goal of this log is usually for research, development, or testing.\n\nFields\n\nsolution::AbstractVector, a solution to the given linear system.\ncollection_rate::Int64, the frequency with which to record information to append to the   remaining fields, starting with the initialization (i.e., iteration 0).\nerror_hist::Vector{Float64}, retains a vector of numbers corresponding to the error   between the iterates of the solver and the solution\nerror_norm::Function, a function that accepts a single vector argument and returns a   scalar. Used to compute the error size.\nresid_hist::Vector{Float64}, retains a vector of numbers corresponding to the residual   (uses the whole system to compute the residual)\nresid_norm::Function, a function that accepts a single vector argument and returns a   scalar. Used to compute the residual size.\niterations::Int64, the number of iterations of the solver.\nconverged::Bool, a flag to indicate whether the system has converged by some measure\n\nConstructors\n\nCalling LSLogOracle(x_star::Vector{Float64}) sets solution = x_star,   collection_rate = 1, error_hist = Float64[], error_norm = norm (Euclidean norm),   resid_hist = Float64[], resid_norm = norm (Euclidean norm), iterations=-1,   and converged = false.\nCalling LSLogOracle(x_star::Vector{Float64}, cr::Int64) sets the structure with the   same parameters as for LSLogOracle(x_star) except collection_rate = cr.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LSLogFull","page":"Linear Solver Logs","title":"RLinearAlgebra.LSLogFull","text":"LSLogFull <: LinSysSolverLog\n\nA mutable structure that stores information about a randomized linear solver's behavior.     The log assumes that the full linear system is available for processing. The goal of     this log is usually for research, development or testing as it is unlikely that the     entire residual vector is readily available.\n\nFields\n\ncollection_rate::Int64, the frequency with which to record information to append to the   remaining fields, starting with the initialization (i.e., iteration 0).\nresid_hist::Vector{Float64}, retains a vector of numbers corresponding to the residual   (uses the whole system to compute the residual)\nresid_norm::Function, a function that accepts a single vector argument and returns a   scalar. Used to compute the residual size.\niterations::Int64, the number of iterations of the solver.\nconverged::Bool, a flag to indicate whether the system has converged by some measure\n\nConstructors\n\nCalling LSLogFull() sets collection_rate = 1, resid_hist = Float64[],   resid_norm = norm (Euclidean norm), iterations = -1, and converged = false.\nCalling LSLogFull(cr::Int64) is the same as calling LSLogFull() except   collection_rate = cr.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#Log-Function","page":"Linear Solver Logs","title":"Log Function","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"RLinearAlgebra.log_update!(::Nothing,::LinSysSampler,::AbstractVector,::Tuple,\n  ::Int64,::Any,::Any)","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.log_update!-Tuple{Nothing, LinSysSampler, AbstractVector{T} where T, Tuple, Int64, Any, Any}","page":"Linear Solver Logs","title":"RLinearAlgebra.log_update!","text":"log_update!(\n    log::LinSysSolverLog,\n    sampler::LinSysSampler,\n    x::AbstractVector,\n    samp:s:Tuple,\n    iter::Int64,\n    A,\n    b)\n\nA common interface for specifying different strategies for updating the log with supertype     LinSysSolverLog. A sampler of supertype LinSysSampler can be used to provide     specific multiple implementations for the same log type. x is the iterate value.     samp is the output generated by the sample function (see linears_samplers.jl).     iter is the current iteration counter. A and b specify the linear system.\n\n\n\n\n\n","category":"method"},{"location":"#RLinearAlgebra","page":"Home","title":"RLinearAlgebra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RLinearAlgebra is a Julia library for the development and application of randomized algorithms to the solution of linear systems of equations. Because of the large diversity of randomized techniques, rather than offering isolated routine implementations of algorithms, this library implements a series of extendable data structures and methods which allow code reuse.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, we implement data structures which allow the implementation of the following solver categories:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Row Projection Methods (RPM) including randomized Kazmarcz, Gauss-sketch, and sampled Motzkin.\nColumn Projection Methods (CPM) including randomized Coordinate Descent and randomized Gauss Seidel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Users can use the available algorithms or create new ones by adding new methods. For example, the RPM methods are composed by a sampling and a projection methods. Users can easily create new algorithms by implementing a new row sampling technique and leverage the existing projection methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To facilitate benchmarking, we provide an abstract class for solver solution logging and stopping criteria.","category":"page"},{"location":"#Documentation-structure","page":"Home","title":"Documentation structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation serves both as a manual to the library and as an introduction to randomized linear algebra solvers. We divide it in three parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorial: here we offer examples of how to solve linear systems with RLinearAlgebra and how to extend the library.\nManual: here we offer an introduction to solving linear systems with randomized linear algebra techniques. We introduce theoretical foundations and we provide code examples with RLinearAlgebra.\nAPI: a detailed description of all the classes and methods of the library.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This material is based upon work supported by the U.S. Department of Energy, Office of Science, under contract number DE-AC02-06CH11357.","category":"page"},{"location":"api/contents/#Randomized-Linear-Solver-Reference","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"","category":"section"},{"location":"api/contents/","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"Pages=[\n  \"linear_rsolve.md\",\n  \"linear_samplers.md\",\n  \"linear_solver_routines.md\",\n  \"linear_solver_logs.md\",\n  \"linear_solver_stops.md\"]","category":"page"},{"location":"man/cls_overview/#Solving-Consistent-Linear-Systems","page":"Consistent Linear Systems","title":"Solving Consistent Linear Systems","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"A system linear of equations–-that is, a linear system–-is specified by a   coefficient matrix, A, and a constant vector b A linear system is   consistent if there exists at least one vector x^* such that Ax^* = b. The   set of vectors, x^*, satisfying Ax^* = b are called solutions. A linear   system can be solved by using a Randomized Linear Solver, which   leverages randomization to (hopefully) reduce the amount of computation or   resources needed to (approximately) find a solution to a linear system.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Randomized linear solvers come in a number of varieties and under a number of   names. In this library, a broad set of randomized linear solvers are   encapsulated using a  flexible yet uniform interface that is described below.   Once a randomized linear solver is specified, it is passed to a solver   function (i.e., rsolve or rsolve!) along with the linear system, which   then produces an approximate solution to the linear system.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"We will begin by specifying the quickest way of solving a linear system by using   the default linear solver. We will then show how to pass a user supplied   randomized linear solver to rsolve. Then, we will introduce the   general interface for specifying randomized linear solvers.","category":"page"},{"location":"man/cls_overview/#Solving-a-linear-system-using-defaults","page":"Consistent Linear Systems","title":"Solving a linear system using defaults","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Given a consistent linear system whose coefficient matrix is specified in A    and whose constant vector is provided in b, an approximate solution to the    system is returned by calling rsolve(A,b). For example, sol is an    approximate solution to the generated system in the following script.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Solve the system\nsol = rsolve(A, b);","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"The default solver is hidden in the preceding example, but we can explicitly   construct the default solver and pass it to rsolve as shown in the   following script.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify the default solver and stop it after 200 iterations\nsolver = RLSSolver(200);\n\n# Solve the system\nsol = rsolve(solver, A, b);","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"warning: Warning\nOwing  to randomness, the two scripts will produce two different solutions. This is expected as randomized linear solvers do not have determinism. You can attempt to enforce this by specifying a seed if you wish to check that the solutions produced are identical.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"In the above example, the randomized linear solver, solver, is given by the   constructor RLSSolver with an argument 200, which specifies the   total number of iterations allowed before the algorithm must stop. While we   have explicitly constructed the solver and passed it to rsolve, we   still have hidden many of the components of the randomized solver. In the   next section, we discuss these components.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"note: Note\nFor an in-place solver or to provide an initial iterate, see the documentation for rsolve!.","category":"page"},{"location":"man/cls_overview/#Components-of-a-randomized-linear-system-solver","page":"Consistent Linear Systems","title":"Components of a randomized linear system solver","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"A Randomized Linear Solver specifies the algorithm that is used to find   an approximate solution to a linear system. In this library, a randomized   linear solver is encapsulated by four general and flexible components.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"A sampler (i.e., sketch, selection) is a way of extracting row or column space information from a given linear system.\nA routine for generating a solution or updating an iterate given the information generated by the sampler.\nA logger for recording essential information about the behavior of the randomized linear solver.\nA stopping condition for determining when to terminate the linear solver (e.g., stopping at one iteration for a sketch-then-solve method).","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"These four components are the fields of an RLSSolver struct.   Specifically, these fields are","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"sampler which must be a subtype of LinSysSampler. Subtypes of LinSysSampler specify the type of sampling/sketching/selection method being deployed. See Linear Samplers for a list of available samplers.\nroutine which must be a subtype of LinSysSolveRoutine. Subtypes of LinSysSolveRoutinespecify the method for solving the system that results from applying the sampling method to the original linear system. See Linear Subsolvers for a list of available routines.\nlog which must be a subtype of LinSysSolverLog. Subtypes of LinSysSolverLog provides a struct that specifies what information is stored during execution of the algorithm. See Linear Solver Logs for a list of available logs.\nstop which must be a subtype of LinSysStopCriterion. Subtypes of LinSysStopCriterion determine when the algorithm should stop, and often makes use of log. See Linear Solver Stop Criteria for a list of available stopping criteria.","category":"page"},{"location":"man/cls_overview/#Example:-A-randomized-Kaczmarz-method","page":"Consistent Linear Systems","title":"Example: A randomized Kaczmarz method","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Suppose we have a consistent linear system with coefficient matrix A and   constant vector b.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"note: Note\nThe system can be overdetermined, square or underdetermined. The method will work regardless.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"To solve this system, we will use a randomized linear solver which","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Randomly cycles through the equations of the linear system. That is, it will  randomly permute the equations of the system, cycle through this  permutation, generate another random permutation of the equations of the system, and repeat this process until a stopping condition is reached.\nGenerates a sequence of iterates by projecting onto the hyperplane specified  by the equation generated by the random cycling.\nRecords the (Euclidean) residual norms using the entire system at each  iteration. For a random algorithm, it makes very little sense to compute the  residual norm at each iteration or even at any iteration as this requires  accessing the entire original system, which is likely inefficient for  realistic problems.\nThe solver stops once the system's equations have been visited ten times  each.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Each of these four components is addressed by the choice of sampler,   routine, log, and stop condition. In sum, these four choices will   be used to specify a solver.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"The sampler that implements the random permutation cycling is implemented  as LinSysVecRowRandCyclic.\nThe routine that implements the projection onto the hyperplane is  implemented as LinSysVecRowProjStd.\nThe log that implements the residual tracking is implemented as    LSLogFull.\nThe stop condition that implements the iteration requirement is  implemented as LSStopMaxIterations. We will pass the iteration at  which we want the algorithm to stop as an argument.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"This example solver can be implemented and used as follows.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify solver\nsolver = RLSSolver(\n    LinSysVecRowRandCyclic(),   # Random Cyclic Sampling\n    LinSysVecRowProjStd(),      # Hyperplane projection\n    LSLogFull(),                # Full Logger: maintains residual history\n    LSStopMaxIterations(200),   # Maximum iterations stopping criterion\n    nothing                     # System solution (not solved yet)\n);\n\n# Solve the system\nsol = rsolve(solver, A, b)","category":"page"}]
}
