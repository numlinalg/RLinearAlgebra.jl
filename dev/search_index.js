var documenterSearchIndex = {"docs":
[{"location":"api/linear_rsolve/#Randomized-Linear-Solver","page":"Randomized Linear Solvers","title":"Randomized Linear Solver","text":"","category":"section"},{"location":"api/linear_rsolve/","page":"Randomized Linear Solvers","title":"Randomized Linear Solvers","text":"Pages=[\"linear_rsolve.md\"]","category":"page"},{"location":"api/linear_rsolve/#Abstract-Types","page":"Randomized Linear Solvers","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_rsolve/","page":"Randomized Linear Solvers","title":"Randomized Linear Solvers","text":"RLSSolver","category":"page"},{"location":"api/linear_rsolve/#RLinearAlgebra.RLSSolver","page":"Randomized Linear Solvers","title":"RLinearAlgebra.RLSSolver","text":"RLSSolver{S<:LinSysSampler, R<:LinSysSolveRoutine,\n    L<:LinSysSolverLog, C<:LinSysStopCriterion}\n\nAn encapsulation for a (R)andomized (L)inear (S)ysterm Solver as a mutable structure.\n\nFields\n\nsampler::S, a procedure for sampling, sketching or selecting with respect to a linear   system.\nroutine::R, a routine for randomly generating the subproblem generated by the sampling,   sketching or selecting operation\nlog::L, a logger for the progress and behavior of the randomized linear system solver.\nstop::C, a stopping criterion for the randomized linear system solver.\nx::Union{Vector{Float64},Nothing}, the result produced by the randomized linear system   solver.\n\nConstructions\n\nRLSSolver(iter::Int64) specifies a solver with: random cyclic row sampling;  partially   orthogonalized row projections (memory of five) subproblem solver; a full residual   logger; and a maximum iteration stopping criterion specified by iter.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_rsolve/#Solver-Functions","page":"Randomized Linear Solvers","title":"Solver Functions","text":"","category":"section"},{"location":"api/linear_rsolve/","page":"Randomized Linear Solvers","title":"Randomized Linear Solvers","text":"rsolve\n\nrsolve!","category":"page"},{"location":"api/linear_rsolve/#RLinearAlgebra.rsolve","page":"Randomized Linear Solvers","title":"RLinearAlgebra.rsolve","text":"rsolve([solver::RLSSolver,] A, b)\n\nDeploys an iterative randomized solver for the linear system whose coefficient matrix is     encapsulated in A and whose constant vector is encapsulated in b. If the solver     is not specified, then the default RLSSolver is constructed and used with a maximum     number of iterations of 10 * length(b). See RLSSolver for more details on the     default solver.\n\nThe function returns the solution.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_rsolve/#RLinearAlgebra.rsolve!","page":"Randomized Linear Solvers","title":"RLinearAlgebra.rsolve!","text":"rsolve!([solver::RLSSolver,] A, b, x::AbstractVector)\n\nIdentical to rsolve except an initial iterate is supplied by the argument x. The     function overwrites the solution into the vector x.\n\n\n\n\n\n","category":"function"},{"location":"man/tracking_overview/#Tracking-an-Iterative-Sketching-Solver","page":"Tracking","title":"Tracking an Iterative Sketching Solver","text":"","category":"section"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"***Here we describe a tracking procedure for the row sketching method. The same descriptions and instructions also apply for the column sketching methods, but use the residual of the normal equations rather than the residual of the linear system***","category":"page"},{"location":"man/tracking_overview/#The-need-for-tracking","page":"Tracking","title":"The need for tracking","text":"","category":"section"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"When using an iterative row sketching method like Randomized Block Kaczmarz to find a x^* such that Ax^*=b for Ain mathbbR^mtimes n, bin mathbbR^n, knowing the quality of the solution is integral for being able to make appropriate stopping decisions. This solution quality can be determined by progress tracking procedures, the most common one being computing the norm squared of the residual of the linear system, Ax_k-b_2^2. Without careful thought progress tracking can undermine the benefits of the iterative sketching procedure. For instance, the update to the sketch is computed using only a sketch of the matrix, SA in mathcalR^p times n, p ll m, and constant vector Sb in mathcalR^p; however, the residual computation requires the accessing the full matrix A to compute. This completely undermines the memory benefits of working with the smaller sketch. Additionally, if p ll sqrtm, which is often the case in practice we can see in the table below that the computational complexity of the update is less than computing the residual.","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"Action Cost Accesses to Full Matrix\nUpdate mathcalO(np^2) 0\nResidual mathcalO(nm) 1\nSketched MA mathcalO(np) 0","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"These cost could be avoided by computing the sketched residual, i.e. S A x - Sb_2^2, but at the cost exact knowledge of  progress. To reduce this randomness Pritchard and Patel propose using  a moving average of the sketched residuals in \"Solving, Tracking  and Stopping Streaming Linear Inverse Problems.\" Specifically they define the progress estimator  $     \\hat \\rhok^\\lambda = \\sum{i-\\lambda +1}^k \\frac{\\|Si A x - Sib\\|_2^2}{\\lambda}, $   where lambda is the width of the moving average window. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"This tracking technique can be used in RLinearAlgebra.jl with the log option LSLogMA() when defining the solver, with a default moving average width of 30.","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify solver\nsolver = RLSSolver(\n    LinSysVecRowRandCyclic(),   # Random Cyclic Sampling\n    LinSysVecRowProjStd(),      # Hyperplane projection\n    LSLogMA(),              # Full Logger: maintains moving average residual history\n    LSStopMaxIterations(200),   # Maximum iterations stopping criterion\n    nothing                     # System solution (not solved yet)\n);\n\n# Solve the system\nsol = rsolve(solver, A, b)","category":"page"},{"location":"man/tracking_overview/#Understanding-how-to-use-the-estimator","page":"Tracking","title":"Understanding how to use the estimator","text":"","category":"section"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"The user is able to choose their own width of the moving average by inputting  lambda2=USER_WIDTH as an option within LSLogMA(). Increasing the width will decrease the variability of the progress estimate and therefore is a suggested action when the matrix is poorly conditioned or has highly variable magnitude of row  norms. However, in most cases the default option of 30 should be  sufficient for reasonable tracking. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"In most cases, it is desirable to in fact use two widths for  the moving average estimator because often at early iterations much of the observed variability in the residuals arises from the  fast convergence of the algorithm. As this variability is primarily because of convergence properties rather than randomness, it is undesirable to smooth this out. Thus, it makes  sense in this phase to use a smaller moving average width, lambda_1, which should typically be set to 1 (the user can change using the option lambda1=SMALLER_WIDTH in LSLogMA()). Once the  algorithm leaves this fast convergence phase it, then the wider moving average window should be used. This switch is determined to be the point where there is no longer monotonic decreases in the norm of the sketched residual. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"If the user wants to compare the performance of the moving average of the sketched residuals to  that of the true residuals then it is possible to input the option true_res=true into LSLogMA(). This will  perform the same moving average tracking procedure, but use the true residual rather than the sketched one.","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"Finally, if the user wants to get uncertainty sets for the sketched residual tracking they can use the function get_uncertainty(), whose use is demonstrated below.  For the uncertainty sets, the user can specify alpha, which indicates the probability that the moving average of the  true residuals falls within outputted interval. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"As an example the user wanted to track a standard row solver  with a moving average of the sketched residuals of width 100 and get a 99% uncertainty sets they could run the following code.  ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"\nusing RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify solver\nsolver = RLSSolver(\n    LinSysVecRowRandCyclic(),   # Random Cyclic Sampling\n    LinSysVecRowProjStd(),      # Hyperplane projection\n    LSLogMA(lambda_2 = 100),    # Full Logger: maintains moving average residual history\n    LSStopMaxIterations(200),   # Maximum iterations stopping criterion\n    nothing                     # System solution (not solved yet)\n);\n\n# Solve the system\nsol = rsolve(solver, A, b)\nbounds = get_uncertainty(sol.log, alpha = .99)","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"Note: If the user is using a subset of identity type sampling method these uncertainty sets will perform conservatively     because of a poor variance estimate. The user can reduce this conservativeness using the option eta=w in      the LSLogMA() settings for the solver, where w is a positive real number that divides the estimated variance of the set.","category":"page"},{"location":"man/tracking_overview/#Stopping","page":"Tracking","title":"Stopping","text":"","category":"section"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"In addition to being able to form the uncertainty sets, Pritchard and Patel also proposed a criterion for stopping when using the sketched moving average estimator. RLinearAlgebra.jl allows for the specification  these methods this can be done using LSStopMA(). To understand the stopping criterion, it is valuable to define some notation. If we allow rho_k^lambda be the moving average of the true residuals, and  hat rho_k^lambda be the moving average of the sketched residuals then two types of errors can occur.  ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"The first can be viewed as stopping too late, and it occurs when the tracking parameter value,  rho_k^lambda leq delta_I upsilon, while hat rho_k^lambda  upsilon, where delta_I  is a user defined parameter that indicates a \"meaningful gap\" between hat rho_k^lambda  and rho_k^lambda. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"The second error type can be viewed as stopping too early, and it occurs when the tracking parameter value,  rho_k^lambda geq delta_II upsilon, while hat rho_k^lambda  upsilon. Where delta_II is a user defined parameter that indicates a \"meaningful gap\" between hat rho_k^lambda and rho_k^lambda. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"Using LSStopMA() ensures that neither of these errors occurs more than the user specified rates xi_I and xi_II. Where xi_I is the upper bound on the probability  the solver is stopped too late and xi_II is an upper bound on the probability that the solver is stopped too early.","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"The options for these stopping criterion parameters are represented by the options delta_I = delta1, delta_II =  delta2 xi_I = chi1, xi_II= chi2, and upsilon= upsilon. By default, upsilon=1e-10, delta1=.9, delta2=1.1, chi_I = .01, chi_{II} = .01. To use the stopping criterion, the user must input a max number of iterations, and specify changes to the default settings as options. So for instance if one wanted to use the stopping criterion with a  maximum iteration of 1000 and upsilon = 1e-3, the following code could be used. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"\nusing RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify solver\nsolver = RLSSolver(\n    LinSysVecRowRandCyclic(),       # Random Cyclic Sampling\n    LinSysVecRowProjStd(),          # Hyperplane projection\n    LSLogMA(lambda_2 = 100),        # Full Logger: maintains moving average residual history\n    LSStopMA(1000, upsilon=1e-3),   # Maximum iterations stopping criterion\n    nothing                         # System solution (not solved yet)\n);\n\n# Solve the system\nsol = rsolve(solver, A, b)\nbounds = get_uncertainty(sol.log, alpha = .99)","category":"page"},{"location":"api/linear_solver_logs/#Linear-Solver-Logs","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"Pages = [\"linear_solver_logs.md\"]","category":"page"},{"location":"api/linear_solver_logs/#Abstract-Types","page":"Linear Solver Logs","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"LinSysSolverLog","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LinSysSolverLog","page":"Linear Solver Logs","title":"RLinearAlgebra.LinSysSolverLog","text":"LinSysSolverLog\n\nAbstract supertype for logging information about a randomized linear system solver.\n\nNote, all descendants that are mutable structs must have fields\n\niterations::Int64, which tracks the number of iterations of the solver\nconverged::Bool, which tracks whether the solver has converged to the solution (by some   notion of convergence that is specified by the user).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#Loggers","page":"Linear Solver Logs","title":"Loggers","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"LSLogOracle\n\nLSLogFull\n\nLSLogMA","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LSLogOracle","page":"Linear Solver Logs","title":"RLinearAlgebra.LSLogOracle","text":"LSLogOracle <: LinSysSolverLog\n\nA mutable structure that stores information about a randomized linear solver's behavior.     The log assumes that the true solution of the system is known and will be supplied.     The goal of this log is usually for research, development, or testing.\n\nFields\n\nsolution::AbstractVector, a solution to the given linear system.\ncollection_rate::Int64, the frequency with which to record information to append to the   remaining fields, starting with the initialization (i.e., iteration 0).\nerror_hist::Vector{Float64}, retains a vector of numbers corresponding to the error   between the iterates of the solver and the solution\nerror_norm::Function, a function that accepts a single vector argument and returns a   scalar. Used to compute the error size.\nresid_hist::Vector{Float64}, retains a vector of numbers corresponding to the residual   (uses the whole system to compute the residual)\nresid_norm::Function, a function that accepts a single vector argument and returns a   scalar. Used to compute the residual size.\niterations::Int64, the number of iterations of the solver.\nconverged::Bool, a flag to indicate whether the system has converged by some measure\n\nConstructors\n\nCalling LSLogOracle(x_star::Vector{Float64}) sets solution = x_star,   collection_rate = 1, error_hist = Float64[], error_norm = norm (Euclidean norm),   resid_hist = Float64[], resid_norm = norm (Euclidean norm), iterations=-1,   and converged = false.\nCalling LSLogOracle(x_star::Vector{Float64}, cr::Int64) sets the structure with the   same parameters as for LSLogOracle(x_star) except collection_rate = cr.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LSLogFull","page":"Linear Solver Logs","title":"RLinearAlgebra.LSLogFull","text":"LSLogFull <: LinSysSolverLog\n\nA mutable structure that stores information about a randomized linear solver's behavior.     The log assumes that the full linear system is available for processing. The goal of     this log is usually for research, development or testing as it is unlikely that the     entire residual vector is readily available.\n\nFields\n\ncollection_rate::Int64, the frequency with which to record information to append to the   remaining fields, starting with the initialization (i.e., iteration 0).\nresid_hist::Vector{Float64}, retains a vector of numbers corresponding to the residual   (uses the whole system to compute the residual)\nresid_norm::Function, a function that accepts a single vector argument and returns a   scalar. Used to compute the residual size.\niterations::Int64, the number of iterations of the solver.\nconverged::Bool, a flag to indicate whether the system has converged by some measure\n\nConstructors\n\nCalling LSLogFull() sets collection_rate = 1, resid_hist = Float64[],   resid_norm = norm (Euclidean norm), iterations = -1, and converged = false.\nCalling LSLogFull(cr::Int64) is the same as calling LSLogFull() except   collection_rate = cr.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LSLogMA","page":"Linear Solver Logs","title":"RLinearAlgebra.LSLogMA","text":"LSLogMA <: LinSysSolverLog\n\nA mutable structure that stores information for tracking a randomized linear solver's      progress.     The log assumes that the entire linear system is not available for processing. \n\nFields\n\ncollection_rate::Int64, the frequency with which to record information about progress estimators    to append to the remaining fields, starting with the initialization (i.e., iterate 0).\nma_info::MAInfo, MAInfo\nresid_hist::Vector{Float64}, contains an estimate of the progress of the randomized   solver. These values are stored at iterates specified by collection_rate.\niota_hist::Vector{Float64}, contains an estimate used for calculating the variability   of the progress estimators. These values are stored at iterates specified by   collection_rate.\nlambda_hist::Vector{Int64}, contains the widths of the moving average.  These values are stored at iterates specified by collection_rate.\nresid_norm::Function, the desired norm used. The default constructor sets this to the    Euclidean norm. \niteration::Int64, the current iteration of the solver.\nconverged::Bool, a flag to indicate whether the system has converged by some measure.    By default this is false.\ndist_info::SEDistInfo, SEDistInfo\n\nConstructors\n\nThe keyword constructor is defined as \n\nLSLogMA(collection_rate = 1,         lambda1 = 1,          lambda2 = 30,          resid_norm = norm #(Euclidean norm),          sigma2 = nothing,          omega = nothing,         eta = 1,          )\n\nFor more information see:\n\nPritchard, Nathaniel, and Vivak Patel. \"Solving, tracking and stopping streaming linear    inverse problems.\" Inverse Problems (2024). doi:10.1088/1361-6420/ad5583.\nPritchard, Nathaniel, and Vivak Patel. “Towards Practical Large-Scale Randomized Iterative    Least Squares Solvers through Uncertainty Quantification.” SIAM/ASA J. Uncertainty    Quantification 11 (2022): 996-1024. doi.org/10.1137/22M1515057\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#Log-Function","page":"Linear Solver Logs","title":"Log Function","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"RLinearAlgebra.log_update!(::Nothing,::LinSysSampler,::AbstractVector,::Tuple,::Int64,::Any,::Any)","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.log_update!-Tuple{Nothing, LinSysSampler, AbstractVector{T} where T, Tuple, Int64, Any, Any}","page":"Linear Solver Logs","title":"RLinearAlgebra.log_update!","text":"log_update!(\n    log::LinSysSolverLog,\n    sampler::LinSysSampler,\n    x::AbstractVector,\n    samp:s:Tuple,\n    iter::Int64,\n    A,\n    b)\n\nA common interface for specifying different strategies for updating the log with supertype     LinSysSolverLog. A sampler of supertype LinSysSampler can be used to provide     specific multiple implementations for the same log type. x is the iterate value.     samp is the output generated by the sample function (see linears_samplers.jl).     iter is the current iteration counter. A and b specify the linear system.\n\n\n\n\n\n","category":"method"},{"location":"api/linear_solver_logs/#Log-Specific-Functions","page":"Linear Solver Logs","title":"Log Specific Functions","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"RLinearAlgebra.get_uncertainty(::LSLogMA; alpha = .05)","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.get_uncertainty-Tuple{LSLogMA}","page":"Linear Solver Logs","title":"RLinearAlgebra.get_uncertainty","text":"get_uncertainty(log::LSLogMA; alpha = 0.05)\n\nA function that takes a LSLogMA type and a confidence level, alpha, and returns a (1-alpha)-credible intervals  for every rho in the log, specifically it returns a tuple with (rho, Upper bound, Lower bound).\n\n\n\n\n\n","category":"method"},{"location":"api/linear_solver_logs/#Internal-Data-Structures","page":"Linear Solver Logs","title":"Internal Data Structures","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"RLinearAlgebra.MAInfo\n\nRLinearAlgebra.SEDistInfo","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.MAInfo","page":"Linear Solver Logs","title":"RLinearAlgebra.MAInfo","text":"MAInfo\n\nA mutable structure that stores information relevant to the moving average of the progress estimator.\n\nFields\n\nlambda1::Int64, the width of the moving average during the fast convergence phase of the algorithm.  During this fast convergence phase, the majority of variation of the sketched estimator comes from  improvement in the solution and thus wide moving average windows inaccurately represent progress. \nlambda2::Int64, the width of the moving average in the slower convergence phase. In the slow convergence phase, each iterate differs from the previous one by a small amount and thus most of the observed variation arises from the randomness of the sketched progress estimator, which is best smoothed by a wide moving average width.\nlambda::Int64, the width of the moving average at the current iteration. This value is not controlled by the user. \nflag::Bool, a boolean indicating which phase we are in, a value of true indicates slow convergence phase. \nidx::Int64, the index indcating what value should be replaced in the moving average buffer.\nres_window::Vector{Float64}, the moving average buffer.\n\nFor more information see:\n\nPritchard, Nathaniel, and Vivak Patel. \"Solving, tracking and stopping streaming linear    inverse problems.\" Inverse Problems (2024). doi:10.1088/1361-6420/ad5583.\nPritchard, Nathaniel, and Vivak Patel. “Towards Practical Large-Scale Randomized Iterative    Least Squares Solvers through Uncertainty Quantification.” SIAM/ASA J. Uncertainty    Quantification 11 (2022): 996-1024. doi.org/10.1137/22M1515057\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#RLinearAlgebra.SEDistInfo","page":"Linear Solver Logs","title":"RLinearAlgebra.SEDistInfo","text":"SEDistInfo\n\nA mutable structure that stores information about a distribution (i.e., sampling method) in the sub-Exponential family.\n\nFields\n\nsampler::Union{DataType, Nothing}, the type of sampling method.\ndimension::Int64, the dimension that of the space that is being sampled.\nblock_dimension::Int64, the dimension of the sample.\nsigma2::Union{Float64, Nothing}, the variance parameter in the sub-Exponential family.    If not specified by the user, a value is selected from a table based on the sampler.    If the sampler is not in the table, then sigma2 is set to 1.\nomega::Union{Float64, Nothing}, the exponential distrbution parameter. If not specified    by the user, a value is selected from a table based on the sampler.   If the sampler is not in the table, then omega is set to 1.\neta::Float64, a parameter for adjusting the conservativeness of the distribution, higher    value means a less conservative estimate. A recommended value is 1.\nscaling::Float64, a scaling parameter for the norm-squared of the sketched residual to    ensure its expectation is the norm-squared of the residual.\n\nFor more information see:\n\nPritchard, Nathaniel, and Vivak Patel. \"Solving, tracking and stopping streaming linear    inverse problems.\" Inverse Problems (2024). doi:10.1088/1361-6420/ad5583.\nPritchard, Nathaniel, and Vivak Patel. “Towards Practical Large-Scale Randomized Iterative    Least Squares Solvers through Uncertainty Quantification.” SIAM/ASA J. Uncertainty    Quantification 11 (2022): 996-1024. doi.org/10.1137/22M1515057\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#Internal-Functions","page":"Linear Solver Logs","title":"Internal Functions","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"RLinearAlgebra.update_ma!\n\nRLinearAlgebra.get_SE_constants!","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.update_ma!","page":"Linear Solver Logs","title":"RLinearAlgebra.update_ma!","text":"update_ma!(\n    log::LSLogMA, \n    res::Union{AbstractVector, Real}, \n    lambda_base::Int64, \n    iter::Int64\n)\n\nFunction that updates the moving average tracking statistic. \n\nInputs\n\nlog::LSLogMA, the moving average log structure.\nres::Union{AbstractVector, Real}, the sketched residual for the current iteration. \nlambda_base::Int64, which lambda, between lambda1 and lambda2, is currently being used.\niter::Int64, the current iteration.\n\nOutputs\n\nUpdates the log datatype and does not explicitly return anything.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_solver_logs/#RLinearAlgebra.get_SE_constants!","page":"Linear Solver Logs","title":"RLinearAlgebra.get_SE_constants!","text":"get_SE_constants!(log::LSLogMA, sampler::Type{T<:LinSysSampler})\n\nA function that returns a default set of sub-Exponential constants for each sampling method.  This function is not exported and thus the user does not have direct access to it. \n\nInputs\n\nlog::LSLogMA, the log containing all the tracking information.\nsampler::Type{LinSysSampler}, the type of sampler being used.\n\nOutputs\n\nPerforms an inplace update of the sub-Exponential constants for the log. Additionally, updates the scaling constant to ensure expectation of  block norms is equal to true norm. If default is not a defined a warning is returned that sigma2 is set 1 and scaling is set to 1. \n\n\n\n\n\n","category":"function"},{"location":"man/cls_overview/#Solving-Consistent-Linear-Systems","page":"Consistent Linear Systems","title":"Solving Consistent Linear Systems","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"A system linear of equations–-that is, a linear system–-is specified by a   coefficient matrix, A, and a constant vector b A linear system is   consistent if there exists at least one vector x^* such that Ax^* = b. The   set of vectors, x^*, satisfying Ax^* = b are called solutions. A linear   system can be solved by using a Randomized Linear Solver, which   leverages randomization to (hopefully) reduce the amount of computation or   resources needed to (approximately) find a solution to a linear system.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Randomized linear solvers come in a number of varieties and under a number of   names. In this library, a broad set of randomized linear solvers are   encapsulated using a  flexible yet uniform interface that is described below.   Once a randomized linear solver is specified, it is passed to a solver   function (i.e., rsolve or rsolve!) along with the linear system, which   then produces an approximate solution to the linear system.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"We will begin by specifying the quickest way of solving a linear system by using   the default linear solver. We will then show how to pass a user supplied   randomized linear solver to rsolve. Then, we will introduce the   general interface for specifying randomized linear solvers.","category":"page"},{"location":"man/cls_overview/#Solving-a-linear-system-using-defaults","page":"Consistent Linear Systems","title":"Solving a linear system using defaults","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Given a consistent linear system whose coefficient matrix is specified in A    and whose constant vector is provided in b, an approximate solution to the    system is returned by calling rsolve(A,b). For example, sol is an    approximate solution to the generated system in the following script.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Solve the system\nsol = rsolve(A, b);","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"The default solver is hidden in the preceding example, but we can explicitly   construct the default solver and pass it to rsolve as shown in the   following script.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify the default solver and stop it after 200 iterations\nsolver = RLSSolver(200);\n\n# Solve the system\nsol = rsolve(solver, A, b);","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"warning: Warning\nOwing  to randomness, the two scripts will produce two different solutions. This is expected as randomized linear solvers do not have determinism. You can attempt to enforce this by specifying a seed if you wish to check that the solutions produced are identical.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"In the above example, the randomized linear solver, solver, is given by the   constructor RLSSolver with an argument 200, which specifies the   total number of iterations allowed before the algorithm must stop. While we   have explicitly constructed the solver and passed it to rsolve, we   still have hidden many of the components of the randomized solver. In the   next section, we discuss these components.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"note: Note\nFor an in-place solver or to provide an initial iterate, see the documentation for rsolve!.","category":"page"},{"location":"man/cls_overview/#Components-of-a-randomized-linear-system-solver","page":"Consistent Linear Systems","title":"Components of a randomized linear system solver","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"A Randomized Linear Solver specifies the algorithm that is used to find   an approximate solution to a linear system. In this library, a randomized   linear solver is encapsulated by four general and flexible components.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"A sampler (i.e., sketch, selection) is a way of extracting row or column space information from a given linear system.\nA routine for generating a solution or updating an iterate given the information generated by the sampler.\nA logger for recording essential information about the behavior of the randomized linear solver.\nA stopping condition for determining when to terminate the linear solver (e.g., stopping at one iteration for a sketch-then-solve method).","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"These four components are the fields of an RLSSolver struct.   Specifically, these fields are","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"sampler which must be a subtype of LinSysSampler. Subtypes of LinSysSampler specify the type of sampling/sketching/selection method being deployed. See Linear Samplers for a list of available samplers.\nroutine which must be a subtype of LinSysSolveRoutine. Subtypes of LinSysSolveRoutinespecify the method for solving the system that results from applying the sampling method to the original linear system. See Linear Subsolvers for a list of available routines.\nlog which must be a subtype of LinSysSolverLog. Subtypes of LinSysSolverLog provides a struct that specifies what information is stored during execution of the algorithm. See Linear Solver Logs for a list of available logs.\nstop which must be a subtype of LinSysStopCriterion. Subtypes of LinSysStopCriterion determine when the algorithm should stop, and often makes use of log. See Linear Solver Stop Criteria for a list of available stopping criteria.","category":"page"},{"location":"man/cls_overview/#Example:-A-randomized-Kaczmarz-method","page":"Consistent Linear Systems","title":"Example: A randomized Kaczmarz method","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Suppose we have a consistent linear system with coefficient matrix A and   constant vector b.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"note: Note\nThe system can be overdetermined, square or underdetermined. The method will work regardless.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"To solve this system, we will use a randomized linear solver which","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Randomly cycles through the equations of the linear system. That is, it will  randomly permute the equations of the system, cycle through this  permutation, generate another random permutation of the equations of the system, and repeat this process until a stopping condition is reached.\nGenerates a sequence of iterates by projecting onto the hyperplane specified  by the equation generated by the random cycling.\nRecords the (Euclidean) residual norms using the entire system at each  iteration. For a random algorithm, it makes very little sense to compute the  residual norm at each iteration or even at any iteration as this requires  accessing the entire original system, which is likely inefficient for  realistic problems.\nThe solver stops once the system's equations have been visited ten times  each.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Each of these four components is addressed by the choice of sampler,   routine, log, and stop condition. In sum, these four choices will   be used to specify a solver.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"The sampler that implements the random permutation cycling is implemented  as LinSysVecRowRandCyclic.\nThe routine that implements the projection onto the hyperplane is  implemented as LinSysVecRowProjStd.\nThe log that implements the residual tracking is implemented as    LSLogFull.\nThe stop condition that implements the iteration requirement is  implemented as LSStopMaxIterations. We will pass the iteration at  which we want the algorithm to stop as an argument.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"This example solver can be implemented and used as follows.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify solver\nsolver = RLSSolver(\n    LinSysVecRowRandCyclic(),   # Random Cyclic Sampling\n    LinSysVecRowProjStd(),      # Hyperplane projection\n    LSLogFull(),                # Full Logger: maintains residual history\n    LSStopMaxIterations(200),   # Maximum iterations stopping criterion\n    nothing                     # System solution (not solved yet)\n);\n\n# Solve the system\nsol = rsolve(solver, A, b)","category":"page"},{"location":"man/cls_overview/#Block-Methods-for-Linear-Systems","page":"Consistent Linear Systems","title":"Block Methods for Linear Systems","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Because of the way that computers operate, it is often more efficient to work using  blocks of data rather than single vectors to generate updates to solutions. ","category":"page"},{"location":"api/linear_solver_stops/#Linear-Solver-Stop-Criteria","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"Pages=[\"linear_solver_stops.md\"]","category":"page"},{"location":"api/linear_solver_stops/#Abstract-Types","page":"Linear Solver Stop Criteria","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"LinSysStopCriterion","category":"page"},{"location":"api/linear_solver_stops/#RLinearAlgebra.LinSysStopCriterion","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.LinSysStopCriterion","text":"LinSysStopCriterion\n\nAbstract supertype for specifying stopping criteria for randomized linear solver.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_stops/#Stopping-Criteria","page":"Linear Solver Stop Criteria","title":"Stopping Criteria","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"LSStopMaxIterations\nLSStopThreshold\nLSStopMA","category":"page"},{"location":"api/linear_solver_stops/#RLinearAlgebra.LSStopMaxIterations","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.LSStopMaxIterations","text":"LSStopMaxIterations <: LinSysStopCriterion\n\nA structure that specifies a maximum iteration stopping criterion. That is, once a method     achieves a certain number of iterations, it stops.\n\nFields\n\nmax_iter::Int64, the maximum number of iterations.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_stops/#RLinearAlgebra.LSStopThreshold","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.LSStopThreshold","text":"LSStopThreshold <: LinSysStopCriterion\n\nA structure that specifies a threshold for sufficient progress as a stopping critertion. That is, once a progress estimator      achieves a certain quality of solution, it stops.\n\nFields\n\nmax_iter::Int64, the maximum number of iterations.\nthreshold::Float64, the value threshold for when sufficient progress has been achieved.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_stops/#RLinearAlgebra.LSStopMA","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.LSStopMA","text":"LSStopMA <: LinSysStopCriterion\n\nA structure that specifies a stopping criterion that incoroporates the randomness of the moving average estimator. That is, once a method     achieves a certain number of iterations, it stops.\n\nFields\n\nmax_iter::Int64, the maximum number of iterations.\nthreshold::Float64, the value of the estimator that is sufficient progress. \ndelta1::Float64, the percent below the threshold does the true value of the progress estimator need to be for not stopping to be a mistake. This is equivalent to stopping too late.\ndelta2::Float64, the percent above the threshold does the true value of the progress estimator need to be for stopping to be a    mistake. This is equivalent to stopping too early.\nchi1::Float64, the probability that the stopping too late action occurs.\nchi2::Float64, the probability that the stopping too early action occurs.\n\nConstructors\n\nCalling LSStopMA(iter) will specify the users desired maximum number of iterations, threshold = 1e-10, delta1 = .9, delta2 = 1.1, chi1 = 0.01, and chi2 = 0.01.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_stops/#Stopping-Function","page":"Linear Solver Stop Criteria","title":"Stopping Function","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"RLinearAlgebra.check_stop_criterion(log::LinSysSolverLog, stop::LinSysStopCriterion) ","category":"page"},{"location":"api/linear_solver_stops/#RLinearAlgebra.check_stop_criterion-Tuple{LinSysSolverLog, LinSysStopCriterion}","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.check_stop_criterion","text":"check_stop_criterion(\n    log::LinSysSolverLog,\n    stop::LinSysStopCriterion\n    )\n\nA common interface for specifying different strategies for stopping log with supertype     LinSysSolverLog. A stop of supertype LinSysStopCriterion can be used to provide     specific multiple implementations of stopping conditions for the same log type.\n\n\n\n\n\n","category":"method"},{"location":"api/linear_solver_stops/#Internal-Functions","page":"Linear Solver Stop Criteria","title":"Internal Functions","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"RLinearAlgebra.iota_threshold(hist::LSLogMA, stop::LSStopMA)","category":"page"},{"location":"api/linear_solver_stops/#RLinearAlgebra.iota_threshold-Tuple{LSLogMA, LSStopMA}","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.iota_threshold","text":"iota_threshold(hist::LSLogMA, stop::LSStopMA)\n\nFunction that computes the stopping criterion using the sub-Exponential distribution from the LSLogMA, and the stopping criterion information in LSSopMA. This function is not exported and thus not directly callable by the user.\n\nInputs\n\nhist::LSLogMA, the log information for the moving average tracking.\nstop::LSStopMA, the stopping information for the stopping criterion.\n\nOuputs\n\nReturns the stoppping criterion value.\n\nPritchard, Nathaniel, and Vivak Patel. \"Solving, Tracking and Stopping Streaming Linear Inverse Problems.\" arXiv preprint arXiv:2201.05741 (2024).\n\n\n\n\n\n","category":"method"},{"location":"api/linear_samplers/#Linear-Samplers","page":"Linear Samplers","title":"Linear Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"Pages = [\"linear_samplers.md\"]","category":"page"},{"location":"api/linear_samplers/#Abstract-Types","page":"Linear Samplers","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysSampler\n\nLinSysVecRowSampler\n\nLinSysVecColSampler\n\nLinSysBlkRowSampler\n\nLinSysBlkColSampler","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysSampler","text":"LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting components     of a linear system.\n\nAliases\n\nLinSysSketch\nLinSysSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowSampler","text":"LinSysVecRowSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a row space     element from a linear system.\n\nAliases\n\nLinSysVecRowSketch\nLinSysVecRowSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecColSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecColSampler","text":"LinSysVecColSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a column space     element from a linear system.\n\nAliases\n\nLinSysVecColSketch\nLinSysVecColSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkRowSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkRowSampler","text":"LinSysBlkRowSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a collection of     row space elements from a linear system.\n\nAliases\n\nLinSysBlkRowSketch\nLinSysBlkRowSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkColSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkColSampler","text":"LinSysBlkColSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a collection of     column space elements from a linear system.\n\nAliases\n\nLinSysBlkColSketch\nLinSysBlkColSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Vector-Row-Samplers","page":"Linear Samplers","title":"Vector Row Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysVecRowDetermCyclic\n\nLinSysVecRowHopRandCyclic\n\nLinSysVecRowOneRandCyclic\n\nLinSysVecRowPropToNormSampler\n\nLinSysVecRowRandCyclic\n\nLinSysVecRowUnidSampler\n\nLinSysVecRowUnifSampler\n\nLinSysVecRowSparseUnifSampler\n\nLinSysVecRowGaussSampler\n\nLinSysVecRowSparseGaussSampler\n\nLinSysVecRowMaxResidual\n\nLinSysVecRowResidCyclic\n\nLinSysVecRowMaxDistance\n\nLinSysVecRowDistCyclic","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowDetermCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowDetermCyclic","text":"LinSysVecRowDetermCyclic <: LinSysVecRowSelect\n\nAn immutable structure without any fields. Specifies deterministic cycling through the equations of a linear system.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowHopRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowHopRandCyclic","text":"LinSysVecRowHopRandCyclic <: LinSysVecRowSelect\n\nA mutable structure that specifies a cycling through the rows of a linear system, where the cycling order is determined randomly once the current cycling order has been used hop number of times. The solver randomly chooses the cycling order whenever necessary.\n\nFields\n\norder::Union{Vector{Int64},Nothing}\nhop::Int64\n\nConstructors\n\nLinSysVecRowHopRandCyclic() defaults to setting the order to nothing and the hop   to 5 (i.e., each ordering is used five times before sampling a new ordering).\nLinSysVecRowHopRandCyclic(hop::Int64) defaults to setting the order to nothing and   the hop to whatever is specified by the argument.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowOneRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowOneRandCyclic","text":"LinSysVecRowOneRandCyclic <: LinSysVecRowSelect\n\nA mutable structure with a field to store a cycling order. Randomly specifies a cycling order over the equations of a linear system. Once this ordering is specified, the ordering is kept fixed.\n\nFields\n\norder::Union{Vector{Int64},Nothing}\n\nCalling LinSysVecRowOneRandCyclic() defaults to setting order to nothing. The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowPropToNormSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowPropToNormSampler","text":"LinSysVecRowPropToNormSampler{T} <: LinSysVecRowSampler where T <: Categorical\n\nA parametric mutable structure that specifies sampling from the rows of the equation where the probability of selecting a given equation is proportional to the sum of squares of the coefficients of the given equation. The solver will appropriately initialize the distribution.\n\nSee Strohmer, T., Vershynin, R. A Randomized Kaczmarz Algorithm with Exponential Convergence. J Fourier Anal Appl 15, 262 (2009). https://doi.org/10.1007/s00041-008-9030-4\n\nAliases\n\nLinSysVecRowSVSampler\n\nFields\n\ndist::T, a categorical probability distribution.\n\nCalling LinSysVecRowPropToNormSampler() or LinSysVecRowSVSampler() defaults dist to Categorical(1.0).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowRandCyclic","text":"LinSysVecRowRandCyclic <: LinSysVecRowSelect\n\nA mutable structure with a field to store a cycling order. Randomly specifies a cycling order the equations of a linear system. Once this ordering is exhausted by the solver, a new random ordering is specified. This process is repeated\n\nFields\n\norder::Union{Vector{Int64},Nothing}\n\nCalling LinSysVecRowOneRandCyclic() defaults to setting order to nothing. The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowUnidSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowUnidSampler","text":"LinSysVecRowUnidSampler <: LinSysVecRowSampler\n\nAn immutable structure without fields that specifies randomly cycling from the rows of a linear system with uniform probability and with replacement.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowUnifSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowUnifSampler","text":"LinSysVecRowUnifSampler <: LinSysVecRowSampler\n\nAn immutable structure without fields that specifies taking a linear combination of all equations with the coefficients being independent uniform random variables.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowSparseUnifSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowSparseUnifSampler","text":"LinSysVecRowSparseUnifSampler <: LinSysVecRowSelect\n\nA mutable structure that specifies sampling a proporition of the rows of a linear system, scaling each using independent uniform  random variables, and then taking their sum. The proportion of rows sampled without replacement is given by (at most) sparsity which must be  between 0 and 1 (not inclusive).\n\nFields\n\nsparsity::Float64\n\nConstructors\n\nLinSysVecRowSparseUnifSampler() defaults the sparsity level to 0.2.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowGaussSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowGaussSampler","text":"LinSysVecRowGaussSampler <: LinSysVecRowSampler\n\nAn immutable structure without fields that specifies taking a linear combination of all equations with the coefficients being independent Gaussian random variables.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowSparseGaussSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowSparseGaussSampler","text":"LinSysVecRowSparseGaussSampler <: LinSysVecRowSelect\n\nA mutable structure that specifies sampling a proporition of the rows of a linear system, scaling each using independent Gaussian  random variables, and then taking their sum. The proportion of rows sampled without replacement is given by (at most) sparsity which must be  between 0 and 1 (not inclusive).\n\nFields\n\nsparsity::Float64\n\nConstructors\n\nLinSysVecRowSparseUnifSampler() defaults the sparsity level to 0.2.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowMaxResidual","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowMaxResidual","text":"LinSysVecRowMaxResidual <: LinSysVecRowSelect\n\nAn immutable structure without fields that specifies choosing the  linear equation in a system with the largest absolute residual at the current  iterate.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowResidCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowResidCyclic","text":"LinSysVecRowResidCyclic <: LinSysVecRowSelect\n\nA mutable structure with a field to store a cycling order. When the ordering  is not specified, the ordering is filled by looking at the residuals at the current iterate and ordering by decreasing residual. Once the order is exhausted a new order is selected. \n\nFields\n\norder::Vector{Int64}\n\nCalling LinSysVecRowResidCyclic() defaults to setting order to an empty array.  The sample function will handle the re-initialization of the fields once the  system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowMaxDistance","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowMaxDistance","text":"LinSysVecRowMaxDistance <: LinSysVecRowSelect\n\nAn immutable structure without fields that specifies choosing the  linear equation in a system with the largest distance between the current iterate and the hyperplane specified by the equation.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowDistCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowDistCyclic","text":"LinSysVecRowDistCyclic <: LinSysVecRowSelect\n\nA mutable structure with a field to store a cycling order. When the ordering  is not specified, the ordering is filled in two steps. First, the distances  between the current iterate and all hyperplanes as specified by the equations of the system. Then, the ordering is the indices of these distances in decreasing  order.\n\nFields\n\norder::Vector{Int64}\n\nCalling LinSysVecRowDistCyclic() defaults to setting order to an empty array.  The sample function will handle the re-initialization of the fields once the  system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Vector-Column-Samplers","page":"Linear Samplers","title":"Vector Column Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysVecColDetermCyclic\n\nLinSysVecColOneRandCyclic","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecColDetermCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecColDetermCyclic","text":"LinSysVecColDetermCyclic <: LinSysVecColSelect\n\nAn immutable structure without any fields. Specifies deterministic cycling through the columns of a linear system.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecColOneRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecColOneRandCyclic","text":"LinSysVecColOneRandCyclic <: LinSysVecColSelect\n\nA mutable structure with a field to store a cycling order. Randomly specifies a cycling order over the equations of a linear system. Once this ordering is specified, the ordering is kept fixed.\n\nFields\n\norder::Vector{Int64}\n\nCalling LinSysVecColOneRandCyclic() defaults to setting order to nothing. The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Block-Vector-Row-Samplers","page":"Linear Samplers","title":"Block Vector Row Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysBlkRowGaussSampler\n\nLinSysBlkRowReplace\n\nLinSysBlkRowRandCyclic\n\nLinSysBlkRowFJLT\n\nLinSysBlkRowSRHT","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkRowGaussSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkRowGaussSampler","text":"LinSysBlkRowGaussSampler <: LinSysBlkRowSampler\n\nA mutable structure with fields to handle Guassian row sketching where a Gaussian matrix is multiplied by the matrix A from the left. \n\nFields\n\nblock_size::Int64, specifies the size of each block.\nsketch_matrix::Union{AbstractMatrix, Nothing}, the buffer for storing the Gaussian sketching matrix.\nscaling::Float64, the standard deviation of the sketch, is set to be sqrt(block_size/numberOfRows).\n\nConstructors\n\nCalling LinSysBlkRowGaussSampler() defaults to setting block_size to 2.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkRowReplace","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkRowReplace","text":"LinSysBlkRowReplace <: LinSysBlkRowSampler\n\nA mutable structure with fields to store information for a sampling method that forms a new block by uniformly sampling rows of A without replacement,  also known as vanilla block randomized Kaczmarz. \n\nNecoara, Ion. “Faster Randomized Block Kaczmarz Algorithms.” SIAM J. Matrix Anal. Appl. 40 (2019): 1425-1452.\n\nFields\n\nblock_size::Int64, specifies the size of each block.\nblock::Vector{Int64}, the list of all the rows in each block.\n\nConstructors\n\nCalling LinSysBlkRowReplace() defaults to setting block_size to 2. The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkRowRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkRowRandCyclic","text":"LinSysBlkRowRandCyclic <: LinSysBlkRowSampler\n\nA mutable structure with fields to handle randomly permuted block sampling. After all blocks are called,  a new random ordering is created. \n\nFields\n\nn_blocks::Int64, Variable that contains the number of blocks overall.\norder::Union{Vector{Int64}, Nothing}, The order that the blocks will be used to generate updates.\nblocks::Union{Vector{Vector{Int64}}, Nothing}, The list of all the row in each block.\n\nConstructors\n\nCalling LinSysBlkColRandCyclic() defaults to setting n_blocks to 2 and blocks to be sequentially ordered.  These values can be changed using the respective keyword arguments. The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkRowFJLT","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkRowFJLT","text":"LinSysBlkRowFJLT <: LinSysBlkRowSampler\n\nA mutable structure with fields to handle FJLT row sketching. At each iteration,  this procedure generates a matrix of the form S = G H D where G is sparse matrix with  the non-zero entries being drawn from a gaussian distribution, H is a Hadamard matrix,  and D is a diagonal matrix with a rademacher vector on the diagonal.\n\nFields\n\nblock_size::Int64, the size of the sketching dimension\nsparsity::Float64, the sparsity of the sampling matrix\npadded_size::Int64, the size of the matrix when padded\nsampling_matrix::Union{SparseMatrixCSC, Nothing}, storage for sparse sketching matrix \nhadamard::Union{AbstractMatrix, Nothing}, storage for the hadamard matrix.\nAp::Union{AbstractMatrix, Nothing}, storage for padded matrix\nbp::Union{AbstractMatrix, Nothing}, storage for padded vector\nscaling::Float64, storage for the scaling of the sketches.\n\nCalling LinSysBlkRowFJLT() defaults to setting sparsity to .3 and the blocksize to 2.\n\nAilon, Nir, and Bernard Chazelle. \"The fast Johnson–Lindenstrauss transform and approximate nearest neighbors.\"  SIAM Journal on computing 39.1 (2009): 302-322. https://doi.org/10.1137/060673096\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkRowSRHT","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkRowSRHT","text":"LinSysBlkRowSRHT <: LinSysBlkRowSampler\n\nA mutable structure with fields to handle SRHT row sketching. At each iteration, this  procedure generates a matrix of the form S = R H D where R is a subset of the identity  matrix, H is a Hadamard matrix, and D is a diagonal matrix with a rademacher vector on  the diagonal.\n\nFields\n\nblock_size::Int64, the size of blocks being chosen\npadded_size::Int64, the size of the matrix when padded\nblock::Union{Vector{Int64}, Nothing}, storage for block indices\nhadamard::Union{AbstractMatrix, Nothing}, storage for the hadamard matrix.\nAp::Union{AbstractMatrix, Nothing}, storage for padded matrix\nbp::Union{AbstractMatrix, Nothing}, storage for padded vector\nscaling::Float64, storage for the scaling of the sketches.\n\nCalling LinSysBlkRowSRHT() defaults to setting block_size to 2.\n\nNguyen, Nam H., Thong T. Do, and Trac D. Tran. \"A fast and efficient algorithm for low-rank approximation of a matrix.\"  Proceedings of the forty-first annual ACM symposium on Theory of computing. 2009. https://doi.org/10.1145/1536414.1536446\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Block-Vector-Col-Samplers","page":"Linear Samplers","title":"Block Vector Col Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysBlkColGaussSampler\n\nLinSysBlkColReplace\n\nLinSysBlkColRandCyclic\n\nLinSysBlkColFJLT\n\nLinSysBlkColSRHT","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkColGaussSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkColGaussSampler","text":"LinSysBlkColGaussSampler <: LinSysBlkColSampler\n\nA mutable structure with fields to handle Guassian column sketching where a Gaussian matrix is multiplied by the matrix A from the right.\n\nFields\n\nblock_size::Int64, specifies the size of each block.\nsketch_matrix::Union{AbstractMatrix, Nothing}, the buffer for storing the Gaussian sketching matrix.\nscaling::Float64, the standard deviation of the sketch, is set to be sqrt(block_size/numberOfColumns).\n\nConstructors\n\nCalling LinSysBlkColGaussSampler() defaults to setting block_size to 2.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkColReplace","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkColReplace","text":"LinSysVecBlkColReplace <: LinSysBlkColSampler\n\nA mutable structure with fields to store information for a sampling method that forms a new block by uniformly sampling columns of A without replacement.\n\nFields\n\nblock_size::Int64, specifies the size of each block.\nblock::Vector{Int64}, the list of all the rows in each block.\n\nConstructors\n\nCalling LinSysBlkColReplace() defaults to setting block_size to 2. The sample function will handle the initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkColRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkColRandCyclic","text":"LinSysBlkColRandCyclic <: LinSysBlkColSampler\n\nA mutable structure with fields to handle randomly permuted block sampling.  After all blocks are called, a new random ordering is created. \n\nFields\n\nn_blocks::Int64, Variable that contains the number of blocks overall.\norder::Vector{Int64}, The order that the blocks will be used to generate updates.\nblocks::Vector{Vector{Int64}}, The vector containing all the groupings of column indices.\n\nConstructors\n\nCalling LinSysBlkColRandCyclic() defaults to setting n_blocks to 2 and blocks to be sequentially ordered.  These values can be changed using the respective keyword arguments.  The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkColFJLT","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkColFJLT","text":"LinSysBlkColFJLT <: LinSysBlkColSampler\n\nA mutable structure with fields to handle FJLT column sketching. At each iteration, this  procedure generates a matrix of the form S = D H G where G is sparse matrix with the non-zero  entries being drawn from a gaussian distribution, H is a Hadamard matrix, and D is a diagonal  matrix with a rademacher vector on the diagonal.\n\nFields\n\nblock_size::Int64, the size of the sketching dimension\nsparsity::Float64, the sparsity of the sampling matrix, should be between 0 and 1\npadded_size::Int64, the size of the matrix when padded\nsampling_matrix::Union{SparseMatrixCSC, Nothing}, storage for sparse sketching matrix \nhadamard::Union{AbstractMatrix, Nothing}, storage for the hadamard matrix.\nAp::Union{AbstractMatrix, Nothing}, storage for padded matrix\nbp::Union{AbstractMatrix, Nothing}, storage for padded vector\nscaling::Float64, storage for the scaling of the sketches.\n\nCalling LinSysBlkColFJLT() defaults to setting sparsity to .3 and the blocksize to 2.\n\nAilon, Nir, and Bernard Chazelle. \"The fast Johnson–Lindenstrauss transform and approximate nearest neighbors.\"  SIAM Journal on computing 39.1 (2009): 302-322. https://doi.org/10.1137/060673096\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkColSRHT","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkColSRHT","text":"LinSysBlkColSRHT <: LinSysBlkColSampler\n\nA mutable structure with fields to handle SRHT column sketching. At each iteration, this  procedure generates a matrix of the form S = D H R where R is a subset of the identity  matrix, H is a Hadamard matrix, and D is a diagonal matrix with a rademacher vector on  the diagonal.\n\nFields\n\nblock_size::Int64, the size of blocks being chosen\npadded_size::Int64, the size of the matrix when padded\nblock::Union{Vector{Int64}, Nothing}, storage for block indices\nhadamard::Union{AbstractMatrix, Nothing}, storage for the hadamard matrix.\nAp::Union{AbstractMatrix, Nothing}, storage for padded matrix\nsigns::Union{Vector{Bool}, Nothing}, storage for random sign flips.\nscaling::Float64, storage for the scaling of the sketches.\n\nCalling LinSysBlkColSRHT() defaults to setting block_size to 2.\n\nNguyen, Nam H., Thong T. Do, and Trac D. Tran. \"A fast and efficient algorithm for low-rank approximation of a matrix.\"  Proceedings of the forty-first annual ACM symposium on Theory of computing. 2009. https://doi.org/10.1145/1536414.1536446\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Sample-Function","page":"Linear Samplers","title":"Sample Function","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"RLinearAlgebra.sample(::Nothing,::AbstractArray,::AbstractVector,\n    ::AbstractVector,::Int64)","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.sample-Tuple{Nothing, AbstractArray, AbstractVector{T} where T, AbstractVector{T} where T, Int64}","page":"Linear Samplers","title":"RLinearAlgebra.sample","text":"sample(type::T where T<:LinSysSampler,\n    A::AbstractArray,\n    b::AbstractVector,\n    x::AbstractVector,\n    iter::Int64)\n\nA common interface for specifying different strategies for sampling, selecting or sketching     a linear system specified by A and b. The type argument is used to select the an     appropriately defined strategy. The argument x is the current iterate value for the     solution. The arguent iter is the iteration counter.\n\nThe value(s) returned by sample depend on the subtype of LinSysSampler being used.     Specifically,\n\nFor T<:LinSysVecRowSampler, a vector in the row space of A and constant are returned\nFor T<:LinSysVecColSampler, a vector of length(x), the matrix A,   and a scalar-valued residual are returned.\n\n\n\n\n\n","category":"method"},{"location":"api/linear_samplers/#Internal-Functions","page":"Linear Samplers","title":"Internal Functions","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"RLinearAlgebra.init_blocks_cyclic!\n\nRLinearAlgebra.fwht!","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.init_blocks_cyclic!","page":"Linear Samplers","title":"RLinearAlgebra.init_blocks_cyclic!","text":"init_blocks_cyclic!(type::Union{LinSysBlkColRandCyclic,LinSysBlkRowRandCyclic}, dim::Int64)\n\nThis function intializes the blockSize, n_blocks, and order values for the LinSysBlkColRandCyclic  and LinSysBlkRowRandCyclic data structures. If a set of blocks is already defined by the user then it  warns the user which block indices are unused. If the blocks are not premade, it simply allocates block  indices sequentially with a size that is floor(n_blocks/dim).\n\n\n\n\n\n","category":"function"},{"location":"api/linear_samplers/#RLinearAlgebra.fwht!","page":"Linear Samplers","title":"RLinearAlgebra.fwht!","text":"fwht!(x::AbstractVector; signs=ones(Bool, size(x)), scaling = 1)\n\nPerforms a Fast Walsh Hadamard Transform (FWHT), modifying the vector x. This means that  if you want an unmodified version of x you should copy it before calling this function.  signs allows the user to input a boolean vector that flips the signs of the entries  of the vector x before applying the transform. scaling allows the user to scale the  result of the transform. Choosing a scaling of 1/sqrt{size(x)} will result in the FWHT  being an orthogonal transform.\n\n!!! Note: To avoid log computation at every call the function does not check that the dimension  is a power of 2. This must be done by a separate function at an earlier point.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_solver_routines/#Linear-Subsolvers","page":"Main Solvers","title":"Linear Subsolvers","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Main Solvers","title":"Main Solvers","text":"Pages=[\"linear_solver_routines.md\"]","category":"page"},{"location":"api/linear_solver_routines/#Abstract-Types","page":"Main Solvers","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Main Solvers","title":"Main Solvers","text":"LinSysSolveRoutine\n\nLinSysVecRowProjection\n\nLinSysVecColProjection\n\nLinSysBlkRowProjection\n\nLinSysBlkColProjection\n\nLinSysPreconKrylov","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysSolveRoutine","page":"Main Solvers","title":"RLinearAlgebra.LinSysSolveRoutine","text":"LinSysSolveRoutine\n\nAbstract supertype that specifies the type of linear system solver routine being deployed.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjection","page":"Main Solvers","title":"RLinearAlgebra.LinSysVecRowProjection","text":"LinSysVecRowProjection <: LinSysSolveRoutine\n\nAbstract supertype for vector row action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjection","page":"Main Solvers","title":"RLinearAlgebra.LinSysVecColProjection","text":"LinSysVecColProjection <: LinSysSolveRoutine\n\nAbstract supertype for vector column action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysBlkRowProjection","page":"Main Solvers","title":"RLinearAlgebra.LinSysBlkRowProjection","text":"LinSysBlkRowProjection <: LinSysSolveRoutine\n\nAbstract supertype for block row action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysBlkColProjection","page":"Main Solvers","title":"RLinearAlgebra.LinSysBlkColProjection","text":"LinSysBlkColProjection <: LinSysSolveRoutine\n\nAbstract supertype for block column action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysPreconKrylov","page":"Main Solvers","title":"RLinearAlgebra.LinSysPreconKrylov","text":"LinSysPreconKrylov <: LinSysSolveRoutine\n\nAbstract supertype for preconditioned Krylov solver.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Vector-Row-Solvers","page":"Main Solvers","title":"Vector Row Solvers","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Main Solvers","title":"Main Solvers","text":"LinSysVecRowProjStd\n\nLinSysVecRowProjPO\n\nLinSysVecRowProjFO\n\nIterativeHessianSketch","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjStd","page":"Main Solvers","title":"RLinearAlgebra.LinSysVecRowProjStd","text":"LinSysVecRowProjStd <: LinSysVecRowProjection\n\nA mutable structure that represents a standard row projection method.\n\nAliases\n\nKaczmarz, see Kaczmarz, M. S. \"Approximate solution of systems of linear equations.\"   (1937). Original article is in German.\nART, see Gordon, Richard, Robert Bender, and Gabor T. Herman. \"Algebraic reconstruction   techniques (ART) for three-dimensional electron microscopy and X-ray photography.\"   Journal of theoretical Biology 29.3 (1970): 471-481.\n\nFields\n\nalpha::Float64, a relaxation parameter that should be set between 0.0 and 2.0\n\nCalling LinSysVecRowProjStd() defaults the relaxation parameter to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjPO","page":"Main Solvers","title":"RLinearAlgebra.LinSysVecRowProjPO","text":"LinSysVecRowProjPO <: LinSysVecRowProjection\n\nA mutable structure that represents the standard row projection method     with orthogonalization of the current projection against a set of m previous     projection directions, where m is specified by the user.\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nα::Float64, the relaxation parameter (usually between 0.0 and 2.0)\nm::Int64, the number of previous directions against which to orthogonalize\nZ::Union{Vector{Vector{Float64}}, Nothing}, stores the m vectors against which the   current projection is orthogonalized against\n\nCalling LinSysVecRowProjPO() defaults the relaxation parameter to 1.0, the memory     parameter m to 5, and Z to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjFO","page":"Main Solvers","title":"RLinearAlgebra.LinSysVecRowProjFO","text":"LinSysVecRowProjFO <: LinSysVecRowProjection\n\nA mutable structure that represents the standard row projection method with full orthogonalization against all previous projections. Equivalently, this type represents a solver for incrementally constructed matrix sketches.\n\nSee McCormick, S. F. \"The methods of Kaczmarz and row orthogonalization for solving linear     equations and least squares problems in Hilbert space.\" Indiana University Mathematics     Journal 26.6 (1977): 1137-1150. https://www.jstor.org/stable/24891603\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nS::Union{Matrix{Float64}, Nothing} is a matrix used for orthogonalizing against   all previous search directions.\n\nCalling LinSysVecRowProjFO() defaults to LinSysVecRowProjFO(nothing).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.IterativeHessianSketch","page":"Main Solvers","title":"RLinearAlgebra.IterativeHessianSketch","text":"IterativeHessianSketch <: LinSysSolveRoutine\n\nA mutable structure that represents the Iterative Hessian Sketch Method.\n\nSee Mert Pilanci and Martin J. Wainwright. \"Iterative Hessian Sketch:      Fast and Accurate Solution Approximation for Constrained Least-Squares.\"     Journal of Machine Learning Research, 17(53), 1–38.     http://jmlr.org/papers/v17/14-460.html\n\nFields\n\nA::AbstractArray, the coefficient matrix for the linear system. Required as we need to compute the full residual.\nb::AbstractVector, the constant term (i.e., the linear system is Ax = b). Required as we need to compute the full residual.\nstep::Union{AbstractVector, Nothing}, buffer array to hold solution of subproblem that provides update to x.\nbtilde::Union{AbstractVector, Nothing}, buffer array to hold constant term in forming the subproblem to compute step.\n\nConstructors\n\n    IterativeHessianSketch(A, b)\n\nArguments\n\nA::AbstractArray, the coefficient matrix for the linear system. Required as we need to compute the full residual.\nb::AbstractVector, the constant term (i.e., the linear system is Ax = b). Required as we need to compute the full residual.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Vector-Column-Solvers","page":"Main Solvers","title":"Vector Column Solvers","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Main Solvers","title":"Main Solvers","text":"LinSysVecColProjStd\n\nLinSysVecColProjPO\n\nLinSysVecColProjFO","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjStd","page":"Main Solvers","title":"RLinearAlgebra.LinSysVecColProjStd","text":"LinSysVecColProjStd <: LinSysVecColProjection\n\nA mutable structure that represents a standard column projection method.\n\nSee Luo, Zhi-Quan, and Paul Tseng. \"On the convergence of the coordinate descent method     for convex differentiable minimization.\" Journal of Optimization Theory and     Applications 72.1 (1992): 7-35.\n\nFor a generalization, see Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado.     \"An Implicit Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nAliases\n\nCoordinateDescent\nGaussSeidel\n\nFields\n\nalpha::Float64, a relaxation parameter that should be set between 0.0 and 2.0\n\nCalling LinSysVecColProjStd() defaults the relaxatoin parameter to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjPO","page":"Main Solvers","title":"RLinearAlgebra.LinSysVecColProjPO","text":"LinSysVecColProjPO <: LinSysVecColProjection\n\nA mutable structure that represents the standard column projection method     with orthogonalization of the current projection against a set of m previous     projection directions, where m is specified by the user.\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nα::Float64, the relaxation parameter (usually between 0.0 and 2.0)\nm::Int64, the number of previous directions against which to orthogonalize\nZ::Union{Vector{Vector{Float64}}, Nothing}, stores the m vectors against which the   current projection is orthogonalized against\n\nCalling LinSysVecColProjPO() defaults the relaxation parameter to 1.0, the memory     parameter m to 5, and Z to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjFO","page":"Main Solvers","title":"RLinearAlgebra.LinSysVecColProjFO","text":"LinSysVecColProjFO <: LinSysVecColProjection\n\nA mutable structure that represents the standard column projection method with full orthogonalization against all previous projections.\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nS::Union{Matrix{Float64}, Nothing} is a matrix used for orthogonalizing against   all previous search directions.\n\nCalling LinSysVecColProjFO() defaults to LinSysVecColProjFO(nothing).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Block-Row-Solver","page":"Main Solvers","title":"Block Row Solver","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Main Solvers","title":"Main Solvers","text":"LinSysBlkRowLQ","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysBlkRowLQ","page":"Main Solvers","title":"RLinearAlgebra.LinSysBlkRowLQ","text":"LinSysBlkRowLQ <: LinSysBlkRowProjection\n\nA mutable structure that represents a standard block row projection method.\n\nAliases\n\nBlockKaczmarz\n\nFields\n\nα::Float64, a relaxation parameter that should be set between 0.0 and 2.0\nupdate::Union{Nothing, AbstractArray}, a buffer for storing update.\n\nConstructors\n\nCalling LinSysBlkRowProj() defaults the relaxation parameter to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Block-Column-Solver","page":"Main Solvers","title":"Block Column Solver","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Main Solvers","title":"Main Solvers","text":"LinSysBlkColGent","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysBlkColGent","page":"Main Solvers","title":"RLinearAlgebra.LinSysBlkColGent","text":"LinSysBlkColGent <: LinSysBlkColProjection\n\nA mutable structure that represents a standard block column projection method that projects  a previous iterate onto the columnspace of an inputted block. This method can be viewed as  a generalization to block coordinate descent. The updates to this are computed using Gentleman's Algorithm.\n\nFor more information on Gentleman's see: Miller, Alan J. “Algorithm AS 274: Least Squares Routines to Supplement Those of Gentleman.”  Journal of the Royal Statistical Society. Series C (Applied Statistics),  vol. 41, no. 2, 1992, pp. 458–78. JSTOR, https://doi.org/10.2307/2347583. \n\nAliases\n\nBlockCoordinateDescent\n\nFields\n\nα::Float64, a relaxation parameter that should be set between 0.0 and 2.0\ngent::GentData, a buffer to store important information related to the Gentleman's \n\nincremental QR least squares solver.\n\nupdate::Union{Nothing, AbstractArray}, a buffer for storing update.\nrowsize::Int64, the upper limit on the size of the row blocks in Gentleman's. By default this is set to 10000.\n\nConstructors\n\nCalling the constructor LinSysBlkColProj() defaults the relaxation parameter to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Solving-Routine","page":"Main Solvers","title":"Solving Routine","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Main Solvers","title":"Main Solvers","text":"RLinearAlgebra.rsubsolve!","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.rsubsolve!","page":"Main Solvers","title":"RLinearAlgebra.rsubsolve!","text":"rsubsolve!(\n    type::LinSysSolveRoutine,\n    x::AbstractVector,\n    samp::Tuple,\n    iter::Int64)\n\nA common interface for specifying different strategies for solving a subproblem generated     by a sampling, selecting or sketching operation on a linear system. The type argument     is used to select the appropriately defined strategy. The argument x is the current     iterate value for the solution. The argument samp depends on the subtype     of LinSysSolveRoutine that is being deployed and is described below. The iter     argument is the iteration counter.\n\nThe value of samp depends on the type of subtype of LinSysSolveRoutine being deployed. To describe this, let A be the coefficient matrix of the system, and b its constant vector.\n\nFor T<:LinSysVecRowProjection, samp is a two-dimensional tuple where the first   entry is a vector in the row space of A; and the second entry is a scalar value   corresponding to a linear combination of the elements of b.\nFor T<:LinSysVecColProjection, samp is a three-dimensional tuple where the first   entry is a vector of length(x) corresponding to the search direction; the second   entry is a matrix with the same number of rows as A (usually it is A);   and the third entry is a scalar-valued residual for the normal system corresponding   to samp[1]'* A' * (A * x - b).\n\nThe function rsubsolve! updates the quantity x and any fields of type that must be     updated.\n\n\n\n\n\n","category":"function"},{"location":"api/low_rank_approximations/#Low-Rank-Approximations","page":"Low Rank Approximations","title":"Low Rank Approximations","text":"","category":"section"},{"location":"api/low_rank_approximations/","page":"Low Rank Approximations","title":"Low Rank Approximations","text":"Pages=[\"low_rank_approximations.md\"]","category":"page"},{"location":"api/low_rank_approximations/#Abstract-Types","page":"Low Rank Approximations","title":"Abstract Types","text":"","category":"section"},{"location":"api/low_rank_approximations/","page":"Low Rank Approximations","title":"Low Rank Approximations","text":"ApproxMethod\n\nRangeFinderMethod\n\nIntDecompMethod\n\nNystromMethod","category":"page"},{"location":"api/low_rank_approximations/#RLinearAlgebra.ApproxMethod","page":"Low Rank Approximations","title":"RLinearAlgebra.ApproxMethod","text":"ApproxMethod \n\nAbstract supertype for low rank approximations to matrices. \n\n\n\n\n\n","category":"type"},{"location":"api/low_rank_approximations/#RLinearAlgebra.RangeFinderMethod","page":"Low Rank Approximations","title":"RLinearAlgebra.RangeFinderMethod","text":"RangeFinderMethod <: ApproxMethod\n\nAbstract supertype for Random Rangefinder techniques such as the random svd decomposition random qr decomposition, and the random eigen decompositions.\n\n\n\n\n\n","category":"type"},{"location":"api/low_rank_approximations/#RLinearAlgebra.IntDecompMethod","page":"Low Rank Approximations","title":"RLinearAlgebra.IntDecompMethod","text":" IntDecompMethod <: ApproxMethod\n\nAbstract supertype for Interpolatory decompositions. This includes methods like the CUR  decomposition.\n\n\n\n\n\n","category":"type"},{"location":"api/low_rank_approximations/#RLinearAlgebra.NystromMethod","page":"Low Rank Approximations","title":"RLinearAlgebra.NystromMethod","text":"NystromMethod <: ApproxMethod\n\nAbstract supertype for Nystrom techniques. These can only be applied to symmetric matrices.\n\n\n\n\n\n","category":"type"},{"location":"api/low_rank_approximations/#RangeFinder-Methods","page":"Low Rank Approximations","title":"RangeFinder Methods","text":"","category":"section"},{"location":"api/low_rank_approximations/","page":"Low Rank Approximations","title":"Low Rank Approximations","text":"","category":"page"},{"location":"api/low_rank_approximations/#Interpretlatory-Decomposition-Methods","page":"Low Rank Approximations","title":"Interpretlatory Decomposition Methods","text":"","category":"section"},{"location":"api/low_rank_approximations/","page":"Low Rank Approximations","title":"Low Rank Approximations","text":"","category":"page"},{"location":"api/low_rank_approximations/#Nystrom-Methods","page":"Low Rank Approximations","title":"Nystrom Methods","text":"","category":"section"},{"location":"api/low_rank_approximations/","page":"Low Rank Approximations","title":"Low Rank Approximations","text":"","category":"page"},{"location":"api/low_rank_approximations/#Approximate-Function","page":"Low Rank Approximations","title":"Approximate Function","text":"","category":"section"},{"location":"api/low_rank_approximations/","page":"Low Rank Approximations","title":"Low Rank Approximations","text":"RLinearAlgebra.rapproximate(::T where T<:ApproxMethod, ::AbstractArray)","category":"page"},{"location":"api/low_rank_approximations/#RLinearAlgebra.rapproximate-Tuple{ApproxMethod, AbstractArray}","page":"Low Rank Approximations","title":"RLinearAlgebra.rapproximate","text":"rapproximate(type::T where T<:ApproxMethod,\n            A::AbstractArray\n           )\n\nA common interface for specifying different strategies for forming low rank approximations of matrices using randomized techniques. This function edits the method data structure in place but will also return the decomposition as well as an error metric representing the  decompositions quality, if an error technique is specified.\n\n\n\n\n\n","category":"method"},{"location":"#RLinearAlgebra","page":"Home","title":"RLinearAlgebra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RLinearAlgebra is a Julia library for the development and application of randomized algorithms to the solution of linear systems of equations. Because of the large diversity of randomized techniques, rather than offering isolated routine implementations of algorithms, this library implements a series of extendable data structures and methods which allow code reuse.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, we implement data structures which allow the implementation of the following solver categories:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Row Projection Methods (RPM) including randomized Kazmarcz, Gauss-sketch, and sampled Motzkin.\nColumn Projection Methods (CPM) including randomized Coordinate Descent and randomized Gauss Seidel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Users can use the available algorithms or create new ones by adding new methods. For example, the RPM methods are composed by a sampling and a projection methods. Users can easily create new algorithms by implementing a new row sampling technique and leverage the existing projection methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To facilitate benchmarking, we provide an abstract class for solver solution logging and stopping criteria.","category":"page"},{"location":"#Documentation-structure","page":"Home","title":"Documentation structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation serves both as a manual to the library and as an introduction to randomized linear algebra solvers. We divide it in three parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorial: here we offer examples of how to solve linear systems with RLinearAlgebra and how to extend the library.\nManual: here we offer an introduction to solving linear systems with randomized linear algebra techniques. We introduce theoretical foundations and we provide code examples with RLinearAlgebra.\nAPI: a detailed description of all the classes and methods of the library.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is supported by the National Science Foundation Office of Advanced Cyberinfrastructure under awards 2309445 and 2309446. This material is based upon work supported by the U.S. Department of Energy, Office of Science, under contract number DE-AC02-06CH11357.","category":"page"},{"location":"api/contents/#Randomized-Linear-Solver-Reference","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"","category":"section"},{"location":"api/contents/","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"Pages=[\n  \"linear_rsolve.md\",\n  \"linear_samplers.md\",\n  \"linear_solver_routines.md\",\n  \"linear_solver_logs.md\",\n  \"linear_solver_stops.md\"]","category":"page"},{"location":"api/linear_solver_helpers/#Linear-Solver-Helpers","page":"Solver Helpers","title":"Linear Solver Helpers","text":"","category":"section"},{"location":"api/linear_solver_helpers/","page":"Solver Helpers","title":"Solver Helpers","text":"Pages=[\"linear_solver_helpers.md\"]","category":"page"},{"location":"api/linear_solver_helpers/#Gentleman's-Solver-for-Least-Squares","page":"Solver Helpers","title":"Gentleman's Solver for Least Squares","text":"","category":"section"},{"location":"api/linear_solver_helpers/#Abstract-Types","page":"Solver Helpers","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_solver_helpers/","page":"Solver Helpers","title":"Solver Helpers","text":"RLinearAlgebra.GentData","category":"page"},{"location":"api/linear_solver_helpers/#RLinearAlgebra.GentData","page":"Solver Helpers","title":"RLinearAlgebra.GentData","text":"GentData{S, M<:Matrix{S}, V<:Vector{S}}\n\nThis is a preallocated data structure for solving least squares problems with  Gentleman's algorithm. This data structure is not exported and thus is not  designed to be manipulated by the user.\n\nFields\n\nA::M, the matrix to be solved.\nB::M, the block of rows of A that are used to update the QR decomposition.\nR::UpperTriangular, the upper triangular part of B.\ntab::SubArray, the last column of B where the constant vector entries corresponding\n\nto the rows of A that were brought to B are stored.\n\nv::V, a buffer vector that stores the scaling constants from the Householder reflections,\n\nsee LAPACK.geqrf! in LinearAlgebra for more information.\n\nbsize::Int64, the number of rows transported to B at each iteration.\n\nCalling Gent(A, bsize) will allocate a B matrix with the n + 1 columns and  n + bsize + 1 rows where n is the number of columns of A. It also allocates a  buffer vector v with n + 1 entries. Finally, it allocates a view of the upper triangular part of B[1:n, 1:n] and a view of the last column of B.\n\nMiller, Alan J. “Algorithm AS 274: Least Squares Routines to Supplement Those of Gentleman.”  Journal of the Royal Statistical Society. Series C (Applied Statistics), vol. 41, no. 2, 1992,  pp. 458–78. JSTOR, https://doi.org/10.2307/2347583. \n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_helpers/#Solver","page":"Solver Helpers","title":"Solver","text":"","category":"section"},{"location":"api/linear_solver_helpers/","page":"Solver Helpers","title":"Solver Helpers","text":"RLinearAlgebra.gentleman!\nRLinearAlgebra.ldiv!\nRLinearAlgebra.copy_block_from_mat!\nRLinearAlgebra.reset_gent!","category":"page"},{"location":"api/linear_solver_helpers/#RLinearAlgebra.gentleman!","page":"Solver Helpers","title":"RLinearAlgebra.gentleman!","text":"gentleman!(G::GentData)\n\nA function that updates the GenData structure with the Gentleman's algorithm applied to a single row block of A.\n\nInputs\n\nG::GentData, a data structure with the information to be updated\n\nby an iteration of Gentlemans.\n\nOutput\n\nThe function will result in updates to the upper triangular part R and the tab vector of the GentData structure.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_solver_helpers/#LinearAlgebra.ldiv!","page":"Solver Helpers","title":"LinearAlgebra.ldiv!","text":"ldiv!(x::AbstractVector, G::GentData, b::AbstractVector)\n\nFunction that takes the allocated GentData structure to solve the least squares problem min_x A x-b_2^2. The function overwrites x with the solution.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_solver_helpers/#RLinearAlgebra.copy_block_from_mat!","page":"Solver Helpers","title":"RLinearAlgebra.copy_block_from_mat!","text":"copyBlockFromMat!(B::AbstractMatrix, A::AbstractMatrix, b::AbstractVector, index::Union{UnitRange{Int64}, Vector{Int64}})\n\nFunction that updates matrix B with the entries at indicies index corresponding to the rows of the A matrix and the  entries of the b constant vector of the linear system.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_solver_helpers/#RLinearAlgebra.reset_gent!","page":"Solver Helpers","title":"RLinearAlgebra.reset_gent!","text":"resetGent!(G::GentData)\n\nFunction that sets all the allocated memory of GentData to zero.\n\n\n\n\n\n","category":"function"}]
}
