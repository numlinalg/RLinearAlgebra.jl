var documenterSearchIndex = {"docs":
[{"location":"references/","page":"References","title":"References","text":"D. P. Woodruff. Sketching as a tool for numerical linear algebra. Foundations and Trends in Theoretical Computer Science 10, 1–157 (2014).\n\n\n\nN. Ailon and B. Chazelle. The Fast Johnson–Lindenstrauss Transform and Approximate Nearest Neighbors. SIAM Journal on Computing 39, 302–322 (2009).\n\n\n\nP.-G. Martinsson and J. Tropp. Randomized Numerical Linear Algebra: Foundations &amp; Algorithms (2020).\n\n\n\nJ. A. Tropp. Improved Analysis of the Subsampled Randomized Hadamard Transform. Advances in Adaptive Data Analysis 03, 115–126 (2011).\n\n\n\nT. Strohmer and R. Vershynin. A Randomized Kaczmarz Algorithm with Exponential Convergence. Journal of Fourier Analysis and Applications 15, 262–278 (2009).\n\n\n\nD. Needell and J. A. Tropp. Paved with Good Intentions: Analysis of a Randomized Block Kaczmarz Method. Linear Algebra and its Applications 441, 199–221 (2014).\n\n\n\nV. Patel, M. Jahangoshahi and D. A. Maldonado. Randomized Block Adaptive Linear System Solvers. SIAM Journal on Matrix Analysis and Applications 44, 1349–1369 (2023).\n\n\n\nT. S. Motzkin and I. J. Schoenberg. The Relaxation Method for Linear Inequalities. Canadian Journal of Mathematics 6, 393–404 (1954).\n\n\n\nN. Halko, P. G. Martinsson and J. A. Tropp. Finding Structure with Randomness: Probabilistic Algorithms for Constructing Approximate Matrix Decompositions. SIAM Review 53, 217–288 (2011).\n\n\n\n","category":"page"},{"location":"api/sub_solvers/#SubSolvers","page":"SubSolvers","title":"SubSolvers","text":"","category":"section"},{"location":"api/sub_solvers/","page":"SubSolvers","title":"SubSolvers","text":"Pages = [\"sub_solvers.md\"]","category":"page"},{"location":"api/sub_solvers/#Abstract-Types","page":"SubSolvers","title":"Abstract Types","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.SubSolver","page":"SubSolvers","title":"RLinearAlgebra.SubSolver","text":"SubSolver\n\nAn abstract supertype for structures specifying solution methods for a linear system or least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.SubSolverRecipe","page":"SubSolvers","title":"RLinearAlgebra.SubSolverRecipe","text":"SubSolverRecipe\n\nAn abstract supertype for structures with pre-allocated memory for methods that solve a linear system or least squares problem.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#SubSolver-Structures","page":"SubSolvers","title":"SubSolver Structures","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.LQSolver","page":"SubSolvers","title":"RLinearAlgebra.LQSolver","text":"LQSolver <: SubSolver\n\nA type containing information relevant to solving the linear subsystems created by the      Solver routines with the LQ factorization. As there are no user controlled parameters,      if the user wishes to use this method they can simply specify LQSolver().\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.LQSolverRecipe","page":"SubSolvers","title":"RLinearAlgebra.LQSolverRecipe","text":"LQSolverRecipe <: SubSolverRecipe{M<:AbstractArray}\n\nA mutable type containing informtation relevant to solving the linear subsytems created by      the Solver routines with the LQ factorization.\n\nFields\n\nA::M, The matrix in the linear system that will be solved with the LQ solver.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.QRSolver","page":"SubSolvers","title":"RLinearAlgebra.QRSolver","text":"QRSolver <: SubSolver\n\nA type containing information relevant to solving the linear subsystems created by the      Solver routines with the QR factorization. As there are no user controlled parameters,      if the user wishes to use this method they can simply specify QRSolver().\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#RLinearAlgebra.QRSolverRecipe","page":"SubSolvers","title":"RLinearAlgebra.QRSolverRecipe","text":"QRSolverRecipe{M<:AbstractArray} <: SubSolverRecipe\n\nA mutable type containing information relevant to solving the linear subsystems created by      the Solver routines with the QR factorization.\n\nFields\n\nA::M, The matrix in the linear system that will be solved with the QR solver.\n\n\n\n\n\n","category":"type"},{"location":"api/sub_solvers/#Exported-Functions","page":"SubSolvers","title":"Exported Functions","text":"","category":"section"},{"location":"api/sub_solvers/#RLinearAlgebra.complete_sub_solver","page":"SubSolvers","title":"RLinearAlgebra.complete_sub_solver","text":"complete_sub_solver(solver::SubSolver, A::AbstractArray)\n\nA function that generates a SubSolverRecipe given the      arguments.\n\nArguments\n\nsolver::SubSolver, a user-specified sub-solving method.\nA::AbstractArray, a coefficient matrix or vector. \n\nReturns\n\nA SubSolverRecipe object.\n\n\n\n\n\ncomplete_sub_solver(solver::SubSolver, A::AbstractArray, b::AbstractArray)\n\nA function that generates a SubSolverRecipe given the      arguments.\n\nArguments\n\nsolver::SubSolver, a user-specified sub-solving method.\nA::AbstractArray, a coefficient matrix or vector. \nb::AbstractArray, a constant matrix or vector. \n\nReturns\n\nA SubSolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/sub_solvers/#RLinearAlgebra.update_sub_solver!","page":"SubSolvers","title":"RLinearAlgebra.update_sub_solver!","text":"update_sub_solver!(solver::SubSolverRecipe, A::AbstractArray)\n\nA function that updates the SubSolver in place given      arguments.\n\nArguments\n\nsolver::SubSolverRecipe, a fully initialized realization for a   linear sub-solver.\nA::AbstractArray, a coefficient matrix or vector. \n\nReturns\n\nModifies the SubSolverRecipe in place given the arguments.and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#Compressors","page":"Compressors Overview","title":"Compressors","text":"","category":"section"},{"location":"api/compressors/","page":"Compressors Overview","title":"Compressors Overview","text":"Pages = [\"compressors.md\"]","category":"page"},{"location":"api/compressors/#Abstract-Types","page":"Compressors Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.Compressor","page":"Compressors Overview","title":"RLinearAlgebra.Compressor","text":"Compressor\n\nAn abstract supertype for structures that contain user-controlled parameters corresponding to techniques that compress a matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CompressorRecipe","page":"Compressors Overview","title":"RLinearAlgebra.CompressorRecipe","text":"CompressorRecipe\n\nAn abstract supertype for structures that contain both the user-controlled parameters in the Compressor and the memory allocations necessary for applying the compression technique to a particular set of matrices and vectors.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CompressorAdjoint","page":"Compressors Overview","title":"RLinearAlgebra.CompressorAdjoint","text":"CompressorAdjoint{S<:CompressorRecipe}\n\nA structure for the adjoint of a compression recipe.\n\nFields\n\nParent::CompressorRecipe, the CompressorRecipe the adjoint is being applied to.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Cardinality","page":"Compressors Overview","title":"RLinearAlgebra.Cardinality","text":"Cardinality\n\nAn abstract type for types that specify whether a compressor will be applied from the left or the right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Left","page":"Compressors Overview","title":"RLinearAlgebra.Left","text":"Left <: Cardinality\n\nA struct indicating matrix multiplication from the left.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Right","page":"Compressors Overview","title":"RLinearAlgebra.Right","text":"Right <: Cardinality\n\nA struct indicating matrix multiplication from the right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Undef","page":"Compressors Overview","title":"RLinearAlgebra.Undef","text":"Undef <: Cardinality\n\nA struct indicating matrix multiplication is undefined.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#Compressor-Structures","page":"Compressors Overview","title":"Compressor Structures","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.CountSketch","page":"Compressors Overview","title":"RLinearAlgebra.CountSketch","text":"CountSketch <: Compressor\n\nAn implementation of the count sketch compression method. See additional details in  [1] Section 2.1, in which the CountSketch matrix is equivalently defined as sparse  embedding matrix.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from  the left (i.e., we reduce the number of rows), then we construct a Count Sketch matrix S with  dimension s times m, where s is the user-specified compression dimension. Each column of  S is generated independently by the following steps:\n\nRandomly select an integer between 1 and s to determine the row position of the nonzero entry.\nAssign this entry a value of either +1 or -1, chosen uniformly at random.\nSet all the other entries in the column to zero.\n\nAs a result, each column of S has exactly one nonzero element.\n\nIf A is compressed from the right, then we construct a Count Sketch matrix S with dimension  n times s, where s is the user-specified compression dimension. Each row of S is  generated independently using the following steps:\n\nRandomly select an integer between 1 and s to determine the column position of the nonzero entry.\nAssign this entry a value of either +1 or -1, chosen uniformly at random.\nSet all other entries in the row to zero.\n\nIn this case, each row of S has exactly one nonzero entry.  The compressed matrix is then formed by multiplying S A (for left compression) or A S (for right compression).\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nCountSketch(;carinality=Left(), compression_dim=2, type=Float64)\n\nKeywords\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\ntype::Type{<:Number}, the type of the elements in the compressor. By default is set   to Float64.\n\nReturns\n\nA CountSketch object.\n\nThrows\n\nArgumentError if compression_dim is non-positive\nArgumentError if Undef() is taken as the input for cardinality\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.CountSketchRecipe","page":"Compressors Overview","title":"RLinearAlgebra.CountSketchRecipe","text":"CountSketchRecipe <: CompressorRecipe\n\nThe recipe containing all allocations and information for the CountSketch compressor.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The    value is either Left() or Right().\ncompression_dim::Int64, the target compression dimension.\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64`, the number of columns of the compression matrix.\nmat::SparseMatrixCSC, the compression matrix stored in a sparse form.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.FJLT","page":"Compressors Overview","title":"RLinearAlgebra.FJLT","text":"FJLT <: Compressor\n\nAn implementation of the Fast Johnson-Lindenstrauss Transform method. This technique applies a sparse matrix, a Walsh-Hadamard transform, and a diagonal sign matrix to produce a sketch.  See [2] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Here S=KHD where \n\nK is a sparse matrix with  with dimension s times m, where each entry has    probability q of being non-zero, and, if it is non-zero, then its value is    drawn from an independent normal distribution with mean 0 and variance 1q;\nH is a Hadamard matrix of dimension m times m, which is implicitly applied    through the fast Walsh-Hadamard transform;\nD of is a diagonal matrix of dimension m times m with entries given by    independent Rademacher variables.\n\nIf we want to compress A from the right (i.e., we reduce the number of columns), then  we would apply S=DHK from the right where the dimensions of the matrices are adjusted  to reflect the number of columns in A.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nblock_size::Int64, the number of vectors in the padding matrix.\nsparsity::Int64, the desired sparsity of the matrix K.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nFJLT(;\n    cardinality=Left(),\n    compression_dim::Int64=2,\n    block_size::Int64=10,\n    sparsity::Float64=0.0,\n    type::Type{N}=Float64,\n) where {N<:Number}\n\nKeywords\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description. By default this is set to 2.\nblock_size::Int64, the number of vectors in the padding matrix.\nsparsity::Int64, the desired sparsity of the matrix K, by default sparsity will be    set to be minleft(14 log(n)^2  m 1right), see [2].\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA FJLT object.\n\nThrows\n\nArgumentError if compression_dim is non-positive, if sparsity is not in 01,   or if block_size is non-positive.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.FJLTRecipe","page":"Compressors Overview","title":"RLinearAlgebra.FJLTRecipe","text":"FJLTRecipe{C<:Cardinality, S<:SparseMatrixCSC, M<:AbstractMatrix} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the FJLT compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are Left() or Right().\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nsparsity:Float64, the sparsity, q, of the sparse component, K.\nscale::Float64, the factor to ensure the isopmorphism of the sketch.\nop::SparseMatrixCSC, the sparse matrix K in the mathematical description.\nsigns::BitVector, the vector of signs where 0 indicates negative one and 1 indicates   positive one. \npadding::AbstractMatrix, the matrix containing the padding for the matrix being sketched.\n\nConstructor\n\nFJLTRecipe(\n    compression_dim::Int64, \n    block_size::Int64,\n    cardinality::C where {C<:Cardinality},\n    sparsity::Float64,\n    A::AbstractMatrix, \n    type::Type{<:Number}\n)\n\nKeywords\n\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\nblock_size::Int64, the number of columns in the padding memory buffer.\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\nsparsity::Vector{Number}, the expected sparsity of the Sparse operator matrix.\nA::AbstractMatrix, the matrix being compressed.\ntype::Type{<:Number}, the type of elements in the compressor.\n\ninfo: Info\nIf the sparsity parameter is set to 0.0, then the sparsity will be set to  minleft(14 log(n)^2  m 1right), see [2].\n\nReturns\n\nA FJLTRecipe object.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Gaussian","page":"Compressors Overview","title":"RLinearAlgebra.Gaussian","text":"Gaussian <: Compressor\n\nA specification for a Gaussian compressor.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress.\n\nIf we want to compress A from the left (i.e., we reduce the number of rows), then we create a Gaussian sketch matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Each entry of S is generated independently following N(0, 1/s), namely, a Gaussian distribution with mean being zero and variance being 1 divided by the compression dimension.\n\nIf A is compressed from the right, then we create a Gaussian sketch matrix, S, with dimension n times s, where s is the compression dimension that is supplied by the user. Each entry of S is generated independently following N(0, 1/s), namely, a Gaussian distribution with mean being zero and variance being 1 divided by the compression dimension.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in    the mathematical description.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nGaussian(;cardinality=Left(), compression_dim=2, type=Float64)\n\nArguments\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in    the mathemtical description. By default this is set to 2.\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA Gaussian object.\n\nThrows\n\nArgumentError if compression_dim is non-positive\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.GaussianRecipe","page":"Compressors Overview","title":"RLinearAlgebra.GaussianRecipe","text":"GaussianRecipe <: CompressorRecipe\n\nThe recipe containing all allocations and information for the Gaussian compressor.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The\n\nvalue is either Left() or Right().\n\ncompression_dim::Int64, the target compression dimension.\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nscale::Number, the standard deviation of Gaussian distribution during the \n\ncompression matrix generation.\n\nop::Matrix{Float64}, the Gaussian compression matrix.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.Sampling","page":"Compressors Overview","title":"RLinearAlgebra.Sampling","text":"Sampling <: Compressor\n\nThis method subsets the rows  or columns of a matrix according to a user-supplied distribution. The size of the  subset is also provided by the user.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress.\n\nIf we want to compress A from the left (i.e., we reduce the number of rows), then we create an index set to contain all the indices of selected rows. The indices are  chosen by sampling over all the rows with the user-specified distribution in the  distribution field.\n\nIf A is compressed from the right (i.e., we reduce the number of columns), then we create an index set to contain all the indices of selected columns. The indices  are chosen by sampling over all the columns with the user-specified distribution  in the distribution field.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension.\ndistribution::Distribution, the distribution being used to assign probability weights   on the indices.\n\nConstructor\n\nSampling(;cardinality = Left(), compression_dim = 2, distribution)\n\nArguments\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. By default this is set to 2.\ndistribution::Distribution, the distribution being used to assign probability weights   on the indices. By default this is set as Uniform distribution.\n\nReturns\n\nA Sampling object.\n\nThrows\n\nArgumentError if compression_dim is non-positive\nArgumentError if Undef() is taken as the input for cardinality\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SamplingRecipe","page":"Compressors Overview","title":"RLinearAlgebra.SamplingRecipe","text":"SamplingRecipe{C<:Cardinality} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the sampling compressor. \n\nFields\n\ncardinality::Cardinality, the cardinality of the compressor. The   value is either Left() or Right().\ncompression_dim::Int64, the target compression dimension.\nn_rows::Int64, number of rows of compression matrix.\nn_cols::Int64, number of columns of compression matrix.\ndistribution_recipe::DistributionRecipe, the user-specified distribution recipe.\nidx::Vector{Int64}, the index set that contains all the chosen indices.\nidx_v::SubArray, the view of the idx.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SparseSign","page":"Compressors Overview","title":"RLinearAlgebra.SparseSign","text":"SparseSign <: Compressor\n\nAn implementation of the sparse sign compression method. This method forms a sparse matrix with a fixed number of non-zeros per row or column depending on the direction that the compressor is being applied. See Section 9.2 of [3] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a sparse sign matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. In this case, each column of S is generated independently by the following steps:\n\nRandomly choose nnz components of the the s components of the column. Note, nnz  is supplied by the user.\nFor each selected component, randomly set it either to -1sqrttextnnz or  1sqrttextnnz with equal probability.\nSet the remaining components of the column to zero.\n\nIf A is compressed from the right, then we create a sparse sign matrix, S, with dimension n times s, where s is the compression dimension that is supplied by the user. In this case, each row of S is generated independently by the following steps:\n\nRandomly choose nnz components fo the s components of the row. Note, nnz  is supplied by the user.\nFor each selected component, randomly set it either to -1sqrttextnnz or  1sqrttextnnz with equal probability.\nSet the remaining components of the row to zero.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nnnz::Int64, the target number of nonzeros for each column or row of the spares sign   matrix.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nSparseSign(;carinality=Left(), compression_dim=2, nnz::Int64=8, type=Float64)\n\nKeywords\n\ncarinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim, the target compression dimension. Referred to as s in the   mathemtical description. By default this is set to 2.\nnnz::Int64, the number of non-zeros per row/column in the sampling matrix. By default   this is set to min(compressiond_dim, 8).\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA SparseSign object.\n\nThrows\n\nArgumentError if compression_dim is non-positive, if nnz is exceeds   compression_dim, or if nnz is non-positive.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SparseSignRecipe","page":"Compressors Overview","title":"RLinearAlgebra.SparseSignRecipe","text":"SparseSignRecipe{C<:Cardinality} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the SparseSign compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to\n\nbe applied to a target matrix or operator. Values allowed are Left() or Right().\n\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nnnz::Int64, the number of non-zero entries in each row if cardinality==Left or the\n\nnumber of non-zero entries each column if cardinality==Right.\n\nscale::Vector{Number}, the set of values of the non-zero entries of the Spares Sign\n\ncompression matrix.\n\nop::SparseMatrixCSC, the Spares Sign compression matrix.\n\nConstructors\n\nSparseSignRecipe(\n    cardinality::C where C<:Cardinality,\n    compression_dim::Int64, \n    A::AbstractMatrix, \n    nnz::Int64, \n    type::Type{<:Number}\n)\n\nAn external constructor of SparseSignRecipe that is dispatched based on the  value of cardinality. See SparseSign for additional details. \n\nArguments\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The    value is either Left() or Right()\ncompression_dim::Int64, the target compression dimension.\nA::AbstractMatrix, a target matrix for compression. \nnnz::Int64, the number of nonzeros in the Sparse Sign compression matrix.\ntype::Type{<:Number}, the data type for the entries of the compression matrix.\n\nReturns\n\nA SparseSignRecipe object.\n\nwarning: Use `complete_compressor`\nWhile an external constructor is provided, it is mainly for internal use. To ensure cross library compatibility please use complete_compressor for forming the SparseSignRecipe.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SRHT","page":"Compressors Overview","title":"RLinearAlgebra.SRHT","text":"SRHT <: Compressor\n\nAn implementation of the Subsampled Randomized Hadamard Transform (SRHT) method. This  technique applies a subsampling matrix, a Walsh-Hadamard transform, and a diagonal sign  matrix to produce a sketch. See [4] for additional details.\n\nMathematical Description\n\nLet A be an m times n matrix that we want to compress. If we want to compress A from the left (i.e., we reduce the number of rows), then we create a matrix, S, with dimension s times m where s is the compression dimension that is supplied by the user. Here S=KHD where \n\nK is a matrix with  with dimension s times m, where the rows are made up of a    random sample of the rows of a m times m identity matrix.\nH is a Hadamard matrix of dimension m times m, which is implicitly applied    through the fast Walsh-Hadamard transform;\nD of is a diagonal matrix of dimension m times m with entries given by    independent Rademacher variables.\n\nIf we want to compress A from the right (i.e., we reduce the number of columns), then  we would apply S=DHK from the right where the dimensions of the matrices are adjusted  to reflect the number of columns in A.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nblock_size::Int64, the number of vectors in the padding matrix.\ntype::Type{<:Number}, the type of the elements in the compressor.\n\nConstructor\n\nSRHT(;\n    cardinality = Left(),\n    compression_dim::Int64=2,\n    block_size::Int64=10,\n    type::Type{N}=Float64\n) where {N <: Number}\n\nKeywords\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().   By default Left() is chosen.\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description. By default this is set to 2.\nblock_size::Int64, the number of vectors in the padding matrix.\ntype::Type{<:Number}, the type of elements in the compressor.\n\nReturns\n\nA SRHT object.\n\nThrows\n\nArgumentError if compression_dim is non-positive or if block_size is non-positive.\nArgumentError if Cardinality is not either Left or Right.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#RLinearAlgebra.SRHTRecipe","page":"Compressors Overview","title":"RLinearAlgebra.SRHTRecipe","text":"SRHTRecipe{C<:Cardinality, M<:AbstractMatrix} <: CompressorRecipe\n\nThe recipe containing all allocations and information for the SRHT compressor.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to   be applied to a target matrix or operator. Values allowed are Left() or Right().\nn_rows::Int64, the number of rows of the compression matrix.\nn_cols::Int64, the number of columns of the compression matrix.\nscale::Float64, the factor to ensure the isopmorphism of the sketch.\nop::Vector{Int64}, the vector of indices to be subsampled.\nsigns::BitVector, the vector of signs where 0 indicates negative one and 1 indicates   positive one. \npadding::AbstractMatrix, the matrix containing the padding for the matrix being    sketched.\n\nConstructor\n\nSRHTRecipe(\n    compression_dim::Int64,\n    block_size::Int64,\n    cardinality::Left,\n    A::AbstractMatrix,\n    type::Type{<:Number}\n)\n\nKeywords\n\ncompression_dim::Int64, the target compression dimension. Referred to as s in the   mathematical description.\nblock_size::Int64, the number of vectors in the padding matrix.\ncardinality::Left, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right().\nA::AbstractMatrix, the matrix being compressed.\ntype::Type{<:Number}, the type of elements in the compressor.\n\n\n\n\n\n","category":"type"},{"location":"api/compressors/#Exported-Functions","page":"Compressors Overview","title":"Exported  Functions","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.complete_compressor","page":"Compressors Overview","title":"RLinearAlgebra.complete_compressor","text":"complete_compressor(compressor::Compressor, x::AbstractVector)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nx::AbstractVector, a vector that ususally represents a current iterate    typically used in a solver.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\ncomplete_compressor(compressor::Compressor, A::AbstractMatrix)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nA::AbstractMatrix, a target matrix for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\ncomplete_compressor(compressor::Compressor, A::AbstractMatrix, b::AbstractVector)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\ncomplete_compressor(\n    compressor::Compressor, \n    x::AbstractVector\n    A::AbstractMatrix, \n    b::AbstractVector, \n)\n\nA function that generates a CompressorRecipe given the      arguments.\n\nArguments\n\ncompressor::Compressor, a user-specified compression method.\nx::AbstractVector, a vector that ususally represents a current iterate    typically used in a solver.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nA CompressorRecipe object.\n\nThrows\n\nArgumentError if no method for completing the compressor exists    for the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.update_compressor!","page":"Compressors Overview","title":"RLinearAlgebra.update_compressor!","text":"update_compressor!(S::CompressorRecipe)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(S::CompressorRecipe, A::AbstractMatrix)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nA::AbstractMatrix, a target matrix for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(S::CompressorRecipe, A::AbstractMatrix, b::AbstractVector)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\nupdate_compressor!(\n    S::CompressorRecipe, \n    A::AbstractMatrix, \n    b::AbstractVector,\n    x::AbstractMatrix\n)\n\nA function that updates the CompressorRecipe in place given      arguments.\n\nArguments\n\nS::CompressorRecipe, a fully    initialized realization for a compression method for a specific matrix or collection    of matrices and vectors.\nx::AbstractVector, a vector that ususally represents a current iterate    typically used in a solver.\nA::AbstractMatrix, a target matrix for compression.\nb::AbstractVector, a possible target vector for compression.\n\nReturns\n\nnothing\n\nThrows\n\nArgumentError if no method exists for updating the compressor    exists.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#Internal-Functions","page":"Compressors Overview","title":"Internal Functions","text":"","category":"section"},{"location":"api/compressors/#RLinearAlgebra.left_mul_dimcheck","page":"Compressors Overview","title":"RLinearAlgebra.left_mul_dimcheck","text":"left_mul_dimcheck(C::AbstractMatrix, S::CompressorRecipe, A::AbstractMatrix)\n\nA function that checks the compatibility of arguments for      multiplication from the left.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nS::Union{CompressorRecipe, ApproximatorRecipe}, a fully    initialized realization for a compression or approximator method for a    specific AbstractArray or operator.\nA::AbstractArray, a target AbstractArray for compression.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\nleft_mul_dimcheck(C::AbstractMatrix, S::CompressorAdjoint, A::AbstractMatrix)\n\nA function that checks the compatibility of arguments for      multiplication from the left.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nS::Union{CompressorAdjoint, ApproximatorAdjoint}, the    representation of an adjoint of a compression or approximator operator.\nA::AbstractArray, a target AbstractArray for compression.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.right_mul_dimcheck","page":"Compressors Overview","title":"RLinearAlgebra.right_mul_dimcheck","text":"right_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix, S::CompressorRecipe)\n\nA function that checks the compatibility of arguments for      multiplication from the right.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nA::AbstractArray, a target AbstractArray for compression.\nS::Union{CompressorRecipe, ApproximatorRecipe}, a fully    initialized realization for a compression or approximator method for a    specific AbstractArray or operator.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\nright_mul_dimcheck(C::AbstractMatrix, A::AbstractMatrix, S::CompressorAdjoint)\n\nA function that checks the compatibility of arguments for      multiplication from the right.\n\nArguments\n\nC::AbstractArray, a AbstractArray where the output will be stored.\nA::AbstractArray, a target AbstractArray for compression.\nS::Union{CompressorAdjoint, ApproximatorAdjoint}, the    representation of an adjoint of a compression or approximator operator.\n\nReturns\n\nnothing\n\nThrows\n\nDimensionMismatch if dimensions of arguments are not compatible for   multiplication.\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.sparse_idx_update!","page":"Compressors Overview","title":"RLinearAlgebra.sparse_idx_update!","text":"sparse_idx_update!(\n    values::Vector{Int64}, \n    max_sample_val::Int64, \n    n_samples::Int64, \n    sample_size::Int64\n)\n\nImplicitly splits values into n_samples components of size sample_size.  On each component, replaces the entries of each component with a random sample  without replacement of size sample_size from the set 1:max_sample_val.\n\nwarn: Warn\nvalues should have length equal to sample_size*n_samples, but this  is not checked. \n\nArguments\n\nvalues::Vector{Int64}, a vector containing samples from 1:max_sample_val.\nmax_sample_val::In64, implicitly supplies the set from which to sample,   1:max_sample_val.\nn_samples::Int64, the number of components that values is implicitly split into. \nsample_size::Int64, the size each component that values is split into.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api/compressors/#RLinearAlgebra.fwht!","page":"Compressors Overview","title":"RLinearAlgebra.fwht!","text":"fwht!(x::AbstractVector, signs::BitVector; scaling::Int64 = 1)\n\nPerforms an in-place Fast Walsh Hadamard Transform on the vector x.   signs allows the user to input a boolean vector that flips the signs of the entries  of the vector x before applying the transform. scaling allows the user to scale the  result of the transform. Choosing a scaling of 1/sqrt{size(x)} will result in the FWHT  being an orthogonal transform.\n\nArguments\n\nx::AbstractVector, the vector the FJLT will be applied to.\nsigns::Vector{Bool}, whether the sign of each entry is positive or negative.\n\nKeywords\n\nscaling::Number, how much the vector is scaled, by default this is 1.\n\nReturns\n\nnothing\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#Loggers","page":"Loggers","title":"Loggers","text":"","category":"section"},{"location":"api/loggers/","page":"Loggers","title":"Loggers","text":"Pages = [\"loggers.md\"]","category":"page"},{"location":"api/loggers/#Abstract-Types","page":"Loggers","title":"Abstract Types","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.Logger","page":"Loggers","title":"RLinearAlgebra.Logger","text":"Logger\n\nAn abstract supertype for structures that record the progress of a SolverRecipe applied to a coefficient matrix and constant vector.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#RLinearAlgebra.LoggerRecipe","page":"Loggers","title":"RLinearAlgebra.LoggerRecipe","text":"LoggerRecipe\n\nAn abstract supertype for a structure that contains pre-allocated memory for a method that records the progress of a SolverRecipe.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#Logger-Structures","page":"Loggers","title":"Logger Structures","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.BasicLogger","page":"Loggers","title":"RLinearAlgebra.BasicLogger","text":"BasicLogger <: Logger\n\nThis is a mutable struct that contains the max_it parameter and stores the error metric      in a vector. Checks convergence of the solver based on the log information.\n\nFields\n\nmax_it::Int64, The maximum number of iterations for the solver. If not specified by the  user, it is set to 3 times the number of rows in the matrix.\nthreshold_info::Union{Float64, Tuple}, The parameters used for stopping the algorithm.\ncollection_rate::Int64, the rate that history is gathered. (Note: The last value is   always recorded.)\nstopping_criterion::Function, function that evaluates the stopping criterion.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#RLinearAlgebra.BasicLoggerRecipe","page":"Loggers","title":"RLinearAlgebra.BasicLoggerRecipe","text":"BasicLoggerRecipe <: LoggerRecipe\n\nThis is a mutable struct that contains the max_it parameter and stores the error metric      in a vector. Checks convergence of the solver based on the log information.\n\nFields\n\nmax_it::Int64, The maximum number of iterations for the solver.\nerror::Float64, The current error metric.\nthreshold_info::Union{Float64, Tuple}, The parameters used for stopping the algorithm.\niteration::Int64, the current iteration of the solver.\nrecord_location::Int64, the location in the history vector of the most recent entry.\ncollection_rate::Int64, the rate that history is gathered. (Note: The last value is   always recorded.)\nconverged::Bool, A boolean indicating whether the stopping criterion is satisfied.\nStoppingCriterion::Function, function that evaluates the stopping criterion.\nhist:AbstractVector, vector that contains the history of the error metric.\n\n\n\n\n\n","category":"type"},{"location":"api/loggers/#Exported-Functions","page":"Loggers","title":"Exported Functions","text":"","category":"section"},{"location":"api/loggers/#RLinearAlgebra.complete_logger","page":"Loggers","title":"RLinearAlgebra.complete_logger","text":"complete_logger(logger::Logger)\n\nA function that generates a LoggerRecipe given the      arguments.\n\nArguments\n\nlogger::Logger, a user-specified logging method.\n\nReturns\n\nA LoggerRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.update_logger!","page":"Loggers","title":"RLinearAlgebra.update_logger!","text":"update_logger!(logger::LoggerRecipe, err::Float64, iteration::Int64)\n\nA function that updates the LoggerRecipe in place given      arguments.\n\nArguments\n\nlogger::LoggerRecipe, a fully initialized realization for a    logging method for a specific linear or least squares solver.\nerr::Real, an error value to be logged. \niteration::Int64, the iteration of the solver. \n\nReturns\n\nPerforms an inplace update to the LoggerRecipe and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.reset_logger!","page":"Loggers","title":"RLinearAlgebra.reset_logger!","text":"reset_logger!(logger::LoggerRecipe)\n\nA function that resets the LoggerRecipe in place.\n\nArguments\n\nlogger::LoggerRecipe, a fully initialized realization for a    logging method for a specific linear or least squares solver.\n\nReturns\n\nPerforms an inplace update to the LoggerRecipe and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/loggers/#RLinearAlgebra.threshold_stop","page":"Loggers","title":"RLinearAlgebra.threshold_stop","text":"threshold_stop(log::BasicLoggerRecipe)\n\nFunction that takes an input threshold and stops when the most recent entry in the history vector is less than the threshold.\n\nArguments\n\nlog::LoggerRecipe, a structure containing the logger information\n\nBool\n\nReturns a Bool indicating if the stopping threshold is satisfied.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#Distributions","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"api/distributions/","page":"Distributions","title":"Distributions","text":"Pages = [\"distributions.md\"]","category":"page"},{"location":"api/distributions/#Abstract-Types","page":"Distributions","title":"Abstract Types","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.Distribution","page":"Distributions","title":"RLinearAlgebra.Distribution","text":"Distribution\n\nAn abstract supertype for structures specifying distribution for indices in sampling methods.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#RLinearAlgebra.DistributionRecipe","page":"Distributions","title":"RLinearAlgebra.DistributionRecipe","text":"DistributionRecipe\n\nAn abstract supertype for structures with pre-allocated memory for distribution function     sampling methods.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#Distribution-Structures","page":"Distributions","title":"Distribution Structures","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.Uniform","page":"Distributions","title":"RLinearAlgebra.Uniform","text":"Uniform <: Distribution\n\nUniform distribution over the row/column index set of a matrix.\n\nMathematical Description\n\nDuring the sampling, the uniform distribution is defined on the domain of row/column  indices. If it's compressing from the left, then it means every row index has the same  probability weight. If it's compressing from the right, then it means every column index  has the same probability weight.\n\nFields\n\ncardinality::Cardinality, the direction the compression matrix is intended to be   applied to a target matrix or operator. Values allowed are Left() or Right()    or Undef().\nreplace::Bool, if true, then the sampling occurs with replacement; if false,    then the sampling occurs without replacement.\n\nConstructor\n\nUniform(;cardinality=Undef(), replace = false)\n\nReturns\n\nA Uniform object.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#RLinearAlgebra.UniformRecipe","page":"Distributions","title":"RLinearAlgebra.UniformRecipe","text":"UniformRecipe <: DistributionRecipe\n\nThe recipe containing all allocations and information for the uniform distribution.\n\nFields\n\ncardinality::C where C<:Cardinality, the cardinality of the compressor. The   value is either Left() or Right() or Undef().\nreplace::Bool, an option to replace or not during the sampling process based    on the given weights.\nstate_space::Vector{Int64}, the row/column index set.\nweights::ProbabilityWeights, the weights of each element in the state space.\n\n\n\n\n\n","category":"type"},{"location":"api/distributions/#Exported-Functions","page":"Distributions","title":"Exported Functions","text":"","category":"section"},{"location":"api/distributions/#RLinearAlgebra.complete_distribution","page":"Distributions","title":"RLinearAlgebra.complete_distribution","text":"complete_distribution(distribution::Distribution, A::AbstractMatrix)\n\nA function that generates a DistributionRecipe given the      arguments.\n\nArguments\n\ndistribution::Distribution, a user-specified distribution function for sampling.\nA::AbstractMatrix, a coefficient matrix. \n\nOutputs\n\nA DistributionRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#RLinearAlgebra.update_distribution!","page":"Distributions","title":"RLinearAlgebra.update_distribution!","text":"update_distribution!(distribution::DistributionRecipe, A::AbstractMatrix)\n\nA function that updates the DistributionRecipe in place given      arguments.\n\nArguments\n\ndistribution::DistributionRecipe, a fully initialized realization of distribution.\nA::AbstractMatrix, a coefficient matrix. \n\nOutputs\n\nModifies the DistributionRecipe in place and returns nothing.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#RLinearAlgebra.sample_distribution!","page":"Distributions","title":"RLinearAlgebra.sample_distribution!","text":"sample_distribution!(x::AbstractVector, distribution::DistributionRecipe)\n\nA function that in place updates the x by given DistributionRecipe info.\n\nArguments\n\nx::AbstractVector, an abstract vector to store the sampled indices. \ndistribution::DistributionRecipe, a fully initialized realization of distribution.\n\nOutputs\n\nModifies the x in place by sampling that follows the weights and replacement given by \n\n'DistributionRecipe'.\n\n\n\n\n\n","category":"function"},{"location":"api/distributions/#Internal-Functions","page":"Distributions","title":"Internal Functions","text":"","category":"section"},{"location":"api/approximators/#Approximators","page":"Approximators Overview","title":"Approximators","text":"","category":"section"},{"location":"api/approximators/","page":"Approximators Overview","title":"Approximators Overview","text":"Pages = [\"approximators.md\"]","category":"page"},{"location":"api/approximators/#Abstract-Types","page":"Approximators Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.Approximator","page":"Approximators Overview","title":"RLinearAlgebra.Approximator","text":"Approximator\n\nAn abstract supertype for structures that store user-controlled parameters corresponding to techniques that form low-rank approximations of the matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.ApproximatorRecipe","page":"Approximators Overview","title":"RLinearAlgebra.ApproximatorRecipe","text":"ApproximatorRecipe\n\nAn abstract supertype for structures that store user-controlled parameters, linear system dependent parameters and preallocated memory corresponding to techniques that form low-rank approximations of the matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.ApproximatorAdjoint","page":"Approximators Overview","title":"RLinearAlgebra.ApproximatorAdjoint","text":"ApproximatorAdjoint{S<:ApproximatorRecipe} <: ApproximatorRecipe\n\nA structure for the adjoint of an ApproximatorRecipe.\n\nFields\n\nParent::ApproximatorRecipe, the approximator that we compute the adjoint of.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeApproximator","page":"Approximators Overview","title":"RLinearAlgebra.RangeApproximator","text":"RangeApproximator\n\nAn abstract type for the structures that contain the user-controlled parameters  corresponding to the Approximator methods that produce an orthogonal approximation to the  range of a matrix A. This includes methods like the RandomizedSVD and  randomized rangefinder.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeApproximatorRecipe","page":"Approximators Overview","title":"RLinearAlgebra.RangeApproximatorRecipe","text":"RangeApproximatorRecipe\n\nAn abstract type for the structures that contain the user-controlled parameters,  linear system information, and preallocated memory for methods corresponding to the Approximator methods that produce an orthogonal approximation to the range of a matrix A. This includes methods like the RandomizedSVD and  randomized rangefinder.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#Approximator-Structures","page":"Approximators Overview","title":"Approximator Structures","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.RandSVD","page":"Approximators Overview","title":"RLinearAlgebra.RandSVD","text":"RandSVD\n\nA struct that implements the Randomized SVD. The Randomized SVD technique compresses a      matrix from the right to compute a rank k estimate to the truncated      SVD of a matrix A. See Algorithm 5.1 in [9] for additional      details.\n\nMathematical Description\n\nSuppose we have a matrix A in mathbbR^m times n for which we wish to form a      low-rank approximation with the form of an SVD. Specifically, we wish to find an      orthogonal matrix, U, a diagonal matrix, Sigma, and an orthogonal matrix,      V such that USigma V^top approx A. This can be done effectively using the      Randomized SVD presented in Algorithm 5.1 of [9].      This algorithm progresses by first having the user select a k  2 to be the      compression_dim of the compressor, which will also correspond to the desired      rank of the approximation. With this k, RandomizedSVD  generates a compression      matrix SinmathbbR^n times k and computes Q = textqr(AS) as in the      RangeFinder. With the Q, the RandomizedSVD      concludes by computing WSigmaV = textSVD(Q^top A) and  setting U = QW.     With high probability the approximation generated by the RandomizedSVD will satisfy      mathbbE A - U Sigma V^top _F leq sqrtk+1       (sum_i=k+1^min(mn)sigma_i)^12     , where sigma_k+1 is the k+1^textth singular value of (see Theorem 10.5      of [9]). This bound is often conservative as long as the singular      values of A decay quickly.\n\nWhen the singular values decay slowly, we can improve the quality of the approximation using the      power iteration, which applies A and A^top, q times      and take the qr factorization of (AA^top)^q AS. Using these power iterations      increases the relative gap between the singular values leading to  better RandomizedSVD      performance. \n\nPerforming power iterations in floating points can destroy all information      related to the smallest singular values of A      (see Remark 4.3 in [9]). We can preserve this information by      orthogonalizing inbetween the products of AS with A or A^top      in the power iteration. These steps are known as the orthogonalized power      iteration (see Algorithm 4.4 of [9]).       Orthogonalized power iterations progress according to the following steps:\n\ntildeA_1 = AS  \nQ_1R_1 = textbfqr(tildeA_1)  \ntildeA_2 = A^top Q_1  \nQ_2R_2 = textbfqr(tildeA_2)  \ntildeA_1 = A Q_2  \nQ_1 R_1 = textbfqr(tildeA_1)  \nRepeat Steps 3 through 6 for the desired number of power iterations  set Q = Q_1.  \n\nFields\n\ncompressor::Compressor, the technique for compressing the matrix from the right.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.    \nblock_size::Int64, the size of the tile when performing matrix multiplication. By    default, block_size = 0, this will be set to be the number of columns in    the original matrix, A.\n\nConstructor\n\nRandSVD(;\n    compressor::Compressor = SparseSign(cardinality = Right()), \n    orthogonalize::Bool  = false, \n    power_its::Int64 = 0,\n    block_size::Int64 = 0,\n)\n\nKeywords\n\ncompressor::Compressor, the technique for compressing the matrix from the right. By    default this is SparseSign with a cardinality Right().\npower_its::Int64, the number of power iterations that should be performed. By default    this is zero.\northogonalize::Bool, a boolean indicating whether the power_its should be performed   with orthogonalization. By default is false. \nblock_size::Int64, the size of the tile when performing matrix multiplication. By    default, block_size = 0, this will be set to be the number of columns in    the original matrix, A. By default this is zero.\n\nReturns\n\nA RandSVD object.\n\nThrows\n\nArgumentError if power_its or block_size are negative.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RandSVDRecipe","page":"Approximators Overview","title":"RLinearAlgebra.RandSVDRecipe","text":"RandSVDRecipe\n\nA struct that contains the preallocated memory and completed compressor to form a     RandSVD approximation to the matrix A.\n\nFields\n\nn_rows::Int64, the number of rows in the approximation. \nn_cols::Int64, the number of columns in the approximation. \ncompressor::CompressorRecipe, the compressor to be applied from the right to A.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\nU::AbstractArray, the orthogonal matrix that approximates the top compressor_dim    left singular vectors of A.\nS::AbstractVector, a vector containing the top compressor_dim singular values of    A.\nV::AbstractArray, the orthogonal matrix that approximates the top compressor_dim    right singular vectors of A.\nbuffer::AbstractArray, the storage for matrix multiplication with this low-rank    approximation. Will have the compression_dim number of rows and block_size   number of columns.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeFinder","page":"Approximators Overview","title":"RLinearAlgebra.RangeFinder","text":"RangeFinder\n\nA struct that implements the Randomized Range Finder technique which uses compression from      the right to form an low-dimensional orthogonal matrix Q that approximates the      range of A. See [9] for additional details.\n\nMathematical Description\n\nSuppose we have a matrix A in mathbbR^m times n of which we wish to form a low      rank approximation that approximately captures the range of A. Specifically, we wish     to find an Orthogonal matrix Q such that QQ^top A approx A. \n\nA simple way to find such a matrix is to choose a k representing the number of      vectors we wish to have in the subspace. Then we can generate a compression matrix      SinmathbbR^n times k and compute Q = textqr(AS).      With high probability we will have A - QQ^top A_2 leq     sqrtk+1 (sum_i=k+1^min(mn)sigma_i)^12,      where sigma_k+1 is the k+1^textth singular value      of A (see Theorem 10.5 of [9]). This bound is often conservative      as long as the singular values of A decay quickly.  \n\nWhen the singular values decay slowly, we can improve the quality of the approximation using the      power iteration, which applies A and A^top, q times      and take the qr factorization of (AA^top)^q AS. Using these power iterations increases the      relative gap between the singular values leading to  better Rangefinder performance. \n\nPerforming power iterations in floating points can destroy all information      related to the smallest singular values of A      (see Remark 4.3 in [9]). We can preserve this information by      orthogonalizing inbetween the products of AS with A or A^top      in the power iteration. These steps are known as the orthogonalized power      iteration (see Algorithm 4.4 of [9]).       Orthogonalized power iterations progress according to the following steps:\n\ntildeA_1 = AS  \nQ_1R_1 = textbfqr(tildeA_1)  \ntildeA_2 = A^top Q_1  \nQ_2R_2 = textbfqr(tildeA_2)  \ntildeA_1 = A Q_2  \nQ_1 R_1 = textbfqr(tildeA_1)  \nRepeat Steps 3 through 6 for the desired number of power iterations  set Q = Q_1. \n\nFields\n\ncompressor::Compressor, the technique that will compress the matrix from the right.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\n\nConstructor\n\nRangeFinder(;\n    compressor = SparseSign(), \n    orthogonalize = false, \n    power_its = 0\n)\n\nKeywords\n\ncompressor::Compressor, the technique that will compress the matrix from the right.\npower_its::Int64, the number of power iterations that should be performed. Default is   zero.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization. Default is false.\n\nReturns\n\nA RangeFinder object.\n\nThrows\n\nArgumentError if power_its is negative.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#RLinearAlgebra.RangeFinderRecipe","page":"Approximators Overview","title":"RLinearAlgebra.RangeFinderRecipe","text":"RangeFinderRecipe\n\nA struct that contains the preallocated memory and completed compressor to form a     RangeFinder approximation to the matrix A.\n\nFields\n\ncompressor::CompressorRecipe, the compressor to be applied from the right to A.\npower_its::Int64, the number of power iterations that should be performed.\northogonalize::Bool, a boolean indicating whether the power_its should be performed    with orthogonalization.\nrange::AbstractMatrix, the orthogonal matrix that approximates the range of A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximators/#Exported-Functions","page":"Approximators Overview","title":"Exported Functions","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.complete_approximator","page":"Approximators Overview","title":"RLinearAlgebra.complete_approximator","text":"complete_approximator(approximator::Approximator, A::AbstractMatrix)\n\nA function that generates an ApproximatorRecipe given      arguments.\n\nArguments\n\napproximator::Approximator, a data structure containing the   user-defined parameters associated with a particular low-rank approximation.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rapproximate","page":"Approximators Overview","title":"RLinearAlgebra.rapproximate","text":"rapproximate(approximator::Approximator, A::AbstractMatrix)\n\nA function that computes a low-rank approximation of the matrix A     using the information in the provided Approximator data structure.\n\nArguments\n\napproximator::Approximator, a data structure containing the   user-defined parameters associated with a particular low-rank approximation.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rapproximate!","page":"Approximators Overview","title":"RLinearAlgebra.rapproximate!","text":"rapproximate!(approximator::ApproximatorRecipe, A::AbstractMatrix)\n\nA function that computes a low-rank approximation of the matrix A     using the information in the provided Approximator data structure.\n\nArguments\n\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#Internal-Functions","page":"Approximators Overview","title":"Internal Functions","text":"","category":"section"},{"location":"api/approximators/#RLinearAlgebra.rand_power_it","page":"Approximators Overview","title":"RLinearAlgebra.rand_power_it","text":"rand_power_it(approx::RangeFinderRecipe, A::AbstractMatrix)\n\nFunction that performs the randomized rangefinder procedure presented in Algortihm 4.3 of  [9].\n\nArguments\n\napprox::RangeFinderRecipe, a RangeFinderRecipe structure that contains the compressor\n\nrecipe.\n\nA::AbstractMatrix, the matrix being approximated.\n\nReturns\n\nQ::AbstractMatrix, an economical Q approximating the range of A.\n\n\n\n\n\n","category":"function"},{"location":"api/approximators/#RLinearAlgebra.rand_ortho_it","page":"Approximators Overview","title":"RLinearAlgebra.rand_ortho_it","text":"rand_ortho_it(approx::RangeFinderRecipe, A::AbstractMatrix)\n\nFunction that performs the randomized rangefinder procedure presented in Algortihm 4.4 of  [9].\n\nArguments\n\napprox::RangeFinderRecipe, a RangeFinderRecipe structure that contains the compressor\n\nrecipe.\n\nA::AbstractMatrix, the matrix being approximated.\n\nReturns\n\nQ::AbstractMatrix, an economical Q approximating the range of A.\n\n\n\n\n\n","category":"function"},{"location":"api/solver_errors/#SolverErrors","page":"SolverErrors","title":"SolverErrors","text":"","category":"section"},{"location":"api/solver_errors/","page":"SolverErrors","title":"SolverErrors","text":"Pages = [\"solver_errors.md\"]","category":"page"},{"location":"api/solver_errors/#Abstract-Types","page":"SolverErrors","title":"Abstract Types","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.SolverError","page":"SolverErrors","title":"RLinearAlgebra.SolverError","text":"SolverError\n\nAn abstract supertype for structures that track and/or evaluate the quality of a solution for a linear system or least squares.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#RLinearAlgebra.SolverErrorRecipe","page":"SolverErrors","title":"RLinearAlgebra.SolverErrorRecipe","text":"SolverErrorRecipe\n\nAn abstract supertype for structures that contain the user-controlled parameters, linear system dependent parameters, and preallocated memory for techniques that evaluate the solution to a linear solver.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#SolverError-Structures","page":"SolverErrors","title":"SolverError Structures","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.FullResidual","page":"SolverErrors","title":"RLinearAlgebra.FullResidual","text":"FullResidual <: SolverError\n\nA SolverError structure for computing the norm of the full residual, b-Ax.\n\nFields\n\nNone\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#RLinearAlgebra.FullResidualRecipe","page":"SolverErrors","title":"RLinearAlgebra.FullResidualRecipe","text":"FullResidual <: SolverErrorRecipe\n\nA SolverErrorResidual structure for computing the norm of the full residual, b-Ax\n\nFields\n\nresidual::AbstractVector, a container for the residual b-Ax.\n\n\n\n\n\n","category":"type"},{"location":"api/solver_errors/#Exported-Functions","page":"SolverErrors","title":"Exported Functions","text":"","category":"section"},{"location":"api/solver_errors/#RLinearAlgebra.complete_error","page":"SolverErrors","title":"RLinearAlgebra.complete_error","text":"complete_error(\n    error::SolverError, \n    solver::Solver,\n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that generates a SolverErrorRecipe given the      arguments.\n\nArguments\n\nerror::SolverError, a user-specified solver error method.\nsolver::Solver, a user-specified solver method.\nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nReturns\n\nA SolverErrorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solver_errors/#RLinearAlgebra.compute_error","page":"SolverErrors","title":"RLinearAlgebra.compute_error","text":"compute_error(\n    error::SolverErrorRecipe, \n    solver::SolverRecipe, \n    x::AbstractVector,\n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that evaluates the error for a proposed solution      vector.\n\nArguments\n\nerror::SolverErrorRecipe, a fully initialized realization for   a solver error method for a specific linear system or least squares problem.\nsolver::SolverRecipe, a fully initialized realization for a    solver method for a specific linear system.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nReturns\n\nReturns nothing\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#Solvers","page":"Solvers Overview","title":"Solvers","text":"","category":"section"},{"location":"api/solvers/","page":"Solvers Overview","title":"Solvers Overview","text":"Pages = [\"solvers.md\"]","category":"page"},{"location":"api/solvers/#Abstract-Types","page":"Solvers Overview","title":"Abstract Types","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.Solver","page":"Solvers Overview","title":"RLinearAlgebra.Solver","text":"Solver\n\nAn abstract supertype for structures that contain the user-controlled parameters for methods that solve linear systems and least squares problems.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#RLinearAlgebra.SolverRecipe","page":"Solvers Overview","title":"RLinearAlgebra.SolverRecipe","text":"SolverRecipe\n\nAn abstract supertype specifying a solver method with pre-allocated data structures given a coefficient matrix and constant vector.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#Solver-Structures","page":"Solvers Overview","title":"Solver Structures","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.Kaczmarz","page":"Solvers Overview","title":"RLinearAlgebra.Kaczmarz","text":"Kaczmarz <: Solver\n\nAn implementation of a Kaczmarz solver. Specifically, it is a solver that iteratively     updates an iterate by projecting the iterate onto (a subspace of) the row space of a     consistent linear system.\n\nMathematical Description\n\nLet A be an m times n matrix and consider the consistent linear system Ax=b.      We can view the solution to this linear system as lying at the intersection of the      row hyperplanes,      cap_i in 1 ldots mu in mathbbR^n  A_i cdot u = b_i     ,     where A_i cdot represents the i^textth row of A. One way to find      this interesection is to iteratively project some abritrary point, x from one      hyperplane to the next, through      x_+ = x + alpha fracb_i - lange A_icdot xrangle A_icdot     Doing this with random permutation of i can lead to a geometric convergence      [5].     Here alpha is viewed as an over-relaxation parameter and can improve convergence.      One can also generalize this procedure to blocks by considering the S being a      s times n random matrix. If we let tilde A = S A and tilde b = Sb      then we can perform block kaczmarz as described by [6] with      x_+ = x + alpha tilde A^top (tilde A tilde A^top)^dagger      (tilde b - tilde A x)     While, S is often random, in reality, whether S is deterministic or random is      quite flexible see [7] for more details.\n\nFields\n\nalpha::Float64, the over-relaxation parameter. It is multiplied by the update and can    affect convergence.\ncompressor::Compressor, a technique for forming the compressed rowspace of the linear    system.\nlog::Logger, a technique for logging the progress of the solver.\nerror::SolverError, a method for estimating the progress of the solver.\nsub_solver::SubSolver, a technique to perform the projection of the solution onto the    compressed rowspace.\n\nConstructor\n\nKaczmarz(;\n    compressor::Compressor = SparseSign(), \n    log::Logger = BasicLogger(),\n    error::SolverError = FullResidual(),\n    sub_solver::SubSolver = LQSolver(),\n    alpha::Float64 = 1.0\n)\n\nKeywords\n\ncompressor::Compressor, a technique for forming the compressed rowspace of the    linear system.\nlog::Logger, a technique for logging the progress of the solver.\nerror::SolverError, a method for estimating the progress of the solver.\nsub_solver::SubSolver, a technique to perform the projection of the solution onto the    compressed rowspace. When the compression_dim = 1 this is not used.\nalpha::Float64, the over-relaxation parameter. It is multiplied by the update and can    affect convergence. By default this value is 1.\n\nReturns\n\nA Kaczmarz object.\n\ninfo: Info\nThe alpha parameter should be in (02)  for convergence to be guaranteed. This  condition is not enforced in the constructor. There are some instances where setting  alpha = 2 can lead to non-convergent cycles [8].\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#RLinearAlgebra.KaczmarzRecipe","page":"Solvers Overview","title":"RLinearAlgebra.KaczmarzRecipe","text":"KaczmarzRecipe{\n    T<:Number, \n    V<:AbstractVector,\n    M<:AbstractMatrix, \n    VV<:SubArray,\n    MV<:SubArray,\n    C<:CompressorRecipe, \n    L<:LoggerRecipe,\n    E<:SolverErrorRecipe, \n    B<:SubSolverRecipe\n} <: SolverRecipe\n\nA mutable structure containing all information relevant to the Kaczmarz solver. It is     formed by calling the function complete_solver on Kaczmarz solver, which includes     all the user controlled parameters, and the linear system matrix A and constant      vector b.\n\nFields\n\ncompressor::CompressorRecipe, a technique for forming the compressed rowspace of the    linear system.\nlog::LoggerRecipe, a technique for logging the progress of the solver.\nerror::SolverErrorRecipe, a method for estimating the progress of the solver.\nsub_solver::SubSolverRecipe, a technique to perform the projection of the solution onto   the compressed rowspace.\nalpha::Float64, the over-relaxation parameter. It is multiplied by the update and can    affect convergence.\ncompressed_mat::AbstractMatrix, a matrix container for storing the compressed matrix.    Will be set to be the largest possible block size.\ncompressed_vec::AbstractVector, a vector container for storing the compressed constant   vector. Will be set to be the largest possible block size.\nsolution_vec::AbstractVector, a vector container for storing the solution to the linear   system.\nupdate_vec::AbstractVector, a vector container for storing the update to the linear    system.\nmat_view::SubArray, a container for storing a view of compressed matrix container.    Using views here allows for variable block sizes.\nvec_view::SubArray, a container for storing a view of the compressed vector container.   Using views here allows for variable block sizes.\n\n\n\n\n\n","category":"type"},{"location":"api/solvers/#Exported-Functions","page":"Solvers Overview","title":"Exported Functions","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.complete_solver","page":"Solvers Overview","title":"RLinearAlgebra.complete_solver","text":"complete_solver(solver::Solver, x::AbstractVector, A::AbstractMatrix, b::AbstractVector)\n\nA function that generates a SolverRecipe given the      arguments.\n\nArguments\n\nsolver::Solver, a user-specified solver method.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nA SolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.rsolve!","page":"Solvers Overview","title":"RLinearAlgebra.rsolve!","text":"rsolve!(\n    solver::SolverRecipe, \n    x::AbstractVector, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that solves a linear system given the arguments.\n\nArguments\n\nsolver::SolverRecipe, a fully initialized realization for a    solver method for a specific linear system.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nReturns nothing. Updates the SolverRecipe and x in place.\n\n\n\n\n\nrsolve!(\n    solver::Solver, \n    x::AbstractVector, \n    A::AbstractMatrix, \n    b::AbstractVector\n)\n\nA function that solves a linear system given the arguments.\n\nArguments\n\nsolver::Solver, a user-specified solver method.\nx::AbstractVector, a vector for the proposed solution. \nA::AbstractMatrix, a coefficient matrix. \nb::AbstractVector, a constant vector. \n\nOutputs\n\nx::AbstractVector, a proposed solution to a linear system or least squares    problem.\nA SolverRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#Internal-Functions","page":"Solvers Overview","title":"Internal Functions","text":"","category":"section"},{"location":"api/solvers/#RLinearAlgebra.kaczmarz_update!","page":"Solvers Overview","title":"RLinearAlgebra.kaczmarz_update!","text":"kaczmarz_update!(solver::KaczmarzRecipe)\n\nA function that performs the Kaczmarz update when the compression dimension is one.      If a is the resulting compression of the coefficient matrix,      and c is the resulting compression of the constant vector,      then we perform the update: x = x - alpha (a^top x -c)  a_2^2. \n\nArguments\n\nsolver::KaczmarzRecipe, the solver information required for performing the update.\n\nOutputs\n\nreturns nothing\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.kaczmarz_update_block!","page":"Solvers Overview","title":"RLinearAlgebra.kaczmarz_update_block!","text":"kaczmarz_update_block!(solver::KaczmarzRecipe)\n\nA function that performs the kaczmarz update when the compression dim is greater than 1.       In the block case where the compressed matrix tilde A, and the compressed      contant vector tilde b, we perform the updated:      x = x - alpha tilde A^top (tilde A tilde A^top)^dagger     (tilde Ax-tilde b).\n\nArguments\n\nsolver::KaczmarzRecipe, the solver information required for performing the update.\n\nOutputs\n\nreturns nothing\n\n\n\n\n\n","category":"function"},{"location":"api/solvers/#RLinearAlgebra.dotu","page":"Solvers Overview","title":"RLinearAlgebra.dotu","text":"dotu(a::AbstractArray, b::AbstractArray)\n\nA function that computes the non conjugate dot product between two vectors. It is equivalent     to calling dot(conj(a), b).\n\nArguments\n\na::AbstractArray, a vector being dot producted (is labeled as a array to allow for    views).\nb::AbstractArray, a vector being dot producted (is labeled as a array to allow for    views).\n\nReturns\n\nA scalar that is the non-conjugated dot product between two vectors.\n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#ApproximatorErrors","page":"ApproximatorErrors","title":"ApproximatorErrors","text":"","category":"section"},{"location":"api/approximator_errors/","page":"ApproximatorErrors","title":"ApproximatorErrors","text":"Pages = [\"approximator_errors.md\"]","category":"page"},{"location":"api/approximator_errors/#Abstract-Types","page":"ApproximatorErrors","title":"Abstract Types","text":"","category":"section"},{"location":"api/approximator_errors/#RLinearAlgebra.ApproximatorError","page":"ApproximatorErrors","title":"RLinearAlgebra.ApproximatorError","text":"ApproximatorError\n\nAn abstract supertype for structures containing user-controlled parameters corresponding to methods that evaluate the quality of a low-rank approximation of a matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximator_errors/#RLinearAlgebra.ApproximatorErrorRecipe","page":"ApproximatorErrors","title":"RLinearAlgebra.ApproximatorErrorRecipe","text":"ApproximatorErrorRecipe\n\nAn abstract supertype for structures containing user-controlled parameters, matrix dependent parameters and preallocated memory corresponding to methods that evaluate the quality of a low-rank approximation of a matrix A.\n\n\n\n\n\n","category":"type"},{"location":"api/approximator_errors/#ApproximatorError-Structures","page":"ApproximatorErrors","title":"ApproximatorError Structures","text":"","category":"section"},{"location":"api/approximator_errors/#Exported-Functions","page":"ApproximatorErrors","title":"Exported Functions","text":"","category":"section"},{"location":"api/approximator_errors/#RLinearAlgebra.complete_approximator_error","page":"ApproximatorErrors","title":"RLinearAlgebra.complete_approximator_error","text":"complete_approximator_error(\n    error::ApproximatorError, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that generates an ApproximatorErrorRecipe     given the arguments.\n\nArguments\n\nerror::ApproximatorError, a data structure containing   the user-defined parameters associated with a particular low-rank approximation error   method.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nAn ApproximatorErrorRecipe object.\n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#RLinearAlgebra.compute_approximator_error","page":"ApproximatorErrors","title":"RLinearAlgebra.compute_approximator_error","text":"compute_approximator_error(\n    error::ApproximatorError, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that computes the approximation error of an     ApproximatorRecipe for a matrix A.\n\nArguments\n\nerror::ApproximatorError, a data structure containing   the user-defined parameters associated with a particular low-rank approximation error   method.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nReturns the error::Float64 \n\n\n\n\n\n","category":"function"},{"location":"api/approximator_errors/#RLinearAlgebra.compute_approximator_error!","page":"ApproximatorErrors","title":"RLinearAlgebra.compute_approximator_error!","text":"compute_approximator_error!(\n    error::ApproximatorErrorRecipe, \n    approximator::ApproximatorRecipe, \n    A::AbstractMatrix\n)\n\nA function that computes the approximation error of an     ApproximatorRecipe for a matrix A.\n\nArguments\n\nerror::ApproximatorErrorRecipe, a fully initialized   realization for a low rank approximation error method for a particular matrix.\napproximator::ApproximatorRecipe, a fully initialized   realization for a low rank approximation method for a particular matrix.\nA::AbstractMatrix, a target matrix for approximation. \n\nOutputs\n\nReturns the error::Float64 \n\n\n\n\n\n","category":"function"},{"location":"#RLinearAlgebra","page":"Home","title":"RLinearAlgebra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RLinearAlgebra is a Julia library for the  development and application of randomized algorithms to the problems of forming low rank  approximations to matrices and finding the solution of linear systems and least squares  problems.  Because of the large diversity of randomized techniques, rather than offering isolated  routine implementations of algorithms, this library implements a series of extendable data  structures and methods which allow code reuse.","category":"page"},{"location":"#Documentation-structure","page":"Home","title":"Documentation structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation serves both as a manual to the library and as an introduction to  randomized linear approximation techniques and randomized linear algebra solvers.  We divide it in four parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorial: examples of how to solve linear systems and least squares problems with   RLinearAlgebra and how to extend the library.\nManual: here we offer an introduction to solving linear systems with randomized linear    algebra techniques, compressing a matrix, and forming a low-rank approximation of a matrix.    We introduce theoretical foundations and we provide code examples with RLinearAlgebra.\nAPI: a detailed description of all the data structures and methods of the library.\nDevelopment: detailed instructions on how to contribute to the library.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is supported by the National Science Foundation Office of Advanced  Cyberinfrastructure under awards  2309445 and  2309446. This material is based upon work supported by the U.S. Department of Energy, Office of  Science, under contract number DE-AC02-06CH11357.","category":"page"},{"location":"api/contents/#Randomized-Linear-Solver-Reference","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"","category":"section"},{"location":"api/contents/","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"Pages=[\n  \"approximators.md\",  \n  \"approximator_errors.md\",\n  \"compressors.md\",\n  \"solvers.md\",\n  \"solver_error.md\",\n  \"sub_solvers.md\",\n  \"loggers.md\"]","category":"page"}]
}
