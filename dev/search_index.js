var documenterSearchIndex = {"docs":
[{"location":"api/linear_rsolve/#Randomized-Linear-Solver","page":"Randomized Linear Solvers","title":"Randomized Linear Solver","text":"","category":"section"},{"location":"api/linear_rsolve/","page":"Randomized Linear Solvers","title":"Randomized Linear Solvers","text":"Pages=[\"linear_rsolve.md\"]","category":"page"},{"location":"api/linear_rsolve/#Abstract-Types","page":"Randomized Linear Solvers","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_rsolve/","page":"Randomized Linear Solvers","title":"Randomized Linear Solvers","text":"RLSSolver","category":"page"},{"location":"api/linear_rsolve/#RLinearAlgebra.RLSSolver","page":"Randomized Linear Solvers","title":"RLinearAlgebra.RLSSolver","text":"RLSSolver{S<:LinSysSampler, R<:LinSysSolveRoutine,\n    L<:LinSysSolverLog, C<:LinSysStopCriterion}\n\nAn encapsulation for a (R)andomized (L)inear (S)ysterm Solver as a mutable structure.\n\nFields\n\nsampler::S, a procedure for sampling, sketching or selecting with respect to a linear   system.\nroutine::R, a routine for randomly generating the subproblem generated by the sampling,   sketching or selecting operation\nlog::L, a logger for the progress and behavior of the randomized linear system solver.\nstop::C, a stopping criterion for the randomized linear system solver.\nx::Union{Vector{Float64},Nothing}, the result produced by the randomized linear system   solver.\n\nConstructions\n\nRLSSolver(iter::Int64) specifies a solver with: random cyclic row sampling;  partially   orthogonalized row projections (memory of five) subproblem solver; a full residual   logger; and a maximum iteration stopping criterion specified by iter.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_rsolve/#Solver-Functions","page":"Randomized Linear Solvers","title":"Solver Functions","text":"","category":"section"},{"location":"api/linear_rsolve/","page":"Randomized Linear Solvers","title":"Randomized Linear Solvers","text":"rsolve\n\nrsolve!","category":"page"},{"location":"api/linear_rsolve/#RLinearAlgebra.rsolve","page":"Randomized Linear Solvers","title":"RLinearAlgebra.rsolve","text":"rsolve([solver::RLSSolver,] A, b)\n\nDeploys an iterative randomized solver for the linear system whose coefficient matrix is     encapsulated in A and whose constant vector is encapsulated in b. If the solver     is not specified, then the default RLSSolver is constructed and used with a maximum     number of iterations of 10 * length(b). See RLSSolver for more details on the     default solver.\n\nThe function returns the solution.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_rsolve/#RLinearAlgebra.rsolve!","page":"Randomized Linear Solvers","title":"RLinearAlgebra.rsolve!","text":"rsolve!([solver::RLSSolver,] A, b, x::AbstractVector)\n\nIdentical to rsolve except an initial iterate is supplied by the argument x. The     function overwrites the solution into the vector x.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_solver_routines/#Linear-Subsolvers","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"Pages=[\"linear_solver_routines.md\"]","category":"page"},{"location":"api/linear_solver_routines/#Abstract-Types","page":"Linear Subsolvers","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"LinSysSolveRoutine\n\nLinSysVecRowProjection\n\nLinSysVecColProjection\n\nLinSysBlkRowProjection\n\nLinSysBlkColProjection\n\nLinSysPreconKrylov","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysSolveRoutine","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysSolveRoutine","text":"LinSysSolveRoutine\n\nAbstract supertype that specifies the type of linear system solver routine being deployed.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjection","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecRowProjection","text":"LinSysVecRowProjection <: LinSysSolveRoutine\n\nAbstract supertype for vector row action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjection","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecColProjection","text":"LinSysVecColProjection <: LinSysSolveRoutine\n\nAbstract supertype for vector column action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysBlkRowProjection","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysBlkRowProjection","text":"LinSysBlkRowProjection <: LinSysSolveRoutine\n\nAbstract supertype for block row action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysBlkColProjection","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysBlkColProjection","text":"LinSysBlkColProjection <: LinSysSolveRoutine\n\nAbstract supertype for block column action projection methods.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysPreconKrylov","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysPreconKrylov","text":"LinSysPreconKrylov <: LinSysSolveRoutine\n\nAbstract supertype for preconditioned Krylov solver.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Vector-Row-Solvers","page":"Linear Subsolvers","title":"Vector Row Solvers","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"LinSysVecRowProjStd\n\nLinSysVecRowProjPO\n\nLinSysVecRowProjFO","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjStd","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecRowProjStd","text":"LinSysVecRowProjStd <: LinSysVecRowProjection\n\nA mutable structure that represents a standard row projection method.\n\nAliases\n\nKaczmarz, see Kaczmarz, M. S. \"Approximate solution of systems of linear equations.\"   (1937). Original article is in German.\nART, see Gordon, Richard, Robert Bender, and Gabor T. Herman. \"Algebraic reconstruction   techniques (ART) for three-dimensional electron microscopy and X-ray photography.\"   Journal of theoretical Biology 29.3 (1970): 471-481.\n\nFields\n\nalpha::Float64, a relaxation parameter that should be set between 0.0 and 2.0\n\nCalling LinSysVecRowProjStd() defaults the relaxation parameter to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjPO","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecRowProjPO","text":"LinSysVecRowProjPO <: LinSysVecRowProjection\n\nA mutable structure that represents the standard row projection method     with orthogonalization of the current projection against a set of m previous     projection directions, where m is specified by the user.\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nα::Float64, the relaxation parameter (usually between 0.0 and 2.0)\nm::Int64, the number of previous directions against which to orthogonalize\nZ::Union{Vector{Vector{Float64}}, Nothing}, stores the m vectors against which the   current projection is orthogonalized against\n\nCalling LinSysVecRowProjPO() defaults the relaxation parameter to 1.0, the memory     parameter m to 5, and Z to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecRowProjFO","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecRowProjFO","text":"LinSysVecRowProjFO <: LinSysVecRowProjection\n\nA mutable structure that represents the standard row projection method with full orthogonalization against all previous projections. Equivalently, this type represents a solver for incrementally constructed matrix sketches.\n\nSee McCormick, S. F. \"The methods of Kaczmarz and row orthogonalization for solving linear     equations and least squares problems in Hilbert space.\" Indiana University Mathematics     Journal 26.6 (1977): 1137-1150. https://www.jstor.org/stable/24891603\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nS::Union{Matrix{Float64}, Nothing} is a matrix used for orthogonalizing against   all previous search directions.\n\nCalling LinSysVecRowProjFO() defaults to LinSysVecRowProjFO(nothing).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Vector-Column-Solvers","page":"Linear Subsolvers","title":"Vector Column Solvers","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"LinSysVecColProjStd\n\nLinSysVecColProjPO\n\nLinSysVecColProjFO","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjStd","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecColProjStd","text":"LinSysVecColProjStd <: LinSysVecColProjection\n\nA mutable structure that represents a standard column projection method.\n\nSee Luo, Zhi-Quan, and Paul Tseng. \"On the convergence of the coordinate descent method     for convex differentiable minimization.\" Journal of Optimization Theory and     Applications 72.1 (1992): 7-35.\n\nFor a generalization, see Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado.     \"An Implicit Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nAliases\n\nCoordinateDescent\nGaussSeidel\n\nFields\n\nalpha::Float64, a relaxation parameter that should be set between 0.0 and 2.0\n\nCalling LinSysVecColProjStd() defaults the relaxatoin parameter to 1.0.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjPO","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecColProjPO","text":"LinSysVecColProjPO <: LinSysVecColProjection\n\nA mutable structure that represents the standard column projection method     with orthogonalization of the current projection against a set of m previous     projection directions, where m is specified by the user.\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nα::Float64, the relaxation parameter (usually between 0.0 and 2.0)\nm::Int64, the number of previous directions against which to orthogonalize\nZ::Union{Vector{Vector{Float64}}, Nothing}, stores the m vectors against which the   current projection is orthogonalized against\n\nCalling LinSysVecColProjPO() defaults the relaxation parameter to 1.0, the memory     parameter m to 5, and Z to nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#RLinearAlgebra.LinSysVecColProjFO","page":"Linear Subsolvers","title":"RLinearAlgebra.LinSysVecColProjFO","text":"LinSysVecColProjFO <: LinSysVecColProjection\n\nA mutable structure that represents the standard column projection method with full orthogonalization against all previous projections.\n\nSee Patel, Vivak, Mohammad Jahangoshahi, and Daniel Adrian Maldonado. \"An Implicit     Representation and Iterative Solution of Randomly Sketched Linear Systems.\"     SIAM Journal on Matrix Analysis and Applications (2021) 42:2, 800-831.     https://doi.org/10.1137/19M1259481\n\nFields\n\nS::Union{Matrix{Float64}, Nothing} is a matrix used for orthogonalizing against   all previous search directions.\n\nCalling LinSysVecColProjFO() defaults to LinSysVecColProjFO(nothing).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_routines/#Subsolver-Function","page":"Linear Subsolvers","title":"Subsolver Function","text":"","category":"section"},{"location":"api/linear_solver_routines/","page":"Linear Subsolvers","title":"Linear Subsolvers","text":"RLinearAlgebra.rsubsolve!(::Nothing,::AbstractVector,::Tuple,::Int64)","category":"page"},{"location":"api/linear_solver_routines/#RLinearAlgebra.rsubsolve!-Tuple{Nothing, AbstractVector{T} where T, Tuple, Int64}","page":"Linear Subsolvers","title":"RLinearAlgebra.rsubsolve!","text":"rsubsolve!(\n    type::LinSysSolveRoutine,\n    x::AbstractVector,\n    samp::Tuple,\n    iter::Int64)\n\nA common interface for specifying different strategies for solving a subproblem generated     by a sampling, selecting or sketching operation on a linear system. The type argument     is used to select the appropriately defined strategy. The argument x is the current     iterate value for the solution. The argument samp depends on the subtype     of LinSysSolveRoutine that is being deployed and is described below. The iter     argument is the iteration counter.\n\nThe value of samp depends on the type of subtype of LinSysSolveRoutine being deployed. To describe this, let A be the coefficient matrix of the system, and b its constant vector.\n\nFor T<:LinSysVecRowProjection, samp is a two-dimensional tuple where the first   entry is a vector in the row space of A; and the second entry is a scalar value   corresponding to a linear combination of the elements of b.\nFor T<:LinSysVecColProjection, samp is a three-dimensional tuple where the first   entry is a vector of length(x) corresponding to the search direction; the second   entry is a matrix with the same number of rows as A (usually it is A);   and the third entry is a scalar-valued residual for the normal system corresponding   to samp[1]'* A' * (A * x - b).\n\nThe function rsubsolve! updates the quantity x and any fields of type that must be     updated.\n\n\n\n\n\n","category":"method"},{"location":"api/linear_solver_stops/#Linear-Solver-Stop-Criteria","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"Pages=[\"linear_solver_stops.md\"]","category":"page"},{"location":"api/linear_solver_stops/#Abstract-Types","page":"Linear Solver Stop Criteria","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"LinSysStopCriterion","category":"page"},{"location":"api/linear_solver_stops/#RLinearAlgebra.LinSysStopCriterion","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.LinSysStopCriterion","text":"LinSysStopCriterion\n\nAbstract supertype for specifying stopping criteria for randomized linear solver.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_stops/#Stopping-Criteria","page":"Linear Solver Stop Criteria","title":"Stopping Criteria","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"LSStopMaxIterations\nLSStopThreshold\nLSStopMA","category":"page"},{"location":"api/linear_solver_stops/#RLinearAlgebra.LSStopMaxIterations","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.LSStopMaxIterations","text":"LSStopMaxIterations <: LinSysStopCriterion\n\nA structure that specifies a maximum iteration stopping criterion. That is, once a method     achieves a certain number of iterations, it stops.\n\nFields\n\nmax_iter::Int64, the maximum number of iterations.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_stops/#RLinearAlgebra.LSStopThreshold","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.LSStopThreshold","text":"LSStopThreshold <: LinSysStopCriterion\n\nA structure that specifies a threshold for sufficient progress as a stopping critertion. That is, once a progress estimator      achieves a certain quality of solution, it stops.\n\nFields\n\nmax_iter::Int64, the maximum number of iterations.\nthreshold::Float64, the value threshold for when sufficient progress has been achieved.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_stops/#RLinearAlgebra.LSStopMA","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.LSStopMA","text":"LSStopMA <: LinSysStopCriterion\n\nA structure that specifies a stopping criterion that incoroporates the randomness of the moving average estimator. That is, once a method     achieves a certain number of iterations, it stops.\n\nFields\n\nmax_iter::Int64, the maximum number of iterations.\nthreshold::Float64, the value of the estimator that is sufficient progress. \ndelta1::Float64, the percent below the threshold does the true value of the progress estimator need to be for not stopping to be a mistake. This is equivalent to stopping too late.\ndelta2::Float64, the percent above the threshold does the true value of the progress estimator need to be for stopping to be a    mistake. This is equivalent to stopping too early.\nchi1::Float64, the probability that the stopping too late action occurs.\nchi2::Float64, the probability that the stopping too early action occurs.\n\nConstructors\n\nCalling LSStopMA(iter) will specify the users desired maximum number of iterations, threshold = 1e-10, delta1 = .9, delta2 = 1.1, chi1 = 0.01, and chi2 = 0.01.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_stops/#Stopping-Function","page":"Linear Solver Stop Criteria","title":"Stopping Function","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"RLinearAlgebra.check_stop_criterion(log::LinSysSolverLog, stop::LinSysStopCriterion) ","category":"page"},{"location":"api/linear_solver_stops/#RLinearAlgebra.check_stop_criterion-Tuple{LinSysSolverLog, LinSysStopCriterion}","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.check_stop_criterion","text":"check_stop_criterion(\n    log::LinSysSolverLog,\n    stop::LinSysStopCriterion\n    )\n\nA common interface for specifying different strategies for stopping log with supertype     LinSysSolverLog. A stop of supertype LinSysStopCriterion can be used to provide     specific multiple implementations of stopping conditions for the same log type.\n\n\n\n\n\n","category":"method"},{"location":"api/linear_solver_stops/#Internal-Functions","page":"Linear Solver Stop Criteria","title":"Internal Functions","text":"","category":"section"},{"location":"api/linear_solver_stops/","page":"Linear Solver Stop Criteria","title":"Linear Solver Stop Criteria","text":"RLinearAlgebra.iota_threshold(hist::LSLogMA, stop::LSStopMA)","category":"page"},{"location":"api/linear_solver_stops/#RLinearAlgebra.iota_threshold-Tuple{LSLogMA, LSStopMA}","page":"Linear Solver Stop Criteria","title":"RLinearAlgebra.iota_threshold","text":"iota_threshold(hist::LSLogMA, stop::LSStopMA)\n\nFunction that computes the stopping criterion using the sub-Exponential distribution from the LSLogMA, and the stopping criterion information in LSSopMA. This function is not exported and thus not directly callable by the user.\n\nInputs\n\nhist::LSLogMA, the log information for the moving average tracking.\nstop::LSStopMA, the stopping information for the stopping criterion.\n\nOuputs\n\nReturns the stoppping criterion value.\n\nPritchard, Nathaniel, and Vivak Patel. \"Solving, Tracking and Stopping Streaming Linear Inverse Problems.\" arXiv preprint arXiv:2201.05741 (2024).\n\n\n\n\n\n","category":"method"},{"location":"man/tracking_overview/#Tracking-an-Iterative-Sketching-Solver","page":"Tracking","title":"Tracking an Iterative Sketching Solver","text":"","category":"section"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"***Here we describe a tracking procedure for the row sketching method. The same descriptions and instructions also apply for the column sketching methods, but use the residual of the normal equations rather than the residual of the linear system***","category":"page"},{"location":"man/tracking_overview/#The-need-for-tracking","page":"Tracking","title":"The need for tracking","text":"","category":"section"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"When using an iterative row sketching method like Randomized Block Kaczmarz to find a x^* such that Ax^*=b for Ain mathbbR^mtimes n, bin mathbbR^n, knowing the quality of the solution is integral for being able to make appropriate stopping decisions. This solution quality can be determined by progress tracking procedures, the most common one being computing the norm squared of the residual of the linear system, Ax_k-b_2^2. Without careful thought progress tracking can undermine the benefits of the iterative sketching procedure. For instance, the update to the sketch is computed using only a sketch of the matrix, SA in mathcalR^p times n, p ll m, and constant vector Sb in mathcalR^p; however, the residual computation requires the accessing the full matrix A to compute. This completely undermines the memory benefits of working with the smaller sketch. Additionally, if p ll sqrtm, which is often the case in practice we can see in the table below that the computational complexity of the update is less than computing the residual.","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"Action Cost Accesses to Full Matrix\nUpdate mathcalO(np^2) 0\nResidual mathcalO(nm) 1\nSketched MA mathcalO(np) 0","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"These cost could be avoided by computing the sketched residual, i.e. S A x - Sb_2^2, but at the cost exact knowledge of  progress. To reduce this randomness Pritchard and Patel propose using  a moving average of the sketched residuals in \"Solving, Tracking  and Stopping Streaming Linear Inverse Problems.\" Specifically they define the progress estimator  $     \\hat \\rhok^\\lambda = \\sum{i-\\lambda +1}^k \\frac{\\|Si A x - Sib\\|_2^2}{\\lambda}, $   where lambda is the width of the moving average window. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"This tracking technique can be used in RLinearAlgebra.jl with the log option LSLogMA() when defining the solver, with a default moving average width of 30.","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify solver\nsolver = RLSSolver(\n    LinSysVecRowRandCyclic(),   # Random Cyclic Sampling\n    LinSysVecRowProjStd(),      # Hyperplane projection\n    LSLogMA(),              # Full Logger: maintains moving average residual history\n    LSStopMaxIterations(200),   # Maximum iterations stopping criterion\n    nothing                     # System solution (not solved yet)\n);\n\n# Solve the system\nsol = rsolve(solver, A, b)","category":"page"},{"location":"man/tracking_overview/#Understanding-how-to-use-the-estimator","page":"Tracking","title":"Understanding how to use the estimator","text":"","category":"section"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"The user is able to choose their own width of the moving average by inputting  lambda2=USER_WIDTH as an option within LSLogMA(). Increasing the width will decrease the variability of the progress estimate and therefore is a suggested action when the matrix is poorly conditioned or has highly variable magnitude of row  norms. However, in most cases the default option of 30 should be  sufficient for reasonable tracking. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"In most cases, it is desirable to in fact use two widths for  the moving average estimator because often at early iterations much of the observed variability in the residuals arises from the  fast convergence of the algorithm. As this variability is primarily because of convergence properties rather than randomness, it is undesirable to smooth this out. Thus, it makes  sense in this phase to use a smaller moving average width, lambda_1, which should typically be set to 1 (the user can change using the option lambda1=SMALLER_WIDTH in LSLogMA()). Once the  algorithm leaves this fast convergence phase it, then the wider moving average window should be used. This switch is determined to be the point where there is no longer monotonic decreases in the norm of the sketched residual. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"If the user wants to compare the performance of the moving average of the sketched residuals to  that of the true residuals then it is possible to input the option true_res=true into LSLogMA(). This will  perform the same moving average tracking procedure, but use the true residual rather than the sketched one.","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"Finally, if the user wants to get uncertainty sets for the sketched residual tracking they can use the function get_uncertainty(), whose use is demonstrated below.  For the uncertainty sets, the user can specify alpha, which indicates the probability that the moving average of the  true residuals falls within outputted interval. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"As an example the user wanted to track a standard row solver  with a moving average of the sketched residuals of width 100 and get a 99% uncertainty sets they could run the following code.  ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"\nusing RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify solver\nsolver = RLSSolver(\n    LinSysVecRowRandCyclic(),   # Random Cyclic Sampling\n    LinSysVecRowProjStd(),      # Hyperplane projection\n    LSLogMA(lambda_2 = 100),    # Full Logger: maintains moving average residual history\n    LSStopMaxIterations(200),   # Maximum iterations stopping criterion\n    nothing                     # System solution (not solved yet)\n);\n\n# Solve the system\nsol = rsolve(solver, A, b)\nbounds = get_uncertainty(sol.log, alpha = .99)","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"Note: If the user is using a subset of identity type sampling method these uncertainty sets will perform conservatively     because of a poor variance estimate. The user can reduce this conservativeness using the option eta=w in      the LSLogMA() settings for the solver, where w is a positive real number that divides the estimated variance of the set.","category":"page"},{"location":"man/tracking_overview/#Stopping","page":"Tracking","title":"Stopping","text":"","category":"section"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"In addition to being able to form the uncertainty sets, Pritchard and Patel also proposed a criterion for stopping when using the sketched moving average estimator. RLinearAlgebra.jl allows for the specification  these methods this can be done using LSStopMA(). To understand the stopping criterion, it is valuable to define some notation. If we allow rho_k^lambda be the moving average of the true residuals, and  hat rho_k^lambda be the moving average of the sketched residuals then two types of errors can occur.  ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"The first can be viewed as stopping too late, and it occurs when the tracking parameter value,  rho_k^lambda leq delta_I upsilon, while hat rho_k^lambda  upsilon, where delta_I  is a user defined parameter that indicates a \"meaningful gap\" between hat rho_k^lambda  and rho_k^lambda. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"The second error type can be viewed as stopping too early, and it occurs when the tracking parameter value,  rho_k^lambda geq delta_II upsilon, while hat rho_k^lambda  upsilon. Where delta_II is a user defined parameter that indicates a \"meaningful gap\" between hat rho_k^lambda and rho_k^lambda. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"Using LSStopMA() ensures that neither of these errors occurs more than the user specified rates xi_I and xi_II. Where xi_I is the upper bound on the probability  the solver is stopped too late and xi_II is an upper bound on the probability that the solver is stopped too early.","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"The options for these stopping criterion parameters are represented by the options delta_I = delta1, delta_II =  delta2 xi_I = chi1, xi_II= chi2, and upsilon= upsilon. By default, upsilon=1e-10, delta1=.9, delta2=1.1, chi_I = .01, chi_{II} = .01. To use the stopping criterion, the user must input a max number of iterations, and specify changes to the default settings as options. So for instance if one wanted to use the stopping criterion with a  maximum iteration of 1000 and upsilon = 1e-3, the following code could be used. ","category":"page"},{"location":"man/tracking_overview/","page":"Tracking","title":"Tracking","text":"\nusing RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify solver\nsolver = RLSSolver(\n    LinSysVecRowRandCyclic(),       # Random Cyclic Sampling\n    LinSysVecRowProjStd(),          # Hyperplane projection\n    LSLogMA(lambda_2 = 100),        # Full Logger: maintains moving average residual history\n    LSStopMA(1000, upsilon=1e-3),   # Maximum iterations stopping criterion\n    nothing                         # System solution (not solved yet)\n);\n\n# Solve the system\nsol = rsolve(solver, A, b)\nbounds = get_uncertainty(sol.log, alpha = .99)","category":"page"},{"location":"api/linear_samplers/#Linear-Samplers","page":"Linear Samplers","title":"Linear Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"Pages = [\"linear_samplers.md\"]","category":"page"},{"location":"api/linear_samplers/#Abstract-Types","page":"Linear Samplers","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysSampler\n\nLinSysVecRowSampler\n\nLinSysVecColSampler\n\nLinSysBlkRowSampler\n\nLinSysBlkColSampler","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysSampler","text":"LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting components     of a linear system.\n\nAliases\n\nLinSysSketch\nLinSysSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowSampler","text":"LinSysVecRowSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a row space     element from a linear system.\n\nAliases\n\nLinSysVecRowSketch\nLinSysVecRowSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecColSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecColSampler","text":"LinSysVecColSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a column space     element from a linear system.\n\nAliases\n\nLinSysVecColSketch\nLinSysVecColSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkRowSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkRowSampler","text":"LinSysBlkRowSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a collection of     row space elements from a linear system.\n\nAliases\n\nLinSysBlkRowSketch\nLinSysBlkRowSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysBlkColSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysBlkColSampler","text":"LinSysBlkColSampler <: LinSysSampler\n\nAbstract supertype for sampling, sketching or deterministically selecting a collection of     column space elements from a linear system.\n\nAliases\n\nLinSysBlkColSketch\nLinSysBlkColSelect\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Vector-Row-Samplers","page":"Linear Samplers","title":"Vector Row Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysVecRowDetermCyclic\n\nLinSysVecRowHopRandCyclic\n\nLinSysVecRowOneRandCyclic\n\nLinSysVecRowPropToNormSampler\n\nLinSysVecRowRandCyclic\n\nLinSysVecRowUnidSampler\n\nLinSysVecRowUnifSampler\n\nLinSysVecRowSparseUnifSampler\n\nLinSysVecRowGaussSampler\n\nLinSysVecRowSparseGaussSampler\n\nLinSysVecRowMaxResidual\n\nLinSysVecRowResidCyclic\n\nLinSysVecRowMaxDistance\n\nLinSysVecRowDistCyclic","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowDetermCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowDetermCyclic","text":"LinSysVecRowDetermCyclic <: LinSysVecRowSelect\n\nAn immutable structure without any fields. Specifies deterministic cycling through the equations of a linear system.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowHopRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowHopRandCyclic","text":"LinSysVecRowHopRandCyclic <: LinSysVecRowSelect\n\nA mutable structure that specifies a cycling through the rows of a linear system, where the cycling order is determined randomly once the current cycling order has been used hop number of times. The solver randomly chooses the cycling order whenever necessary.\n\nFields\n\norder::Union{Vector{Int64},Nothing}\nhop::Int64\n\nConstructors\n\nLinSysVecRowHopRandCyclic() defaults to setting the order to nothing and the hop   to 5 (i.e., each ordering is used five times before sampling a new ordering).\nLinSysVecRowHopRandCyclic(hop::Int64) defaults to setting the order to nothing and   the hop to whatever is specified by the argument.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowOneRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowOneRandCyclic","text":"LinSysVecRowOneRandCyclic <: LinSysVecRowSelect\n\nA mutable structure with a field to store a cycling order. Randomly specifies a cycling order over the equations of a linear system. Once this ordering is specified, the ordering is kept fixed.\n\nFields\n\norder::Union{Vector{Int64},Nothing}\n\nCalling LinSysVecRowOneRandCyclic() defaults to setting order to nothing. The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowPropToNormSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowPropToNormSampler","text":"LinSysVecRowPropToNormSampler{T} <: LinSysVecRowSampler where T <: Categorical\n\nA parametric mutable structure that specifies sampling from the rows of the equation where the probability of selecting a given equation is proportional to the sum of squares of the coefficients of the given equation. The solver will appropriately initialize the distribution.\n\nSee Strohmer, T., Vershynin, R. A Randomized Kaczmarz Algorithm with Exponential Convergence. J Fourier Anal Appl 15, 262 (2009). https://doi.org/10.1007/s00041-008-9030-4\n\nAliases\n\nLinSysVecRowSVSampler\n\nFields\n\ndist::T, a categorical probability distribution.\n\nCalling LinSysVecRowPropToNormSampler() or LinSysVecRowSVSampler() defaults dist to Categorical(1.0).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowRandCyclic","text":"LinSysVecRowRandCyclic <: LinSysVecRowSelect\n\nA mutable structure with a field to store a cycling order. Randomly specifies a cycling order the equations of a linear system. Once this ordering is exhausted by the solver, a new random ordering is specified. This process is repeated\n\nFields\n\norder::Union{Vector{Int64},Nothing}\n\nCalling LinSysVecRowOneRandCyclic() defaults to setting order to nothing. The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowUnidSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowUnidSampler","text":"LinSysVecRowUnidSampler <: LinSysVecRowSampler\n\nAn immutable structure without fields that specifies randomly cycling from the rows of a linear system with uniform probability and with replacement.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowUnifSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowUnifSampler","text":"LinSysVecRowUnifSampler <: LinSysVecRowSampler\n\nAn immutable structure without fields that specifies taking a linear combination of all equations with the coefficients being independent uniform random variables.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowSparseUnifSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowSparseUnifSampler","text":"LinSysVecRowSparseUnifSampler <: LinSysVecRowSelect\n\nA mutable structure that specifies sampling a proporition of the rows of a linear system, scaling each using independent uniform  random variables, and then taking their sum. The proportion of rows sampled without replacement is given by (at most) sparsity which must be  between 0 and 1 (not inclusive).\n\nFields\n\nsparsity::Float64\n\nConstructors\n\nLinSysVecRowSparseUnifSampler() defaults the sparsity level to 0.2.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowGaussSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowGaussSampler","text":"LinSysVecRowGaussSampler <: LinSysVecRowSampler\n\nAn immutable structure without fields that specifies taking a linear combination of all equations with the coefficients being independent Gaussian random variables.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowSparseGaussSampler","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowSparseGaussSampler","text":"LinSysVecRowSparseGaussSampler <: LinSysVecRowSelect\n\nA mutable structure that specifies sampling a proporition of the rows of a linear system, scaling each using independent Gaussian  random variables, and then taking their sum. The proportion of rows sampled without replacement is given by (at most) sparsity which must be  between 0 and 1 (not inclusive).\n\nFields\n\nsparsity::Float64\n\nConstructors\n\nLinSysVecRowSparseUnifSampler() defaults the sparsity level to 0.2.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowMaxResidual","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowMaxResidual","text":"LinSysVecRowMaxResidual <: LinSysVecRowSelect\n\nAn immutable structure without fields that specifies choosing the  linear equation in a system with the largest absolute residual at the current  iterate.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowResidCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowResidCyclic","text":"LinSysVecRowResidCyclic <: LinSysVecRowSelect\n\nA mutable structure with a field to store a cycling order. When the ordering  is not specified, the ordering is filled by looking at the residuals at the current iterate and ordering by decreasing residual. Once the order is exhausted a new order is selected. \n\nFields\n\norder::Vector{Int64}\n\nCalling LinSysVecRowResidCyclic() defaults to setting order to an empty array.  The sample function will handle the re-initialization of the fields once the  system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowMaxDistance","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowMaxDistance","text":"LinSysVecRowMaxDistance <: LinSysVecRowSelect\n\nAn immutable structure without fields that specifies choosing the  linear equation in a system with the largest distance between the current iterate and the hyperplane specified by the equation.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecRowDistCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecRowDistCyclic","text":"LinSysVecRowDistCyclic <: LinSysVecRowSelect\n\nA mutable structure with a field to store a cycling order. When the ordering  is not specified, the ordering is filled in two steps. First, the distances  between the current iterate and all hyperplanes as specified by the equations of the system. Then, the ordering is the indices of these distances in decreasing  order.\n\nFields\n\norder::Vector{Int64}\n\nCalling LinSysVecRowDistCyclic() defaults to setting order to an empty array.  The sample function will handle the re-initialization of the fields once the  system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Vector-Column-Samplers","page":"Linear Samplers","title":"Vector Column Samplers","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"LinSysVecColDetermCyclic\n\nLinSysVecColOneRandCyclic","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecColDetermCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecColDetermCyclic","text":"LinSysVecColDetermCyclic <: LinSysVecColSelect\n\nAn immutable structure without any fields. Specifies deterministic cycling through the columns of a linear system.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#RLinearAlgebra.LinSysVecColOneRandCyclic","page":"Linear Samplers","title":"RLinearAlgebra.LinSysVecColOneRandCyclic","text":"LinSysVecColOneRandCyclic <: LinSysVecColSelect\n\nA mutable structure with a field to store a cycling order. Randomly specifies a cycling order over the equations of a linear system. Once this ordering is specified, the ordering is kept fixed.\n\nFields\n\norder::Vector{Int64}\n\nCalling LinSysVecColOneRandCyclic() defaults to setting order to nothing. The sample function will handle the re-initialization of the fields once the system is provided.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_samplers/#Sample-Function","page":"Linear Samplers","title":"Sample Function","text":"","category":"section"},{"location":"api/linear_samplers/","page":"Linear Samplers","title":"Linear Samplers","text":"RLinearAlgebra.sample(::Nothing,::AbstractArray,::AbstractVector,\n    ::AbstractVector,::Int64)","category":"page"},{"location":"api/linear_samplers/#RLinearAlgebra.sample-Tuple{Nothing, AbstractArray, AbstractVector{T} where T, AbstractVector{T} where T, Int64}","page":"Linear Samplers","title":"RLinearAlgebra.sample","text":"sample(type::T where T<:LinSysSampler,\n    A::AbstractArray,\n    b::AbstractVector,\n    x::AbstractVector,\n    iter::Int64)\n\nA common interface for specifying different strategies for sampling, selecting or sketching     a linear system specified by A and b. The type argument is used to select the an     appropriately defined strategy. The argument x is the current iterate value for the     solution. The arguent iter is the iteration counter.\n\nThe value(s) returned by sample depend on the subtype of LinSysSampler being used.     Specifically,\n\nFor T<:LinSysVecRowSampler, a vector in the row space of A and constant are returned\nFor T<:LinSysVecColSampler, a vector of length(x), the matrix A,   and a scalar-valued residual are returned.\n\n\n\n\n\n","category":"method"},{"location":"api/linear_solver_logs/#Linear-Solver-Logs","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"Pages = [\"linear_solver_logs.md\"]","category":"page"},{"location":"api/linear_solver_logs/#Abstract-Types","page":"Linear Solver Logs","title":"Abstract Types","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"LinSysSolverLog","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LinSysSolverLog","page":"Linear Solver Logs","title":"RLinearAlgebra.LinSysSolverLog","text":"LinSysSolverLog\n\nAbstract supertype for logging information about a randomized linear system solver.\n\nNote, all descendants that are mutable structs must have fields\n\niterations::Int64, which tracks the number of iterations of the solver\nconverged::Bool, which tracks whether the solver has converged to the solution (by some   notion of convergence that is specified by the user).\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#Loggers","page":"Linear Solver Logs","title":"Loggers","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"LSLogOracle\n\nLSLogFull\n\nLSLogMA","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LSLogOracle","page":"Linear Solver Logs","title":"RLinearAlgebra.LSLogOracle","text":"LSLogOracle <: LinSysSolverLog\n\nA mutable structure that stores information about a randomized linear solver's behavior.     The log assumes that the true solution of the system is known and will be supplied.     The goal of this log is usually for research, development, or testing.\n\nFields\n\nsolution::AbstractVector, a solution to the given linear system.\ncollection_rate::Int64, the frequency with which to record information to append to the   remaining fields, starting with the initialization (i.e., iteration 0).\nerror_hist::Vector{Float64}, retains a vector of numbers corresponding to the error   between the iterates of the solver and the solution\nerror_norm::Function, a function that accepts a single vector argument and returns a   scalar. Used to compute the error size.\nresid_hist::Vector{Float64}, retains a vector of numbers corresponding to the residual   (uses the whole system to compute the residual)\nresid_norm::Function, a function that accepts a single vector argument and returns a   scalar. Used to compute the residual size.\niterations::Int64, the number of iterations of the solver.\nconverged::Bool, a flag to indicate whether the system has converged by some measure\n\nConstructors\n\nCalling LSLogOracle(x_star::Vector{Float64}) sets solution = x_star,   collection_rate = 1, error_hist = Float64[], error_norm = norm (Euclidean norm),   resid_hist = Float64[], resid_norm = norm (Euclidean norm), iterations=-1,   and converged = false.\nCalling LSLogOracle(x_star::Vector{Float64}, cr::Int64) sets the structure with the   same parameters as for LSLogOracle(x_star) except collection_rate = cr.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LSLogFull","page":"Linear Solver Logs","title":"RLinearAlgebra.LSLogFull","text":"LSLogFull <: LinSysSolverLog\n\nA mutable structure that stores information about a randomized linear solver's behavior.     The log assumes that the full linear system is available for processing. The goal of     this log is usually for research, development or testing as it is unlikely that the     entire residual vector is readily available.\n\nFields\n\ncollection_rate::Int64, the frequency with which to record information to append to the   remaining fields, starting with the initialization (i.e., iteration 0).\nresid_hist::Vector{Float64}, retains a vector of numbers corresponding to the residual   (uses the whole system to compute the residual)\nresid_norm::Function, a function that accepts a single vector argument and returns a   scalar. Used to compute the residual size.\niterations::Int64, the number of iterations of the solver.\nconverged::Bool, a flag to indicate whether the system has converged by some measure\n\nConstructors\n\nCalling LSLogFull() sets collection_rate = 1, resid_hist = Float64[],   resid_norm = norm (Euclidean norm), iterations = -1, and converged = false.\nCalling LSLogFull(cr::Int64) is the same as calling LSLogFull() except   collection_rate = cr.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#RLinearAlgebra.LSLogMA","page":"Linear Solver Logs","title":"RLinearAlgebra.LSLogMA","text":"LSLogMA <: LinSysSolverLog\n\nA mutable structure that stores information about a randomized linear solver's behavior.     The log assumes that only a random block of full linear system is available for processing.      The goal of this log is usually for all use cases as it acts as a cheap approximation of the      full residual.\n\nFields\n\ncollection_rate::Int64, the frequency with which to record information to append to the   remaining fields, starting with the initialization (i.e., iteration 0).\nma_info::MAInfo, structure that holds information relevant only to moving average,   like the two choices of moving average widths (lambda1 and lambda2), the current moving average  width (lambda), a flag to indicate which moving average regime, between lambda1 and lambda2, is   being used, a vector containing the values to be averaged (res_window), and an indicator of where   the next value should be placed (idx).\nresid_hist::Vector{Float64}, a structure that contains the moving average of the error proxy,   typically the norm of residual or gradient of normal equations.\niota_hist::Vector{Float64}, a structure that contains the moving average of the error proxy,   typically the norm of residual or gradient of normal equations.\nwidth_hist::Vector{Int64}, data structure that contains the widths used in the moving average   calculation at each iteration.\nresid_norm::Function, a function that accepts a single vector argument and returns a   scalar. Used to compute the residual size.\niterations::Int64, the number of iterations of the solver.\nconverged::Bool, a flag to indicate whether the system has converged by some measure.\ntrue_res, a boolean indicating if we want the true residual computed instead of approximate.\ndist_info::DistInfo, a structure that stores information about the sub-Exponential distribution.\n\nConstructors\n\nCalling LSLogMA() sets collection_rate = 1,  lambda1 = 1,   lambda2 = 30, resid_hist = Float64[], iota_hist = Float64[], width_hist = Int64[],    resid_norm = norm (Euclidean norm), iterations = -1, converged = false,    sampler = LinSysVecRowDetermCyclic, max_dimension = 0, sigma2 = nothing, omega = nothing,   eta = 1, and true_res = false. The user can specify their own values of lambda1, lambda2, sigma2, omega, and eta using    key word arguments as inputs into the constructor.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#Log-Function","page":"Linear Solver Logs","title":"Log Function","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"RLinearAlgebra.log_update!(::Nothing,::LinSysSampler,::AbstractVector,::Tuple,::Int64,::Any,::Any)","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.log_update!-Tuple{Nothing, LinSysSampler, AbstractVector{T} where T, Tuple, Int64, Any, Any}","page":"Linear Solver Logs","title":"RLinearAlgebra.log_update!","text":"log_update!(\n    log::LinSysSolverLog,\n    sampler::LinSysSampler,\n    x::AbstractVector,\n    samp:s:Tuple,\n    iter::Int64,\n    A,\n    b)\n\nA common interface for specifying different strategies for updating the log with supertype     LinSysSolverLog. A sampler of supertype LinSysSampler can be used to provide     specific multiple implementations for the same log type. x is the iterate value.     samp is the output generated by the sample function (see linears_samplers.jl).     iter is the current iteration counter. A and b specify the linear system.\n\n\n\n\n\n","category":"method"},{"location":"api/linear_solver_logs/#Log-Specific-Functions","page":"Linear Solver Logs","title":"Log Specific Functions","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"RLinearAlgebra.get_uncertainty(::LSLogMA; alpha = .05)","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.get_uncertainty-Tuple{LSLogMA}","page":"Linear Solver Logs","title":"RLinearAlgebra.get_uncertainty","text":"get_uncertainty(log::LSLogMA; alpha = .95)\n\nA function that takes a LSLogMA type and a confidence level, alpha, and returns credible intervals for for every rho in the log, specifically it returns a tuple with (rho, Upper bound, Lower bound).\n\n\n\n\n\n","category":"method"},{"location":"api/linear_solver_logs/#Internal-Data-Structures","page":"Linear Solver Logs","title":"Internal Data Structures","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"RLinearAlgebra.MAInfo\n\nRLinearAlgebra.DistInfo","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.MAInfo","page":"Linear Solver Logs","title":"RLinearAlgebra.MAInfo","text":"MAInfo\n\nA mutable structure that stores information relevant to the moving average of the progress estimator.\n\nFields\n\nlambda1::Int64, the width of the moving average during the fast convergence phase of the algorithm, this has a default value of one.    \nlambda2::Int64, the width of the moving average in the slower convergence phase, this has a default value of 30.\nlambda::Int64, the value of the moving average width at the current iteration.\nflag::Bool, A boolean indicating which phase we are in, a value of true indicates second phase. \nidx::Int64, The index indcating what value should be replaced in the moving average buffer.\nres_window::Vector{Float64} - The moving average buffer.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#RLinearAlgebra.DistInfo","page":"Linear Solver Logs","title":"RLinearAlgebra.DistInfo","text":"DistInfo\n\nA mutable structure that stores information about the sub-Exponential distribution.\n\nFields\n\nsampler::Union{DataType, Nothing}, The type of sampler being used.\nmax_dimension::Int64, The dimension that is being sampled.\nblock_dimension::Int64, The sampling dimension.\nsigma2::Union{Float64, Nothing}, The variance parameter in the sub-Exponential distribution,   if not given is determined for sampling method.\nomega::Union{Float64, Nothing}, The exponential distrbution parameter, if not given is determined for sampling methods.\neta::Float64, A parameter for adjusting the conservativeness of the distribution, higher value means a less conservative estimate. By default, this is set to one.\n\n\n\n\n\n","category":"type"},{"location":"api/linear_solver_logs/#Internal-Functions","page":"Linear Solver Logs","title":"Internal Functions","text":"","category":"section"},{"location":"api/linear_solver_logs/","page":"Linear Solver Logs","title":"Linear Solver Logs","text":"RLinearAlgebra.update_ma!\n\nRLinearAlgebra.get_SE_constants!","category":"page"},{"location":"api/linear_solver_logs/#RLinearAlgebra.update_ma!","page":"Linear Solver Logs","title":"RLinearAlgebra.update_ma!","text":"update_ma!(\n    log::LSLogMA, \n    res::Union{AbstractVector, Real}, \n    lambda_base::Int64, \n    iter::Int64\n)\n\nFunction that updates the moving average tracking statistic. This function is not exported and thus the user has no direct access. \n\nInputs\n\nlog::LSLogMA, the moving average log structure.\n`res::Union{AbstractVector, Real}, the residual for the current iteration. This could be sketeched or full residual depending on the inputs when creating the log structor.\n\n-lambda_base::Int64, which lambda, between lambda1 and lambda2, is currently being used. -iter::Int64, the current iteration.\n\nOutputs\n\nPerforms and inplace update of the log datatype.\n\n\n\n\n\n","category":"function"},{"location":"api/linear_solver_logs/#RLinearAlgebra.get_SE_constants!","page":"Linear Solver Logs","title":"RLinearAlgebra.get_SE_constants!","text":"get_SE_constants!(log::LSLogMA, sampler::Type{T<:LinSysSampler})\n\nA function that returns a default set of sub-Exponential constants for each sampling method. This function is not exported and thus the user does not have direct access to it. \n\nInputs\n\nlog::LSLogMA, the log containing al the tracking information.\nsampler::Type{LinSysSampler}, the type of sampler being used.\n\nOutputs\n\nPerforms an inplace update of the sub-Exponential constants for the log.\n\n\n\n\n\n","category":"function"},{"location":"#RLinearAlgebra","page":"Home","title":"RLinearAlgebra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RLinearAlgebra is a Julia library for the development and application of randomized algorithms to the solution of linear systems of equations. Because of the large diversity of randomized techniques, rather than offering isolated routine implementations of algorithms, this library implements a series of extendable data structures and methods which allow code reuse.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Currently, we implement data structures which allow the implementation of the following solver categories:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Row Projection Methods (RPM) including randomized Kazmarcz, Gauss-sketch, and sampled Motzkin.\nColumn Projection Methods (CPM) including randomized Coordinate Descent and randomized Gauss Seidel.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Users can use the available algorithms or create new ones by adding new methods. For example, the RPM methods are composed by a sampling and a projection methods. Users can easily create new algorithms by implementing a new row sampling technique and leverage the existing projection methods.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To facilitate benchmarking, we provide an abstract class for solver solution logging and stopping criteria.","category":"page"},{"location":"#Documentation-structure","page":"Home","title":"Documentation structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This documentation serves both as a manual to the library and as an introduction to randomized linear algebra solvers. We divide it in three parts:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Tutorial: here we offer examples of how to solve linear systems with RLinearAlgebra and how to extend the library.\nManual: here we offer an introduction to solving linear systems with randomized linear algebra techniques. We introduce theoretical foundations and we provide code examples with RLinearAlgebra.\nAPI: a detailed description of all the classes and methods of the library.","category":"page"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This work is supported by the National Science Foundation Office of Advanced Cyberinfrastructure under awards 2309445 and 2309446. This material is based upon work supported by the U.S. Department of Energy, Office of Science, under contract number DE-AC02-06CH11357.","category":"page"},{"location":"api/contents/#Randomized-Linear-Solver-Reference","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"","category":"section"},{"location":"api/contents/","page":"Randomized Linear Solver Reference","title":"Randomized Linear Solver Reference","text":"Pages=[\n  \"linear_rsolve.md\",\n  \"linear_samplers.md\",\n  \"linear_solver_routines.md\",\n  \"linear_solver_logs.md\",\n  \"linear_solver_stops.md\"]","category":"page"},{"location":"man/cls_overview/#Solving-Consistent-Linear-Systems","page":"Consistent Linear Systems","title":"Solving Consistent Linear Systems","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"A system linear of equations–-that is, a linear system–-is specified by a   coefficient matrix, A, and a constant vector b A linear system is   consistent if there exists at least one vector x^* such that Ax^* = b. The   set of vectors, x^*, satisfying Ax^* = b are called solutions. A linear   system can be solved by using a Randomized Linear Solver, which   leverages randomization to (hopefully) reduce the amount of computation or   resources needed to (approximately) find a solution to a linear system.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Randomized linear solvers come in a number of varieties and under a number of   names. In this library, a broad set of randomized linear solvers are   encapsulated using a  flexible yet uniform interface that is described below.   Once a randomized linear solver is specified, it is passed to a solver   function (i.e., rsolve or rsolve!) along with the linear system, which   then produces an approximate solution to the linear system.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"We will begin by specifying the quickest way of solving a linear system by using   the default linear solver. We will then show how to pass a user supplied   randomized linear solver to rsolve. Then, we will introduce the   general interface for specifying randomized linear solvers.","category":"page"},{"location":"man/cls_overview/#Solving-a-linear-system-using-defaults","page":"Consistent Linear Systems","title":"Solving a linear system using defaults","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Given a consistent linear system whose coefficient matrix is specified in A    and whose constant vector is provided in b, an approximate solution to the    system is returned by calling rsolve(A,b). For example, sol is an    approximate solution to the generated system in the following script.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Solve the system\nsol = rsolve(A, b);","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"The default solver is hidden in the preceding example, but we can explicitly   construct the default solver and pass it to rsolve as shown in the   following script.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify the default solver and stop it after 200 iterations\nsolver = RLSSolver(200);\n\n# Solve the system\nsol = rsolve(solver, A, b);","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"warning: Warning\nOwing  to randomness, the two scripts will produce two different solutions. This is expected as randomized linear solvers do not have determinism. You can attempt to enforce this by specifying a seed if you wish to check that the solutions produced are identical.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"In the above example, the randomized linear solver, solver, is given by the   constructor RLSSolver with an argument 200, which specifies the   total number of iterations allowed before the algorithm must stop. While we   have explicitly constructed the solver and passed it to rsolve, we   still have hidden many of the components of the randomized solver. In the   next section, we discuss these components.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"note: Note\nFor an in-place solver or to provide an initial iterate, see the documentation for rsolve!.","category":"page"},{"location":"man/cls_overview/#Components-of-a-randomized-linear-system-solver","page":"Consistent Linear Systems","title":"Components of a randomized linear system solver","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"A Randomized Linear Solver specifies the algorithm that is used to find   an approximate solution to a linear system. In this library, a randomized   linear solver is encapsulated by four general and flexible components.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"A sampler (i.e., sketch, selection) is a way of extracting row or column space information from a given linear system.\nA routine for generating a solution or updating an iterate given the information generated by the sampler.\nA logger for recording essential information about the behavior of the randomized linear solver.\nA stopping condition for determining when to terminate the linear solver (e.g., stopping at one iteration for a sketch-then-solve method).","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"These four components are the fields of an RLSSolver struct.   Specifically, these fields are","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"sampler which must be a subtype of LinSysSampler. Subtypes of LinSysSampler specify the type of sampling/sketching/selection method being deployed. See Linear Samplers for a list of available samplers.\nroutine which must be a subtype of LinSysSolveRoutine. Subtypes of LinSysSolveRoutinespecify the method for solving the system that results from applying the sampling method to the original linear system. See Linear Subsolvers for a list of available routines.\nlog which must be a subtype of LinSysSolverLog. Subtypes of LinSysSolverLog provides a struct that specifies what information is stored during execution of the algorithm. See Linear Solver Logs for a list of available logs.\nstop which must be a subtype of LinSysStopCriterion. Subtypes of LinSysStopCriterion determine when the algorithm should stop, and often makes use of log. See Linear Solver Stop Criteria for a list of available stopping criteria.","category":"page"},{"location":"man/cls_overview/#Example:-A-randomized-Kaczmarz-method","page":"Consistent Linear Systems","title":"Example: A randomized Kaczmarz method","text":"","category":"section"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Suppose we have a consistent linear system with coefficient matrix A and   constant vector b.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"note: Note\nThe system can be overdetermined, square or underdetermined. The method will work regardless.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"To solve this system, we will use a randomized linear solver which","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Randomly cycles through the equations of the linear system. That is, it will  randomly permute the equations of the system, cycle through this  permutation, generate another random permutation of the equations of the system, and repeat this process until a stopping condition is reached.\nGenerates a sequence of iterates by projecting onto the hyperplane specified  by the equation generated by the random cycling.\nRecords the (Euclidean) residual norms using the entire system at each  iteration. For a random algorithm, it makes very little sense to compute the  residual norm at each iteration or even at any iteration as this requires  accessing the entire original system, which is likely inefficient for  realistic problems.\nThe solver stops once the system's equations have been visited ten times  each.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"Each of these four components is addressed by the choice of sampler,   routine, log, and stop condition. In sum, these four choices will   be used to specify a solver.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"The sampler that implements the random permutation cycling is implemented  as LinSysVecRowRandCyclic.\nThe routine that implements the projection onto the hyperplane is  implemented as LinSysVecRowProjStd.\nThe log that implements the residual tracking is implemented as    LSLogFull.\nThe stop condition that implements the iteration requirement is  implemented as LSStopMaxIterations. We will pass the iteration at  which we want the algorithm to stop as an argument.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"This example solver can be implemented and used as follows.","category":"page"},{"location":"man/cls_overview/","page":"Consistent Linear Systems","title":"Consistent Linear Systems","text":"using RLinearAlgebra\n\n# Generate a system\nA = rand(20, 5);\nx = rand(5);\nb = A * x;\n\n# Specify solver\nsolver = RLSSolver(\n    LinSysVecRowRandCyclic(),   # Random Cyclic Sampling\n    LinSysVecRowProjStd(),      # Hyperplane projection\n    LSLogFull(),                # Full Logger: maintains residual history\n    LSStopMaxIterations(200),   # Maximum iterations stopping criterion\n    nothing                     # System solution (not solved yet)\n);\n\n# Solve the system\nsol = rsolve(solver, A, b)","category":"page"}]
}
